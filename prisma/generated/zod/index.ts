import { z } from 'zod';
import { Prisma } from '@prisma/client';
import Decimal from 'decimal.js';

/////////////////////////////////////////
// HELPER FUNCTIONS
/////////////////////////////////////////

// JSON
//------------------------------------------------------

export type NullableJsonInput =
  | Prisma.JsonValue
  | null
  | 'JsonNull'
  | 'DbNull'
  | Prisma.NullTypes.DbNull
  | Prisma.NullTypes.JsonNull;

export const transformJsonNull = (v?: NullableJsonInput) => {
  if (!v || v === 'DbNull') return Prisma.DbNull;
  if (v === 'JsonNull') return Prisma.JsonNull;
  return v;
};

export const JsonValueSchema: z.ZodType<Prisma.JsonValue> = z.lazy(() =>
  z.union([
    z.string(),
    z.number(),
    z.boolean(),
    z.literal(null),
    z.record(z.lazy(() => JsonValueSchema.optional())),
    z.array(z.lazy(() => JsonValueSchema))
  ])
);

export type JsonValueType = z.infer<typeof JsonValueSchema>;

export const NullableJsonValue = z
  .union([JsonValueSchema, z.literal('DbNull'), z.literal('JsonNull')])
  .nullable()
  .transform(v => transformJsonNull(v));

export type NullableJsonValueType = z.infer<typeof NullableJsonValue>;

export const InputJsonValueSchema: z.ZodType<Prisma.InputJsonValue> = z.lazy(
  () =>
    z.union([
      z.string(),
      z.number(),
      z.boolean(),
      z.object({ toJSON: z.function(z.tuple([]), z.any()) }),
      z.record(z.lazy(() => z.union([InputJsonValueSchema, z.literal(null)]))),
      z.array(z.lazy(() => z.union([InputJsonValueSchema, z.literal(null)])))
    ])
);

export type InputJsonValueType = z.infer<typeof InputJsonValueSchema>;

// DECIMAL
//------------------------------------------------------

export const DecimalJsLikeSchema: z.ZodType<Prisma.DecimalJsLike> = z.object({
  d: z.array(z.number()),
  e: z.number(),
  s: z.number(),
  toFixed: z.function(z.tuple([]), z.string())
});

export const DECIMAL_STRING_REGEX =
  /^(?:-?Infinity|NaN|-?(?:0[bB][01]+(?:\.[01]+)?(?:[pP][-+]?\d+)?|0[oO][0-7]+(?:\.[0-7]+)?(?:[pP][-+]?\d+)?|0[xX][\da-fA-F]+(?:\.[\da-fA-F]+)?(?:[pP][-+]?\d+)?|(?:\d+|\d*\.\d+)(?:[eE][-+]?\d+)?))$/;

export const isValidDecimalInput = (
  v?: null | string | number | Prisma.DecimalJsLike
): v is string | number | Prisma.DecimalJsLike => {
  if (v === undefined || v === null) return false;
  return (
    (typeof v === 'object' &&
      'd' in v &&
      'e' in v &&
      's' in v &&
      'toFixed' in v) ||
    (typeof v === 'string' && DECIMAL_STRING_REGEX.test(v)) ||
    typeof v === 'number'
  );
};

/////////////////////////////////////////
// ENUMS
/////////////////////////////////////////

export const TransactionIsolationLevelSchema = z.enum([
  'ReadUncommitted',
  'ReadCommitted',
  'RepeatableRead',
  'Serializable'
]);

export const TwoFactorConfirmationScalarFieldEnumSchema = z.enum([
  'id',
  'userId'
]);

export const RelationLoadStrategySchema = z.enum(['query', 'join']);

export const AccountScalarFieldEnumSchema = z.enum([
  'id',
  'providerId',
  'providerAccountId',
  'password',
  'refresh_token',
  'access_token',
  'expires_at',
  'scope',
  'id_token',
  'createdAt',
  'updatedAt',
  'userId'
]);

export const SessionScalarFieldEnumSchema = z.enum([
  'id',
  'sessionToken',
  'expires',
  'ipAddress',
  'userAgent',
  'createdAt',
  'updatedAt',
  'userId'
]);

export const VerificationScalarFieldEnumSchema = z.enum([
  'id',
  'identifier',
  'value',
  'expiresAt',
  'createdAt',
  'updatedAt'
]);

export const AuthenticatorScalarFieldEnumSchema = z.enum([
  'id',
  'credentialID',
  'providerAccountId',
  'credentialPublicKey',
  'counter',
  'credentialDeviceType',
  'credentialBackedUp',
  'transports',
  'userId'
]);

export const PasswordResetTokenScalarFieldEnumSchema = z.enum([
  'id',
  'email',
  'token',
  'expires'
]);

export const TwoFactorTokenScalarFieldEnumSchema = z.enum([
  'id',
  'email',
  'token',
  'expires'
]);

export const CustomerScalarFieldEnumSchema = z.enum([
  'stripe_customer_id',
  'id'
]);

export const ProductScalarFieldEnumSchema = z.enum([
  'id',
  'active',
  'name',
  'description',
  'image',
  'metadata'
]);

export const PriceScalarFieldEnumSchema = z.enum([
  'id',
  'active',
  'description',
  'unit_amount',
  'currency',
  'type',
  'interval',
  'interval_count',
  'trial_period_days',
  'metadata',
  'productId'
]);

export const SubscriptionScalarFieldEnumSchema = z.enum([
  'id',
  'status',
  'metadata',
  'quantity',
  'cancel_at_period_end',
  'created',
  'current_period_start',
  'current_period_end',
  'ended_at',
  'cancel_at',
  'canceled_at',
  'trial_start',
  'trial_end',
  'priceId',
  'userId'
]);

export const FeedScalarFieldEnumSchema = z.enum([
  'id',
  'type',
  'content',
  'commentable',
  'createdAt',
  'updatedAt',
  'siteId',
  'userId'
]);

export const CommentScalarFieldEnumSchema = z.enum([
  'id',
  'content',
  'createdAt',
  'updatedAt',
  'feedId',
  'userId'
]);

export const CityScalarFieldEnumSchema = z.enum([
  'id',
  'departement',
  'slug',
  'nom',
  'nomSimple',
  'nomReel',
  'nomSoundex',
  'nomMetaphone',
  'codePostal',
  'commune',
  'codeCommune',
  'arrondissement',
  'canton',
  'amdi',
  'population2010',
  'population1999',
  'population2012',
  'densite2010',
  'surface',
  'longitudeDeg',
  'latitudeDeg',
  'longitudeGrd',
  'latitudeGrd',
  'longitudeDms',
  'latitudeDms',
  'zmin',
  'zmax'
]);

export const NafSectionScalarFieldEnumSchema = z.enum(['id', 'title']);

export const NafDivisionScalarFieldEnumSchema = z.enum([
  'id',
  'title',
  'sectionId'
]);

export const NafGroupScalarFieldEnumSchema = z.enum([
  'id',
  'title',
  'divisionId'
]);

export const NafClassScalarFieldEnumSchema = z.enum(['id', 'title', 'groupId']);

export const NafCodeScalarFieldEnumSchema = z.enum(['id', 'title', 'classId']);

export const OutboxScalarFieldEnumSchema = z.enum([
  'id',
  'email',
  'subject',
  'body',
  'status',
  'metadata',
  'createdAt',
  'campaignId'
]);

export const ListScalarFieldEnumSchema = z.enum([
  'id',
  'title',
  'description',
  'createdAt',
  'updatedAt'
]);

export const CampaignScalarFieldEnumSchema = z.enum([
  'id',
  'type',
  'smart',
  'title',
  'description',
  'active',
  'createdAt',
  'updatedAt',
  'listId',
  'emailId'
]);

export const EmailScalarFieldEnumSchema = z.enum([
  'id',
  'title',
  'description',
  'subject',
  'content',
  'design',
  'createdAt',
  'updatedAt',
  'userId'
]);

export const MediaScalarFieldEnumSchema = z.enum([
  'id',
  'entityId',
  'entityType',
  'url',
  'alt',
  'type',
  'position',
  'isMain',
  'createdAt',
  'updatedAt'
]);

export const ClickScalarFieldEnumSchema = z.enum([
  'id',
  'part',
  'path',
  'request',
  'createdAt',
  'blockId',
  'siteId',
  'linkId',
  'userId',
  'refererId'
]);

export const LinkScalarFieldEnumSchema = z.enum([
  'id',
  'url',
  'name',
  'description',
  'createdAt',
  'updatedAt',
  'userId'
]);

export const BlockScalarFieldEnumSchema = z.enum([
  'id',
  'type',
  'position',
  'label',
  'href',
  'logo',
  'style',
  'widget',
  'createdAt',
  'updatedAt',
  'siteId'
]);

export const LikeScalarFieldEnumSchema = z.enum([
  'id',
  'ip',
  'createdAt',
  'siteId',
  'userId',
  'feedId'
]);

export const SiteScalarFieldEnumSchema = z.enum([
  'id',
  'name',
  'display_name',
  'description',
  'logo',
  'font',
  'image',
  'imageBlurhash',
  'subdomain',
  'customDomain',
  'message404',
  'background',
  'createdAt',
  'updatedAt',
  'userId'
]);

export const SubscriberScalarFieldEnumSchema = z.enum([
  'id',
  'email',
  'createdAt',
  'updatedAt',
  'siteId'
]);

export const ReservationScalarFieldEnumSchema = z.enum([
  'id',
  'type',
  'name',
  'email',
  'dateStart',
  'dateEnd',
  'comment',
  'createdAt',
  'updatedAt',
  'blockId',
  'affiliateId'
]);

export const CategoryScalarFieldEnumSchema = z.enum([
  'id',
  'name',
  'description',
  'slug',
  'active',
  'position',
  'createdAt',
  'updatedAt',
  'categoryId',
  'blockId'
]);

export const InventoryScalarFieldEnumSchema = z.enum([
  'id',
  'name',
  'description',
  'slug',
  'sku',
  'basePrice',
  'active',
  'isFeatured',
  'metaTitle',
  'metaDescription',
  'tags',
  'stock',
  'createdAt',
  'updatedAt',
  'categoryId',
  'blockId'
]);

export const InventoryVariantScalarFieldEnumSchema = z.enum([
  'id',
  'inventoryId',
  'name',
  'value',
  'type',
  'price',
  'stock',
  'active',
  'position',
  'createdAt',
  'updatedAt'
]);

export const CronScalarFieldEnumSchema = z.enum([
  'id',
  'name',
  'cronExpr',
  'timezone',
  'modulePath',
  'functionName',
  'enabled',
  'lastRunAt',
  'lastStatus',
  'lastDurationMs',
  'lockedAt',
  'createdAt',
  'updatedAt'
]);

export const HistoryScalarFieldEnumSchema = z.enum([
  'id',
  'status',
  'startedAt',
  'endedAt',
  'durationMs',
  'message',
  'cronId',
  'createdAt'
]);

export const UserScalarFieldEnumSchema = z.enum([
  'id',
  'name',
  'email',
  'emailVerified',
  'image',
  'isTwoFactorEnabled',
  'billing_address',
  'payment_method',
  'company',
  'address',
  'location',
  'postcode',
  'city',
  'phone',
  'activity',
  'bounced',
  'affiliateRate',
  'isAnonymous',
  'createdAt',
  'updatedAt',
  'role',
  'refererId',
  'codeNaf'
]);

export const MessageScalarFieldEnumSchema = z.enum([
  'id',
  'content',
  'createdAt',
  'senderEmail',
  'receiveEmail'
]);

export const FeedbackScalarFieldEnumSchema = z.enum([
  'id',
  'message',
  'createdAt',
  'updatedAt',
  'userId'
]);

export const QueueScalarFieldEnumSchema = z.enum([
  'id',
  'job',
  'payload',
  'status',
  'attempts',
  'lastError',
  'runAt',
  'priority',
  'processingStartedAt',
  'correlationId',
  'createdAt',
  'updatedAt',
  'userId'
]);

export const ActionScalarFieldEnumSchema = z.enum([
  'id',
  'code',
  'description',
  'type',
  'config',
  'isPublished',
  'version',
  'createdAt',
  'updatedAt'
]);

export const WorkflowScalarFieldEnumSchema = z.enum([
  'id',
  'name',
  'description',
  'isDefault',
  'isActive',
  'createdAt',
  'updatedAt'
]);

export const TriggerScalarFieldEnumSchema = z.enum([
  'id',
  'code',
  'description'
]);

export const RuleScalarFieldEnumSchema = z.enum([
  'id',
  'workflowId',
  'actionId',
  'triggerId',
  'delayMinutes',
  'order',
  'isActive',
  'version'
]);

export const ConditionScalarFieldEnumSchema = z.enum([
  'id',
  'name',
  'description',
  'type',
  'parameters',
  'createdAt',
  'updatedAt'
]);

export const RuleConditionScalarFieldEnumSchema = z.enum([
  'ruleId',
  'conditionId',
  'group',
  'logic'
]);

export const EventScalarFieldEnumSchema = z.enum([
  'id',
  'userId',
  'eventType',
  'payload',
  'correlationId',
  'createdAt',
  'status',
  'attempts',
  'lastError'
]);

export const WorkflowStateScalarFieldEnumSchema = z.enum([
  'id',
  'userId',
  'workflowId',
  'status',
  'startedAt',
  'updatedAt'
]);

export const ExecutionScalarFieldEnumSchema = z.enum([
  'id',
  'userId',
  'actionId',
  'ruleId',
  'executedAt',
  'status',
  'errorMessage',
  'resultPayload',
  'correlationId'
]);

export const SortOrderSchema = z.enum(['asc', 'desc']);

export const JsonNullValueInputSchema = z
  .enum(['JsonNull'])
  .transform(value => (value === 'JsonNull' ? Prisma.JsonNull : value));

export const NullableJsonNullValueInputSchema = z
  .enum(['DbNull', 'JsonNull'])
  .transform(value =>
    value === 'JsonNull'
      ? Prisma.JsonNull
      : value === 'DbNull'
        ? Prisma.DbNull
        : value
  );

export const QueryModeSchema = z.enum(['default', 'insensitive']);

export const NullsOrderSchema = z.enum(['first', 'last']);

export const JsonNullValueFilterSchema = z
  .enum(['DbNull', 'JsonNull', 'AnyNull'])
  .transform(value =>
    value === 'JsonNull'
      ? Prisma.JsonNull
      : value === 'DbNull'
        ? Prisma.JsonNull
        : value === 'AnyNull'
          ? Prisma.AnyNull
          : value
  );

export const PricingTypeSchema = z.enum(['one_time', 'recurring']);

export type PricingTypeType = `${z.infer<typeof PricingTypeSchema>}`;

export const PricingPlanIntervalSchema = z.enum([
  'day',
  'week',
  'month',
  'year'
]);

export type PricingPlanIntervalType =
  `${z.infer<typeof PricingPlanIntervalSchema>}`;

export const SubscriptionStatusSchema = z.enum([
  'trialing',
  'active',
  'canceled',
  'incomplete',
  'incomplete_expired',
  'past_due',
  'unpaid',
  'paused'
]);

export type SubscriptionStatusType =
  `${z.infer<typeof SubscriptionStatusSchema>}`;

export const FeedTypeSchema = z.enum(['TEXT', 'MEDIA', 'BLOCK']);

export type FeedTypeType = `${z.infer<typeof FeedTypeSchema>}`;

export const CampaignTypeSchema = z.enum([
  'email',
  'sms',
  'ads',
  'push',
  'offline'
]);

export type CampaignTypeType = `${z.infer<typeof CampaignTypeSchema>}`;

export const MediaTypeSchema = z.enum(['IMAGE', 'VIDEO']);

export type MediaTypeType = `${z.infer<typeof MediaTypeSchema>}`;

export const EntityTypeSchema = z.enum([
  'INVENTORY',
  'CATEGORY',
  'BLOCK',
  'USER'
]);

export type EntityTypeType = `${z.infer<typeof EntityTypeSchema>}`;

export const VariantTypeSchema = z.enum([
  'SIZE',
  'COLOR',
  'MATERIAL',
  'STYLE',
  'OTHER'
]);

export type VariantTypeType = `${z.infer<typeof VariantTypeSchema>}`;

export const UserRoleSchema = z.enum([
  'USER',
  'ADMIN',
  'SELLER',
  'LEAD',
  'GUEST'
]);

export type UserRoleType = `${z.infer<typeof UserRoleSchema>}`;

export const ConditionTypeSchema = z.enum([
  'USER_PROPERTY',
  'SUBSCRIPTION_STATUS',
  'EVENT_HISTORY_COUNT',
  'EVENT_HISTORY_EXISTS',
  'TRIGGER_PAYLOAD'
]);

export type ConditionTypeType = `${z.infer<typeof ConditionTypeSchema>}`;

export const OperatorSchema = z.enum(['AND', 'OR']);

export type OperatorType = `${z.infer<typeof OperatorSchema>}`;

export const WorkflowStateStatusSchema = z.enum([
  'ACTIVE',
  'COMPLETED',
  'CANCELLED'
]);

export type WorkflowStateStatusType =
  `${z.infer<typeof WorkflowStateStatusSchema>}`;

export const ExecutionStatusSchema = z.enum([
  'PENDING',
  'PROCESSING',
  'SUCCESS',
  'FAILED'
]);

export type ExecutionStatusType = `${z.infer<typeof ExecutionStatusSchema>}`;

/////////////////////////////////////////
// MODELS
/////////////////////////////////////////

/////////////////////////////////////////
// TWO FACTOR CONFIRMATION SCHEMA
/////////////////////////////////////////

export const TwoFactorConfirmationSchema = z.object({
  id: z.string().cuid(),
  userId: z.string()
});

export type TwoFactorConfirmation = z.infer<typeof TwoFactorConfirmationSchema>;

/////////////////////////////////////////
// ACCOUNT SCHEMA
/////////////////////////////////////////

export const AccountSchema = z.object({
  id: z.string().cuid(),
  providerId: z.string().nullable(),
  providerAccountId: z.string(),
  password: z.string().nullable(),
  refresh_token: z.string().nullable(),
  access_token: z.string().nullable(),
  expires_at: z.number().int().nullable(),
  scope: z.string().nullable(),
  id_token: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  userId: z.string()
});

export type Account = z.infer<typeof AccountSchema>;

/////////////////////////////////////////
// SESSION SCHEMA
/////////////////////////////////////////

export const SessionSchema = z.object({
  id: z.string().cuid(),
  sessionToken: z.string(),
  expires: z.coerce.date(),
  ipAddress: z.string().nullable(),
  userAgent: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  userId: z.string()
});

export type Session = z.infer<typeof SessionSchema>;

/////////////////////////////////////////
// VERIFICATION SCHEMA
/////////////////////////////////////////

export const VerificationSchema = z.object({
  id: z.string().cuid(),
  identifier: z.string(),
  value: z.string(),
  expiresAt: z.coerce.date(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date()
});

export type Verification = z.infer<typeof VerificationSchema>;

/////////////////////////////////////////
// AUTHENTICATOR SCHEMA
/////////////////////////////////////////

export const AuthenticatorSchema = z.object({
  id: z.string().cuid(),
  credentialID: z.string(),
  providerAccountId: z.string(),
  credentialPublicKey: z.string(),
  counter: z.number().int(),
  credentialDeviceType: z.string(),
  credentialBackedUp: z.boolean(),
  transports: z.string().nullable(),
  userId: z.string()
});

export type Authenticator = z.infer<typeof AuthenticatorSchema>;

/////////////////////////////////////////
// PASSWORD RESET TOKEN SCHEMA
/////////////////////////////////////////

export const PasswordResetTokenSchema = z.object({
  id: z.string().cuid(),
  email: z.string(),
  token: z.string(),
  expires: z.coerce.date()
});

export type PasswordResetToken = z.infer<typeof PasswordResetTokenSchema>;

/////////////////////////////////////////
// TWO FACTOR TOKEN SCHEMA
/////////////////////////////////////////

export const TwoFactorTokenSchema = z.object({
  id: z.string().cuid(),
  email: z.string(),
  token: z.string(),
  expires: z.coerce.date()
});

export type TwoFactorToken = z.infer<typeof TwoFactorTokenSchema>;

/////////////////////////////////////////
// CUSTOMER SCHEMA
/////////////////////////////////////////

export const CustomerSchema = z.object({
  stripe_customer_id: z.string(),
  id: z.string()
});

export type Customer = z.infer<typeof CustomerSchema>;

/////////////////////////////////////////
// PRODUCT SCHEMA
/////////////////////////////////////////

export const ProductSchema = z.object({
  id: z.string(),
  active: z.boolean(),
  name: z.string(),
  description: z.string(),
  image: z.string(),
  metadata: JsonValueSchema
});

export type Product = z.infer<typeof ProductSchema>;

/////////////////////////////////////////
// PRICE SCHEMA
/////////////////////////////////////////

export const PriceSchema = z.object({
  type: PricingTypeSchema,
  interval: PricingPlanIntervalSchema.nullable(),
  id: z.string(),
  active: z.boolean(),
  description: z.string(),
  unit_amount: z.number().int().nullable(),
  currency: z.string(),
  interval_count: z.number().int().nullable(),
  trial_period_days: z.number().int().nullable(),
  metadata: JsonValueSchema,
  productId: z.string()
});

export type Price = z.infer<typeof PriceSchema>;

/////////////////////////////////////////
// SUBSCRIPTION SCHEMA
/////////////////////////////////////////

export const SubscriptionSchema = z.object({
  status: SubscriptionStatusSchema,
  id: z.string(),
  metadata: JsonValueSchema,
  quantity: z.number().int(),
  cancel_at_period_end: z.boolean(),
  created: z.coerce.date(),
  current_period_start: z.coerce.date(),
  current_period_end: z.coerce.date(),
  ended_at: z.coerce.date().nullable(),
  cancel_at: z.coerce.date().nullable(),
  canceled_at: z.coerce.date().nullable(),
  trial_start: z.coerce.date().nullable(),
  trial_end: z.coerce.date().nullable(),
  priceId: z.string(),
  userId: z.string()
});

export type Subscription = z.infer<typeof SubscriptionSchema>;

/////////////////////////////////////////
// FEED SCHEMA
/////////////////////////////////////////

export const FeedSchema = z.object({
  type: FeedTypeSchema,
  id: z.string().cuid(),
  content: JsonValueSchema,
  commentable: z.boolean(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  siteId: z.string(),
  userId: z.string()
});

export type Feed = z.infer<typeof FeedSchema>;

/////////////////////////////////////////
// COMMENT SCHEMA
/////////////////////////////////////////

export const CommentSchema = z.object({
  id: z.string().cuid(),
  content: z.string(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  feedId: z.string().nullable(),
  userId: z.string()
});

export type Comment = z.infer<typeof CommentSchema>;

/////////////////////////////////////////
// CITY SCHEMA
/////////////////////////////////////////

export const CitySchema = z.object({
  id: z.number().int(),
  departement: z.string().nullable(),
  slug: z.string().nullable(),
  nom: z.string().nullable(),
  nomSimple: z.string().nullable(),
  nomReel: z.string().nullable(),
  nomSoundex: z.string().nullable(),
  nomMetaphone: z.string().nullable(),
  codePostal: z.string().nullable(),
  commune: z.string().nullable(),
  codeCommune: z.string(),
  arrondissement: z.number().int().nullable(),
  canton: z.string().nullable(),
  amdi: z.number().int().nullable(),
  population2010: z.number().int().nullable(),
  population1999: z.number().int().nullable(),
  population2012: z.number().int().nullable(),
  densite2010: z.number().int().nullable(),
  surface: z.number().nullable(),
  longitudeDeg: z.number().nullable(),
  latitudeDeg: z.number().nullable(),
  longitudeGrd: z.string().nullable(),
  latitudeGrd: z.string().nullable(),
  longitudeDms: z.string().nullable(),
  latitudeDms: z.string().nullable(),
  zmin: z.number().int().nullable(),
  zmax: z.number().int().nullable()
});

export type City = z.infer<typeof CitySchema>;

/////////////////////////////////////////
// NAF SECTION SCHEMA
/////////////////////////////////////////

export const NafSectionSchema = z.object({
  id: z.string(),
  title: z.string()
});

export type NafSection = z.infer<typeof NafSectionSchema>;

/////////////////////////////////////////
// NAF DIVISION SCHEMA
/////////////////////////////////////////

export const NafDivisionSchema = z.object({
  id: z.string(),
  title: z.string(),
  sectionId: z.string()
});

export type NafDivision = z.infer<typeof NafDivisionSchema>;

/////////////////////////////////////////
// NAF GROUP SCHEMA
/////////////////////////////////////////

export const NafGroupSchema = z.object({
  id: z.string(),
  title: z.string(),
  divisionId: z.string()
});

export type NafGroup = z.infer<typeof NafGroupSchema>;

/////////////////////////////////////////
// NAF CLASS SCHEMA
/////////////////////////////////////////

export const NafClassSchema = z.object({
  id: z.string(),
  title: z.string(),
  groupId: z.string()
});

export type NafClass = z.infer<typeof NafClassSchema>;

/////////////////////////////////////////
// NAF CODE SCHEMA
/////////////////////////////////////////

export const NafCodeSchema = z.object({
  id: z.string(),
  title: z.string(),
  classId: z.string()
});

export type NafCode = z.infer<typeof NafCodeSchema>;

/////////////////////////////////////////
// OUTBOX SCHEMA
/////////////////////////////////////////

export const OutboxSchema = z.object({
  id: z.string().cuid(),
  email: z.string(),
  subject: z.string(),
  body: z.string(),
  status: z.string(),
  metadata: JsonValueSchema.nullable(),
  createdAt: z.coerce.date(),
  campaignId: z.string().nullable()
});

export type Outbox = z.infer<typeof OutboxSchema>;

/////////////////////////////////////////
// LIST SCHEMA
/////////////////////////////////////////

export const ListSchema = z.object({
  id: z.string().cuid(),
  title: z.string(),
  description: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date()
});

export type List = z.infer<typeof ListSchema>;

/////////////////////////////////////////
// CAMPAIGN SCHEMA
/////////////////////////////////////////

export const CampaignSchema = z.object({
  type: CampaignTypeSchema,
  id: z.string().cuid(),
  smart: z.boolean(),
  title: z.string(),
  description: z.string().nullable(),
  active: z.boolean(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  listId: z.string().nullable(),
  emailId: z.string()
});

export type Campaign = z.infer<typeof CampaignSchema>;

/////////////////////////////////////////
// EMAIL SCHEMA
/////////////////////////////////////////

export const EmailSchema = z.object({
  id: z.string().cuid(),
  title: z.string(),
  description: z.string().nullable(),
  subject: z.string(),
  content: z.string(),
  design: JsonValueSchema,
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  userId: z.string()
});

export type Email = z.infer<typeof EmailSchema>;

/////////////////////////////////////////
// MEDIA SCHEMA
/////////////////////////////////////////

export const MediaSchema = z.object({
  entityType: EntityTypeSchema,
  type: MediaTypeSchema,
  id: z.string().cuid(),
  entityId: z.string(),
  url: z.string(),
  alt: z.string().nullable(),
  position: z.number().int(),
  isMain: z.boolean(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date()
});

export type Media = z.infer<typeof MediaSchema>;

/////////////////////////////////////////
// CLICK SCHEMA
/////////////////////////////////////////

export const ClickSchema = z.object({
  id: z.string().cuid(),
  part: z.string().nullable(),
  path: z.string().nullable(),
  request: JsonValueSchema.nullable(),
  createdAt: z.coerce.date(),
  blockId: z.string().nullable(),
  siteId: z.string().nullable(),
  linkId: z.string().nullable(),
  userId: z.string().nullable(),
  refererId: z.string().nullable()
});

export type Click = z.infer<typeof ClickSchema>;

/////////////////////////////////////////
// LINK SCHEMA
/////////////////////////////////////////

export const LinkSchema = z.object({
  id: z.string(),
  url: z.string(),
  name: z.string().nullable(),
  description: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  userId: z.string().nullable()
});

export type Link = z.infer<typeof LinkSchema>;

/////////////////////////////////////////
// BLOCK SCHEMA
/////////////////////////////////////////

export const BlockSchema = z.object({
  id: z.string().cuid(),
  type: z.string(),
  position: z.number().int(),
  label: z.string().nullable(),
  href: z.string().nullable(),
  logo: z.string().nullable(),
  style: JsonValueSchema.nullable(),
  widget: JsonValueSchema.nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  siteId: z.string()
});

export type Block = z.infer<typeof BlockSchema>;

/////////////////////////////////////////
// LIKE SCHEMA
/////////////////////////////////////////

export const LikeSchema = z.object({
  id: z.string().cuid(),
  ip: z.string(),
  createdAt: z.coerce.date(),
  siteId: z.string(),
  userId: z.string().nullable(),
  feedId: z.string().nullable()
});

export type Like = z.infer<typeof LikeSchema>;

/////////////////////////////////////////
// SITE SCHEMA
/////////////////////////////////////////

export const SiteSchema = z.object({
  id: z.string().cuid(),
  name: z.string().nullable(),
  display_name: z.string().nullable(),
  description: z.string().nullable(),
  logo: z.string().nullable(),
  font: z.string(),
  image: z.string().nullable(),
  imageBlurhash: z.string().nullable(),
  subdomain: z.string().nullable(),
  customDomain: z.string().nullable(),
  message404: z.string().nullable(),
  background: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  userId: z.string()
});

export type Site = z.infer<typeof SiteSchema>;

/////////////////////////////////////////
// SUBSCRIBER SCHEMA
/////////////////////////////////////////

export const SubscriberSchema = z.object({
  id: z.string().cuid(),
  email: z.string(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  siteId: z.string()
});

export type Subscriber = z.infer<typeof SubscriberSchema>;

/////////////////////////////////////////
// RESERVATION SCHEMA
/////////////////////////////////////////

export const ReservationSchema = z.object({
  id: z.string().cuid(),
  type: z.string().nullable(),
  name: z.string().nullable(),
  email: z.string(),
  dateStart: z.coerce.date(),
  dateEnd: z.coerce.date().nullable(),
  comment: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  blockId: z.string().nullable(),
  affiliateId: z.string().nullable()
});

export type Reservation = z.infer<typeof ReservationSchema>;

/////////////////////////////////////////
// CATEGORY SCHEMA
/////////////////////////////////////////

export const CategorySchema = z.object({
  id: z.string().cuid(),
  name: z.string(),
  description: z.string().nullable(),
  slug: z.string(),
  active: z.boolean(),
  position: z.number().int(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  categoryId: z.string().nullable(),
  blockId: z.string()
});

export type Category = z.infer<typeof CategorySchema>;

/////////////////////////////////////////
// INVENTORY SCHEMA
/////////////////////////////////////////

export const InventorySchema = z.object({
  id: z.string().cuid(),
  name: z.string(),
  description: z.string().nullable(),
  slug: z.string(),
  sku: z.string().nullable(),
  basePrice: z.number(),
  active: z.boolean(),
  isFeatured: z.boolean(),
  metaTitle: z.string().nullable(),
  metaDescription: z.string().nullable(),
  tags: z.string().array(),
  stock: z.number().int(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  categoryId: z.string().nullable(),
  blockId: z.string()
});

export type Inventory = z.infer<typeof InventorySchema>;

/////////////////////////////////////////
// INVENTORY VARIANT SCHEMA
/////////////////////////////////////////

export const InventoryVariantSchema = z.object({
  type: VariantTypeSchema,
  id: z.string().cuid(),
  inventoryId: z.string(),
  name: z.string(),
  value: z.string(),
  price: z
    .instanceof(Prisma.Decimal, {
      message:
        "Field 'price' must be a Decimal. Location: ['Models', 'InventoryVariant']"
    })
    .nullable(),
  stock: z.number().int(),
  active: z.boolean(),
  position: z.number().int(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date()
});

export type InventoryVariant = z.infer<typeof InventoryVariantSchema>;

/////////////////////////////////////////
// CRON SCHEMA
/////////////////////////////////////////

export const CronSchema = z.object({
  id: z.string().cuid(),
  name: z.string(),
  cronExpr: z.string(),
  timezone: z.string(),
  modulePath: z.string(),
  functionName: z.string(),
  enabled: z.boolean(),
  lastRunAt: z.coerce.date().nullable(),
  lastStatus: z.string().nullable(),
  lastDurationMs: z.number().int().nullable(),
  lockedAt: z.coerce.date().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date()
});

export type Cron = z.infer<typeof CronSchema>;

/////////////////////////////////////////
// HISTORY SCHEMA
/////////////////////////////////////////

export const HistorySchema = z.object({
  id: z.string().cuid(),
  status: z.string(),
  startedAt: z.coerce.date(),
  endedAt: z.coerce.date(),
  durationMs: z.number().int(),
  message: JsonValueSchema.nullable(),
  cronId: z.string(),
  createdAt: z.coerce.date()
});

export type History = z.infer<typeof HistorySchema>;

/////////////////////////////////////////
// USER SCHEMA
/////////////////////////////////////////

export const UserSchema = z.object({
  role: UserRoleSchema,
  id: z.string().cuid(),
  name: z.string().nullable(),
  email: z.string(),
  emailVerified: z.boolean(),
  image: z.string().nullable(),
  isTwoFactorEnabled: z.boolean(),
  billing_address: JsonValueSchema,
  payment_method: JsonValueSchema,
  company: z.string().nullable(),
  address: z.string().nullable(),
  location: JsonValueSchema.nullable(),
  postcode: z.string().nullable(),
  city: z.string().nullable(),
  phone: z.string().nullable(),
  activity: z.string().nullable(),
  bounced: z.number().int(),
  affiliateRate: z.number().nullable(),
  isAnonymous: z.boolean().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  refererId: z.string().nullable(),
  codeNaf: z.string().nullable()
});

export type User = z.infer<typeof UserSchema>;

/////////////////////////////////////////
// MESSAGE SCHEMA
/////////////////////////////////////////

export const MessageSchema = z.object({
  id: z.string().cuid(),
  content: z.string(),
  createdAt: z.coerce.date(),
  senderEmail: z.string(),
  receiveEmail: z.string()
});

export type Message = z.infer<typeof MessageSchema>;

/////////////////////////////////////////
// FEEDBACK SCHEMA
/////////////////////////////////////////

export const FeedbackSchema = z.object({
  id: z.string().cuid(),
  message: z.string(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  userId: z.string().nullable()
});

export type Feedback = z.infer<typeof FeedbackSchema>;

/////////////////////////////////////////
// QUEUE SCHEMA
/////////////////////////////////////////

export const QueueSchema = z.object({
  id: z.string().cuid(),
  job: z.string(),
  payload: JsonValueSchema,
  status: z.string(),
  attempts: z.number().int(),
  lastError: z.string().nullable(),
  runAt: z.coerce.date(),
  priority: z.number().int(),
  processingStartedAt: z.coerce.date().nullable(),
  correlationId: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  userId: z.string().nullable()
});

export type Queue = z.infer<typeof QueueSchema>;

/////////////////////////////////////////
// ACTION SCHEMA
/////////////////////////////////////////

export const ActionSchema = z.object({
  id: z.string().cuid(),
  code: z.string(),
  description: z.string().nullable(),
  type: z.string(),
  config: JsonValueSchema,
  isPublished: z.boolean(),
  version: z.number().int(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date()
});

export type Action = z.infer<typeof ActionSchema>;

/////////////////////////////////////////
// WORKFLOW SCHEMA
/////////////////////////////////////////

export const WorkflowSchema = z.object({
  id: z.string().cuid(),
  name: z.string(),
  description: z.string().nullable(),
  isDefault: z.boolean(),
  isActive: z.boolean(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date()
});

export type Workflow = z.infer<typeof WorkflowSchema>;

/////////////////////////////////////////
// TRIGGER SCHEMA
/////////////////////////////////////////

export const TriggerSchema = z.object({
  id: z.string().cuid(),
  code: z.string(),
  description: z.string().nullable()
});

export type Trigger = z.infer<typeof TriggerSchema>;

/////////////////////////////////////////
// RULE SCHEMA
/////////////////////////////////////////

export const RuleSchema = z.object({
  id: z.string().cuid(),
  workflowId: z.string(),
  actionId: z.string(),
  triggerId: z.string(),
  delayMinutes: z.number().int(),
  order: z.number().int(),
  isActive: z.boolean(),
  version: z.number().int()
});

export type Rule = z.infer<typeof RuleSchema>;

/////////////////////////////////////////
// CONDITION SCHEMA
/////////////////////////////////////////

export const ConditionSchema = z.object({
  type: ConditionTypeSchema,
  id: z.string().cuid(),
  name: z.string(),
  description: z.string().nullable(),
  parameters: JsonValueSchema,
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date()
});

export type Condition = z.infer<typeof ConditionSchema>;

/////////////////////////////////////////
// RULE CONDITION SCHEMA
/////////////////////////////////////////

export const RuleConditionSchema = z.object({
  logic: OperatorSchema,
  ruleId: z.string(),
  conditionId: z.string(),
  group: z.number().int()
});

export type RuleCondition = z.infer<typeof RuleConditionSchema>;

/////////////////////////////////////////
// EVENT SCHEMA
/////////////////////////////////////////

export const EventSchema = z.object({
  id: z.string().cuid(),
  userId: z.string(),
  eventType: z.string(),
  payload: JsonValueSchema.nullable(),
  correlationId: z.string().nullable(),
  createdAt: z.coerce.date(),
  status: z.string(),
  attempts: z.number().int(),
  lastError: z.string().nullable()
});

export type Event = z.infer<typeof EventSchema>;

/////////////////////////////////////////
// WORKFLOW STATE SCHEMA
/////////////////////////////////////////

export const WorkflowStateSchema = z.object({
  status: WorkflowStateStatusSchema,
  id: z.string().cuid(),
  userId: z.string(),
  workflowId: z.string(),
  startedAt: z.coerce.date(),
  updatedAt: z.coerce.date()
});

export type WorkflowState = z.infer<typeof WorkflowStateSchema>;

/////////////////////////////////////////
// EXECUTION SCHEMA
/////////////////////////////////////////

export const ExecutionSchema = z.object({
  status: ExecutionStatusSchema,
  id: z.string().cuid(),
  userId: z.string(),
  actionId: z.string(),
  ruleId: z.string().nullable(),
  executedAt: z.coerce.date().nullable(),
  errorMessage: z.string().nullable(),
  resultPayload: JsonValueSchema.nullable(),
  correlationId: z.string().nullable()
});

export type Execution = z.infer<typeof ExecutionSchema>;

/////////////////////////////////////////
// SELECT & INCLUDE
/////////////////////////////////////////

// TWO FACTOR CONFIRMATION
//------------------------------------------------------

export const TwoFactorConfirmationIncludeSchema: z.ZodType<Prisma.TwoFactorConfirmationInclude> =
  z
    .object({
      user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
    })
    .strict();

export const TwoFactorConfirmationArgsSchema: z.ZodType<Prisma.TwoFactorConfirmationDefaultArgs> =
  z
    .object({
      select: z.lazy(() => TwoFactorConfirmationSelectSchema).optional(),
      include: z.lazy(() => TwoFactorConfirmationIncludeSchema).optional()
    })
    .strict();

export const TwoFactorConfirmationSelectSchema: z.ZodType<Prisma.TwoFactorConfirmationSelect> =
  z
    .object({
      id: z.boolean().optional(),
      userId: z.boolean().optional(),
      user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
    })
    .strict();

// ACCOUNT
//------------------------------------------------------

export const AccountIncludeSchema: z.ZodType<Prisma.AccountInclude> = z
  .object({
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

export const AccountArgsSchema: z.ZodType<Prisma.AccountDefaultArgs> = z
  .object({
    select: z.lazy(() => AccountSelectSchema).optional(),
    include: z.lazy(() => AccountIncludeSchema).optional()
  })
  .strict();

export const AccountSelectSchema: z.ZodType<Prisma.AccountSelect> = z
  .object({
    id: z.boolean().optional(),
    providerId: z.boolean().optional(),
    providerAccountId: z.boolean().optional(),
    password: z.boolean().optional(),
    refresh_token: z.boolean().optional(),
    access_token: z.boolean().optional(),
    expires_at: z.boolean().optional(),
    scope: z.boolean().optional(),
    id_token: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    userId: z.boolean().optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

// SESSION
//------------------------------------------------------

export const SessionIncludeSchema: z.ZodType<Prisma.SessionInclude> = z
  .object({
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

export const SessionArgsSchema: z.ZodType<Prisma.SessionDefaultArgs> = z
  .object({
    select: z.lazy(() => SessionSelectSchema).optional(),
    include: z.lazy(() => SessionIncludeSchema).optional()
  })
  .strict();

export const SessionSelectSchema: z.ZodType<Prisma.SessionSelect> = z
  .object({
    id: z.boolean().optional(),
    sessionToken: z.boolean().optional(),
    expires: z.boolean().optional(),
    ipAddress: z.boolean().optional(),
    userAgent: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    userId: z.boolean().optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

// VERIFICATION
//------------------------------------------------------

export const VerificationSelectSchema: z.ZodType<Prisma.VerificationSelect> = z
  .object({
    id: z.boolean().optional(),
    identifier: z.boolean().optional(),
    value: z.boolean().optional(),
    expiresAt: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional()
  })
  .strict();

// AUTHENTICATOR
//------------------------------------------------------

export const AuthenticatorIncludeSchema: z.ZodType<Prisma.AuthenticatorInclude> =
  z
    .object({
      user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
    })
    .strict();

export const AuthenticatorArgsSchema: z.ZodType<Prisma.AuthenticatorDefaultArgs> =
  z
    .object({
      select: z.lazy(() => AuthenticatorSelectSchema).optional(),
      include: z.lazy(() => AuthenticatorIncludeSchema).optional()
    })
    .strict();

export const AuthenticatorSelectSchema: z.ZodType<Prisma.AuthenticatorSelect> =
  z
    .object({
      id: z.boolean().optional(),
      credentialID: z.boolean().optional(),
      providerAccountId: z.boolean().optional(),
      credentialPublicKey: z.boolean().optional(),
      counter: z.boolean().optional(),
      credentialDeviceType: z.boolean().optional(),
      credentialBackedUp: z.boolean().optional(),
      transports: z.boolean().optional(),
      userId: z.boolean().optional(),
      user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
    })
    .strict();

// PASSWORD RESET TOKEN
//------------------------------------------------------

export const PasswordResetTokenSelectSchema: z.ZodType<Prisma.PasswordResetTokenSelect> =
  z
    .object({
      id: z.boolean().optional(),
      email: z.boolean().optional(),
      token: z.boolean().optional(),
      expires: z.boolean().optional()
    })
    .strict();

// TWO FACTOR TOKEN
//------------------------------------------------------

export const TwoFactorTokenSelectSchema: z.ZodType<Prisma.TwoFactorTokenSelect> =
  z
    .object({
      id: z.boolean().optional(),
      email: z.boolean().optional(),
      token: z.boolean().optional(),
      expires: z.boolean().optional()
    })
    .strict();

// CUSTOMER
//------------------------------------------------------

export const CustomerIncludeSchema: z.ZodType<Prisma.CustomerInclude> = z
  .object({
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

export const CustomerArgsSchema: z.ZodType<Prisma.CustomerDefaultArgs> = z
  .object({
    select: z.lazy(() => CustomerSelectSchema).optional(),
    include: z.lazy(() => CustomerIncludeSchema).optional()
  })
  .strict();

export const CustomerSelectSchema: z.ZodType<Prisma.CustomerSelect> = z
  .object({
    stripe_customer_id: z.boolean().optional(),
    id: z.boolean().optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

// PRODUCT
//------------------------------------------------------

export const ProductIncludeSchema: z.ZodType<Prisma.ProductInclude> = z
  .object({
    prices: z
      .union([z.boolean(), z.lazy(() => PriceFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => ProductCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const ProductArgsSchema: z.ZodType<Prisma.ProductDefaultArgs> = z
  .object({
    select: z.lazy(() => ProductSelectSchema).optional(),
    include: z.lazy(() => ProductIncludeSchema).optional()
  })
  .strict();

export const ProductCountOutputTypeArgsSchema: z.ZodType<Prisma.ProductCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => ProductCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const ProductCountOutputTypeSelectSchema: z.ZodType<Prisma.ProductCountOutputTypeSelect> =
  z
    .object({
      prices: z.boolean().optional()
    })
    .strict();

export const ProductSelectSchema: z.ZodType<Prisma.ProductSelect> = z
  .object({
    id: z.boolean().optional(),
    active: z.boolean().optional(),
    name: z.boolean().optional(),
    description: z.boolean().optional(),
    image: z.boolean().optional(),
    metadata: z.boolean().optional(),
    prices: z
      .union([z.boolean(), z.lazy(() => PriceFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => ProductCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// PRICE
//------------------------------------------------------

export const PriceIncludeSchema: z.ZodType<Prisma.PriceInclude> = z
  .object({
    subscriptions: z
      .union([z.boolean(), z.lazy(() => SubscriptionFindManyArgsSchema)])
      .optional(),
    product: z.union([z.boolean(), z.lazy(() => ProductArgsSchema)]).optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => PriceCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const PriceArgsSchema: z.ZodType<Prisma.PriceDefaultArgs> = z
  .object({
    select: z.lazy(() => PriceSelectSchema).optional(),
    include: z.lazy(() => PriceIncludeSchema).optional()
  })
  .strict();

export const PriceCountOutputTypeArgsSchema: z.ZodType<Prisma.PriceCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => PriceCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const PriceCountOutputTypeSelectSchema: z.ZodType<Prisma.PriceCountOutputTypeSelect> =
  z
    .object({
      subscriptions: z.boolean().optional()
    })
    .strict();

export const PriceSelectSchema: z.ZodType<Prisma.PriceSelect> = z
  .object({
    id: z.boolean().optional(),
    active: z.boolean().optional(),
    description: z.boolean().optional(),
    unit_amount: z.boolean().optional(),
    currency: z.boolean().optional(),
    type: z.boolean().optional(),
    interval: z.boolean().optional(),
    interval_count: z.boolean().optional(),
    trial_period_days: z.boolean().optional(),
    metadata: z.boolean().optional(),
    productId: z.boolean().optional(),
    subscriptions: z
      .union([z.boolean(), z.lazy(() => SubscriptionFindManyArgsSchema)])
      .optional(),
    product: z.union([z.boolean(), z.lazy(() => ProductArgsSchema)]).optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => PriceCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// SUBSCRIPTION
//------------------------------------------------------

export const SubscriptionIncludeSchema: z.ZodType<Prisma.SubscriptionInclude> =
  z
    .object({
      price: z.union([z.boolean(), z.lazy(() => PriceArgsSchema)]).optional(),
      user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
    })
    .strict();

export const SubscriptionArgsSchema: z.ZodType<Prisma.SubscriptionDefaultArgs> =
  z
    .object({
      select: z.lazy(() => SubscriptionSelectSchema).optional(),
      include: z.lazy(() => SubscriptionIncludeSchema).optional()
    })
    .strict();

export const SubscriptionSelectSchema: z.ZodType<Prisma.SubscriptionSelect> = z
  .object({
    id: z.boolean().optional(),
    status: z.boolean().optional(),
    metadata: z.boolean().optional(),
    quantity: z.boolean().optional(),
    cancel_at_period_end: z.boolean().optional(),
    created: z.boolean().optional(),
    current_period_start: z.boolean().optional(),
    current_period_end: z.boolean().optional(),
    ended_at: z.boolean().optional(),
    cancel_at: z.boolean().optional(),
    canceled_at: z.boolean().optional(),
    trial_start: z.boolean().optional(),
    trial_end: z.boolean().optional(),
    priceId: z.boolean().optional(),
    userId: z.boolean().optional(),
    price: z.union([z.boolean(), z.lazy(() => PriceArgsSchema)]).optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

// FEED
//------------------------------------------------------

export const FeedIncludeSchema: z.ZodType<Prisma.FeedInclude> = z
  .object({
    site: z.union([z.boolean(), z.lazy(() => SiteArgsSchema)]).optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    comments: z
      .union([z.boolean(), z.lazy(() => CommentFindManyArgsSchema)])
      .optional(),
    likes: z
      .union([z.boolean(), z.lazy(() => LikeFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => FeedCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const FeedArgsSchema: z.ZodType<Prisma.FeedDefaultArgs> = z
  .object({
    select: z.lazy(() => FeedSelectSchema).optional(),
    include: z.lazy(() => FeedIncludeSchema).optional()
  })
  .strict();

export const FeedCountOutputTypeArgsSchema: z.ZodType<Prisma.FeedCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => FeedCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const FeedCountOutputTypeSelectSchema: z.ZodType<Prisma.FeedCountOutputTypeSelect> =
  z
    .object({
      comments: z.boolean().optional(),
      likes: z.boolean().optional()
    })
    .strict();

export const FeedSelectSchema: z.ZodType<Prisma.FeedSelect> = z
  .object({
    id: z.boolean().optional(),
    type: z.boolean().optional(),
    content: z.boolean().optional(),
    commentable: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    siteId: z.boolean().optional(),
    userId: z.boolean().optional(),
    site: z.union([z.boolean(), z.lazy(() => SiteArgsSchema)]).optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    comments: z
      .union([z.boolean(), z.lazy(() => CommentFindManyArgsSchema)])
      .optional(),
    likes: z
      .union([z.boolean(), z.lazy(() => LikeFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => FeedCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// COMMENT
//------------------------------------------------------

export const CommentIncludeSchema: z.ZodType<Prisma.CommentInclude> = z
  .object({
    feed: z.union([z.boolean(), z.lazy(() => FeedArgsSchema)]).optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

export const CommentArgsSchema: z.ZodType<Prisma.CommentDefaultArgs> = z
  .object({
    select: z.lazy(() => CommentSelectSchema).optional(),
    include: z.lazy(() => CommentIncludeSchema).optional()
  })
  .strict();

export const CommentSelectSchema: z.ZodType<Prisma.CommentSelect> = z
  .object({
    id: z.boolean().optional(),
    content: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    feedId: z.boolean().optional(),
    userId: z.boolean().optional(),
    feed: z.union([z.boolean(), z.lazy(() => FeedArgsSchema)]).optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

// CITY
//------------------------------------------------------

export const CitySelectSchema: z.ZodType<Prisma.CitySelect> = z
  .object({
    id: z.boolean().optional(),
    departement: z.boolean().optional(),
    slug: z.boolean().optional(),
    nom: z.boolean().optional(),
    nomSimple: z.boolean().optional(),
    nomReel: z.boolean().optional(),
    nomSoundex: z.boolean().optional(),
    nomMetaphone: z.boolean().optional(),
    codePostal: z.boolean().optional(),
    commune: z.boolean().optional(),
    codeCommune: z.boolean().optional(),
    arrondissement: z.boolean().optional(),
    canton: z.boolean().optional(),
    amdi: z.boolean().optional(),
    population2010: z.boolean().optional(),
    population1999: z.boolean().optional(),
    population2012: z.boolean().optional(),
    densite2010: z.boolean().optional(),
    surface: z.boolean().optional(),
    longitudeDeg: z.boolean().optional(),
    latitudeDeg: z.boolean().optional(),
    longitudeGrd: z.boolean().optional(),
    latitudeGrd: z.boolean().optional(),
    longitudeDms: z.boolean().optional(),
    latitudeDms: z.boolean().optional(),
    zmin: z.boolean().optional(),
    zmax: z.boolean().optional()
  })
  .strict();

// NAF SECTION
//------------------------------------------------------

export const NafSectionIncludeSchema: z.ZodType<Prisma.NafSectionInclude> = z
  .object({
    divisions: z
      .union([z.boolean(), z.lazy(() => NafDivisionFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => NafSectionCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const NafSectionArgsSchema: z.ZodType<Prisma.NafSectionDefaultArgs> = z
  .object({
    select: z.lazy(() => NafSectionSelectSchema).optional(),
    include: z.lazy(() => NafSectionIncludeSchema).optional()
  })
  .strict();

export const NafSectionCountOutputTypeArgsSchema: z.ZodType<Prisma.NafSectionCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => NafSectionCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const NafSectionCountOutputTypeSelectSchema: z.ZodType<Prisma.NafSectionCountOutputTypeSelect> =
  z
    .object({
      divisions: z.boolean().optional()
    })
    .strict();

export const NafSectionSelectSchema: z.ZodType<Prisma.NafSectionSelect> = z
  .object({
    id: z.boolean().optional(),
    title: z.boolean().optional(),
    divisions: z
      .union([z.boolean(), z.lazy(() => NafDivisionFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => NafSectionCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// NAF DIVISION
//------------------------------------------------------

export const NafDivisionIncludeSchema: z.ZodType<Prisma.NafDivisionInclude> = z
  .object({
    groups: z
      .union([z.boolean(), z.lazy(() => NafGroupFindManyArgsSchema)])
      .optional(),
    section: z
      .union([z.boolean(), z.lazy(() => NafSectionArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => NafDivisionCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const NafDivisionArgsSchema: z.ZodType<Prisma.NafDivisionDefaultArgs> = z
  .object({
    select: z.lazy(() => NafDivisionSelectSchema).optional(),
    include: z.lazy(() => NafDivisionIncludeSchema).optional()
  })
  .strict();

export const NafDivisionCountOutputTypeArgsSchema: z.ZodType<Prisma.NafDivisionCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => NafDivisionCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const NafDivisionCountOutputTypeSelectSchema: z.ZodType<Prisma.NafDivisionCountOutputTypeSelect> =
  z
    .object({
      groups: z.boolean().optional()
    })
    .strict();

export const NafDivisionSelectSchema: z.ZodType<Prisma.NafDivisionSelect> = z
  .object({
    id: z.boolean().optional(),
    title: z.boolean().optional(),
    sectionId: z.boolean().optional(),
    groups: z
      .union([z.boolean(), z.lazy(() => NafGroupFindManyArgsSchema)])
      .optional(),
    section: z
      .union([z.boolean(), z.lazy(() => NafSectionArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => NafDivisionCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// NAF GROUP
//------------------------------------------------------

export const NafGroupIncludeSchema: z.ZodType<Prisma.NafGroupInclude> = z
  .object({
    classes: z
      .union([z.boolean(), z.lazy(() => NafClassFindManyArgsSchema)])
      .optional(),
    division: z
      .union([z.boolean(), z.lazy(() => NafDivisionArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => NafGroupCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const NafGroupArgsSchema: z.ZodType<Prisma.NafGroupDefaultArgs> = z
  .object({
    select: z.lazy(() => NafGroupSelectSchema).optional(),
    include: z.lazy(() => NafGroupIncludeSchema).optional()
  })
  .strict();

export const NafGroupCountOutputTypeArgsSchema: z.ZodType<Prisma.NafGroupCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => NafGroupCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const NafGroupCountOutputTypeSelectSchema: z.ZodType<Prisma.NafGroupCountOutputTypeSelect> =
  z
    .object({
      classes: z.boolean().optional()
    })
    .strict();

export const NafGroupSelectSchema: z.ZodType<Prisma.NafGroupSelect> = z
  .object({
    id: z.boolean().optional(),
    title: z.boolean().optional(),
    divisionId: z.boolean().optional(),
    classes: z
      .union([z.boolean(), z.lazy(() => NafClassFindManyArgsSchema)])
      .optional(),
    division: z
      .union([z.boolean(), z.lazy(() => NafDivisionArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => NafGroupCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// NAF CLASS
//------------------------------------------------------

export const NafClassIncludeSchema: z.ZodType<Prisma.NafClassInclude> = z
  .object({
    codes: z
      .union([z.boolean(), z.lazy(() => NafCodeFindManyArgsSchema)])
      .optional(),
    group: z.union([z.boolean(), z.lazy(() => NafGroupArgsSchema)]).optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => NafClassCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const NafClassArgsSchema: z.ZodType<Prisma.NafClassDefaultArgs> = z
  .object({
    select: z.lazy(() => NafClassSelectSchema).optional(),
    include: z.lazy(() => NafClassIncludeSchema).optional()
  })
  .strict();

export const NafClassCountOutputTypeArgsSchema: z.ZodType<Prisma.NafClassCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => NafClassCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const NafClassCountOutputTypeSelectSchema: z.ZodType<Prisma.NafClassCountOutputTypeSelect> =
  z
    .object({
      codes: z.boolean().optional()
    })
    .strict();

export const NafClassSelectSchema: z.ZodType<Prisma.NafClassSelect> = z
  .object({
    id: z.boolean().optional(),
    title: z.boolean().optional(),
    groupId: z.boolean().optional(),
    codes: z
      .union([z.boolean(), z.lazy(() => NafCodeFindManyArgsSchema)])
      .optional(),
    group: z.union([z.boolean(), z.lazy(() => NafGroupArgsSchema)]).optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => NafClassCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// NAF CODE
//------------------------------------------------------

export const NafCodeIncludeSchema: z.ZodType<Prisma.NafCodeInclude> = z
  .object({
    class: z.union([z.boolean(), z.lazy(() => NafClassArgsSchema)]).optional(),
    users: z
      .union([z.boolean(), z.lazy(() => UserFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => NafCodeCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const NafCodeArgsSchema: z.ZodType<Prisma.NafCodeDefaultArgs> = z
  .object({
    select: z.lazy(() => NafCodeSelectSchema).optional(),
    include: z.lazy(() => NafCodeIncludeSchema).optional()
  })
  .strict();

export const NafCodeCountOutputTypeArgsSchema: z.ZodType<Prisma.NafCodeCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => NafCodeCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const NafCodeCountOutputTypeSelectSchema: z.ZodType<Prisma.NafCodeCountOutputTypeSelect> =
  z
    .object({
      users: z.boolean().optional()
    })
    .strict();

export const NafCodeSelectSchema: z.ZodType<Prisma.NafCodeSelect> = z
  .object({
    id: z.boolean().optional(),
    title: z.boolean().optional(),
    classId: z.boolean().optional(),
    class: z.union([z.boolean(), z.lazy(() => NafClassArgsSchema)]).optional(),
    users: z
      .union([z.boolean(), z.lazy(() => UserFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => NafCodeCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// OUTBOX
//------------------------------------------------------

export const OutboxIncludeSchema: z.ZodType<Prisma.OutboxInclude> = z
  .object({
    campaign: z
      .union([z.boolean(), z.lazy(() => CampaignArgsSchema)])
      .optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

export const OutboxArgsSchema: z.ZodType<Prisma.OutboxDefaultArgs> = z
  .object({
    select: z.lazy(() => OutboxSelectSchema).optional(),
    include: z.lazy(() => OutboxIncludeSchema).optional()
  })
  .strict();

export const OutboxSelectSchema: z.ZodType<Prisma.OutboxSelect> = z
  .object({
    id: z.boolean().optional(),
    email: z.boolean().optional(),
    subject: z.boolean().optional(),
    body: z.boolean().optional(),
    status: z.boolean().optional(),
    metadata: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    campaignId: z.boolean().optional(),
    campaign: z
      .union([z.boolean(), z.lazy(() => CampaignArgsSchema)])
      .optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

// LIST
//------------------------------------------------------

export const ListIncludeSchema: z.ZodType<Prisma.ListInclude> = z
  .object({
    owners: z
      .union([z.boolean(), z.lazy(() => UserFindManyArgsSchema)])
      .optional(),
    contacts: z
      .union([z.boolean(), z.lazy(() => UserFindManyArgsSchema)])
      .optional(),
    campaigns: z
      .union([z.boolean(), z.lazy(() => CampaignFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => ListCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const ListArgsSchema: z.ZodType<Prisma.ListDefaultArgs> = z
  .object({
    select: z.lazy(() => ListSelectSchema).optional(),
    include: z.lazy(() => ListIncludeSchema).optional()
  })
  .strict();

export const ListCountOutputTypeArgsSchema: z.ZodType<Prisma.ListCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => ListCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const ListCountOutputTypeSelectSchema: z.ZodType<Prisma.ListCountOutputTypeSelect> =
  z
    .object({
      owners: z.boolean().optional(),
      contacts: z.boolean().optional(),
      campaigns: z.boolean().optional()
    })
    .strict();

export const ListSelectSchema: z.ZodType<Prisma.ListSelect> = z
  .object({
    id: z.boolean().optional(),
    title: z.boolean().optional(),
    description: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    owners: z
      .union([z.boolean(), z.lazy(() => UserFindManyArgsSchema)])
      .optional(),
    contacts: z
      .union([z.boolean(), z.lazy(() => UserFindManyArgsSchema)])
      .optional(),
    campaigns: z
      .union([z.boolean(), z.lazy(() => CampaignFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => ListCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// CAMPAIGN
//------------------------------------------------------

export const CampaignIncludeSchema: z.ZodType<Prisma.CampaignInclude> = z
  .object({
    list: z.union([z.boolean(), z.lazy(() => ListArgsSchema)]).optional(),
    email: z.union([z.boolean(), z.lazy(() => EmailArgsSchema)]).optional(),
    outboxes: z
      .union([z.boolean(), z.lazy(() => OutboxFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => CampaignCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const CampaignArgsSchema: z.ZodType<Prisma.CampaignDefaultArgs> = z
  .object({
    select: z.lazy(() => CampaignSelectSchema).optional(),
    include: z.lazy(() => CampaignIncludeSchema).optional()
  })
  .strict();

export const CampaignCountOutputTypeArgsSchema: z.ZodType<Prisma.CampaignCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => CampaignCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const CampaignCountOutputTypeSelectSchema: z.ZodType<Prisma.CampaignCountOutputTypeSelect> =
  z
    .object({
      outboxes: z.boolean().optional()
    })
    .strict();

export const CampaignSelectSchema: z.ZodType<Prisma.CampaignSelect> = z
  .object({
    id: z.boolean().optional(),
    type: z.boolean().optional(),
    smart: z.boolean().optional(),
    title: z.boolean().optional(),
    description: z.boolean().optional(),
    active: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    listId: z.boolean().optional(),
    emailId: z.boolean().optional(),
    list: z.union([z.boolean(), z.lazy(() => ListArgsSchema)]).optional(),
    email: z.union([z.boolean(), z.lazy(() => EmailArgsSchema)]).optional(),
    outboxes: z
      .union([z.boolean(), z.lazy(() => OutboxFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => CampaignCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// EMAIL
//------------------------------------------------------

export const EmailIncludeSchema: z.ZodType<Prisma.EmailInclude> = z
  .object({
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    campaigns: z
      .union([z.boolean(), z.lazy(() => CampaignFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => EmailCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const EmailArgsSchema: z.ZodType<Prisma.EmailDefaultArgs> = z
  .object({
    select: z.lazy(() => EmailSelectSchema).optional(),
    include: z.lazy(() => EmailIncludeSchema).optional()
  })
  .strict();

export const EmailCountOutputTypeArgsSchema: z.ZodType<Prisma.EmailCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => EmailCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const EmailCountOutputTypeSelectSchema: z.ZodType<Prisma.EmailCountOutputTypeSelect> =
  z
    .object({
      campaigns: z.boolean().optional()
    })
    .strict();

export const EmailSelectSchema: z.ZodType<Prisma.EmailSelect> = z
  .object({
    id: z.boolean().optional(),
    title: z.boolean().optional(),
    description: z.boolean().optional(),
    subject: z.boolean().optional(),
    content: z.boolean().optional(),
    design: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    userId: z.boolean().optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    campaigns: z
      .union([z.boolean(), z.lazy(() => CampaignFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => EmailCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// MEDIA
//------------------------------------------------------

export const MediaSelectSchema: z.ZodType<Prisma.MediaSelect> = z
  .object({
    id: z.boolean().optional(),
    entityId: z.boolean().optional(),
    entityType: z.boolean().optional(),
    url: z.boolean().optional(),
    alt: z.boolean().optional(),
    type: z.boolean().optional(),
    position: z.boolean().optional(),
    isMain: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional()
  })
  .strict();

// CLICK
//------------------------------------------------------

export const ClickIncludeSchema: z.ZodType<Prisma.ClickInclude> = z
  .object({
    block: z.union([z.boolean(), z.lazy(() => BlockArgsSchema)]).optional(),
    site: z.union([z.boolean(), z.lazy(() => SiteArgsSchema)]).optional(),
    link: z.union([z.boolean(), z.lazy(() => LinkArgsSchema)]).optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    referer: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

export const ClickArgsSchema: z.ZodType<Prisma.ClickDefaultArgs> = z
  .object({
    select: z.lazy(() => ClickSelectSchema).optional(),
    include: z.lazy(() => ClickIncludeSchema).optional()
  })
  .strict();

export const ClickSelectSchema: z.ZodType<Prisma.ClickSelect> = z
  .object({
    id: z.boolean().optional(),
    part: z.boolean().optional(),
    path: z.boolean().optional(),
    request: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    blockId: z.boolean().optional(),
    siteId: z.boolean().optional(),
    linkId: z.boolean().optional(),
    userId: z.boolean().optional(),
    refererId: z.boolean().optional(),
    block: z.union([z.boolean(), z.lazy(() => BlockArgsSchema)]).optional(),
    site: z.union([z.boolean(), z.lazy(() => SiteArgsSchema)]).optional(),
    link: z.union([z.boolean(), z.lazy(() => LinkArgsSchema)]).optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    referer: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

// LINK
//------------------------------------------------------

export const LinkIncludeSchema: z.ZodType<Prisma.LinkInclude> = z
  .object({
    clicks: z
      .union([z.boolean(), z.lazy(() => ClickFindManyArgsSchema)])
      .optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => LinkCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const LinkArgsSchema: z.ZodType<Prisma.LinkDefaultArgs> = z
  .object({
    select: z.lazy(() => LinkSelectSchema).optional(),
    include: z.lazy(() => LinkIncludeSchema).optional()
  })
  .strict();

export const LinkCountOutputTypeArgsSchema: z.ZodType<Prisma.LinkCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => LinkCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const LinkCountOutputTypeSelectSchema: z.ZodType<Prisma.LinkCountOutputTypeSelect> =
  z
    .object({
      clicks: z.boolean().optional()
    })
    .strict();

export const LinkSelectSchema: z.ZodType<Prisma.LinkSelect> = z
  .object({
    id: z.boolean().optional(),
    url: z.boolean().optional(),
    name: z.boolean().optional(),
    description: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    userId: z.boolean().optional(),
    clicks: z
      .union([z.boolean(), z.lazy(() => ClickFindManyArgsSchema)])
      .optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => LinkCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// BLOCK
//------------------------------------------------------

export const BlockIncludeSchema: z.ZodType<Prisma.BlockInclude> = z
  .object({
    clicks: z
      .union([z.boolean(), z.lazy(() => ClickFindManyArgsSchema)])
      .optional(),
    reservations: z
      .union([z.boolean(), z.lazy(() => ReservationFindManyArgsSchema)])
      .optional(),
    site: z.union([z.boolean(), z.lazy(() => SiteArgsSchema)]).optional(),
    categories: z
      .union([z.boolean(), z.lazy(() => CategoryFindManyArgsSchema)])
      .optional(),
    inventories: z
      .union([z.boolean(), z.lazy(() => InventoryFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => BlockCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const BlockArgsSchema: z.ZodType<Prisma.BlockDefaultArgs> = z
  .object({
    select: z.lazy(() => BlockSelectSchema).optional(),
    include: z.lazy(() => BlockIncludeSchema).optional()
  })
  .strict();

export const BlockCountOutputTypeArgsSchema: z.ZodType<Prisma.BlockCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => BlockCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const BlockCountOutputTypeSelectSchema: z.ZodType<Prisma.BlockCountOutputTypeSelect> =
  z
    .object({
      clicks: z.boolean().optional(),
      reservations: z.boolean().optional(),
      categories: z.boolean().optional(),
      inventories: z.boolean().optional()
    })
    .strict();

export const BlockSelectSchema: z.ZodType<Prisma.BlockSelect> = z
  .object({
    id: z.boolean().optional(),
    type: z.boolean().optional(),
    position: z.boolean().optional(),
    label: z.boolean().optional(),
    href: z.boolean().optional(),
    logo: z.boolean().optional(),
    style: z.boolean().optional(),
    widget: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    siteId: z.boolean().optional(),
    clicks: z
      .union([z.boolean(), z.lazy(() => ClickFindManyArgsSchema)])
      .optional(),
    reservations: z
      .union([z.boolean(), z.lazy(() => ReservationFindManyArgsSchema)])
      .optional(),
    site: z.union([z.boolean(), z.lazy(() => SiteArgsSchema)]).optional(),
    categories: z
      .union([z.boolean(), z.lazy(() => CategoryFindManyArgsSchema)])
      .optional(),
    inventories: z
      .union([z.boolean(), z.lazy(() => InventoryFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => BlockCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// LIKE
//------------------------------------------------------

export const LikeIncludeSchema: z.ZodType<Prisma.LikeInclude> = z
  .object({
    site: z.union([z.boolean(), z.lazy(() => SiteArgsSchema)]).optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    feed: z.union([z.boolean(), z.lazy(() => FeedArgsSchema)]).optional()
  })
  .strict();

export const LikeArgsSchema: z.ZodType<Prisma.LikeDefaultArgs> = z
  .object({
    select: z.lazy(() => LikeSelectSchema).optional(),
    include: z.lazy(() => LikeIncludeSchema).optional()
  })
  .strict();

export const LikeSelectSchema: z.ZodType<Prisma.LikeSelect> = z
  .object({
    id: z.boolean().optional(),
    ip: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    siteId: z.boolean().optional(),
    userId: z.boolean().optional(),
    feedId: z.boolean().optional(),
    site: z.union([z.boolean(), z.lazy(() => SiteArgsSchema)]).optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    feed: z.union([z.boolean(), z.lazy(() => FeedArgsSchema)]).optional()
  })
  .strict();

// SITE
//------------------------------------------------------

export const SiteIncludeSchema: z.ZodType<Prisma.SiteInclude> = z
  .object({
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    blocks: z
      .union([z.boolean(), z.lazy(() => BlockFindManyArgsSchema)])
      .optional(),
    clicks: z
      .union([z.boolean(), z.lazy(() => ClickFindManyArgsSchema)])
      .optional(),
    subscribers: z
      .union([z.boolean(), z.lazy(() => SubscriberFindManyArgsSchema)])
      .optional(),
    likes: z
      .union([z.boolean(), z.lazy(() => LikeFindManyArgsSchema)])
      .optional(),
    feed: z
      .union([z.boolean(), z.lazy(() => FeedFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => SiteCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const SiteArgsSchema: z.ZodType<Prisma.SiteDefaultArgs> = z
  .object({
    select: z.lazy(() => SiteSelectSchema).optional(),
    include: z.lazy(() => SiteIncludeSchema).optional()
  })
  .strict();

export const SiteCountOutputTypeArgsSchema: z.ZodType<Prisma.SiteCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => SiteCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const SiteCountOutputTypeSelectSchema: z.ZodType<Prisma.SiteCountOutputTypeSelect> =
  z
    .object({
      blocks: z.boolean().optional(),
      clicks: z.boolean().optional(),
      subscribers: z.boolean().optional(),
      likes: z.boolean().optional(),
      feed: z.boolean().optional()
    })
    .strict();

export const SiteSelectSchema: z.ZodType<Prisma.SiteSelect> = z
  .object({
    id: z.boolean().optional(),
    name: z.boolean().optional(),
    display_name: z.boolean().optional(),
    description: z.boolean().optional(),
    logo: z.boolean().optional(),
    font: z.boolean().optional(),
    image: z.boolean().optional(),
    imageBlurhash: z.boolean().optional(),
    subdomain: z.boolean().optional(),
    customDomain: z.boolean().optional(),
    message404: z.boolean().optional(),
    background: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    userId: z.boolean().optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    blocks: z
      .union([z.boolean(), z.lazy(() => BlockFindManyArgsSchema)])
      .optional(),
    clicks: z
      .union([z.boolean(), z.lazy(() => ClickFindManyArgsSchema)])
      .optional(),
    subscribers: z
      .union([z.boolean(), z.lazy(() => SubscriberFindManyArgsSchema)])
      .optional(),
    likes: z
      .union([z.boolean(), z.lazy(() => LikeFindManyArgsSchema)])
      .optional(),
    feed: z
      .union([z.boolean(), z.lazy(() => FeedFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => SiteCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// SUBSCRIBER
//------------------------------------------------------

export const SubscriberIncludeSchema: z.ZodType<Prisma.SubscriberInclude> = z
  .object({
    site: z.union([z.boolean(), z.lazy(() => SiteArgsSchema)]).optional()
  })
  .strict();

export const SubscriberArgsSchema: z.ZodType<Prisma.SubscriberDefaultArgs> = z
  .object({
    select: z.lazy(() => SubscriberSelectSchema).optional(),
    include: z.lazy(() => SubscriberIncludeSchema).optional()
  })
  .strict();

export const SubscriberSelectSchema: z.ZodType<Prisma.SubscriberSelect> = z
  .object({
    id: z.boolean().optional(),
    email: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    siteId: z.boolean().optional(),
    site: z.union([z.boolean(), z.lazy(() => SiteArgsSchema)]).optional()
  })
  .strict();

// RESERVATION
//------------------------------------------------------

export const ReservationIncludeSchema: z.ZodType<Prisma.ReservationInclude> = z
  .object({
    block: z.union([z.boolean(), z.lazy(() => BlockArgsSchema)]).optional(),
    affiliate: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

export const ReservationArgsSchema: z.ZodType<Prisma.ReservationDefaultArgs> = z
  .object({
    select: z.lazy(() => ReservationSelectSchema).optional(),
    include: z.lazy(() => ReservationIncludeSchema).optional()
  })
  .strict();

export const ReservationSelectSchema: z.ZodType<Prisma.ReservationSelect> = z
  .object({
    id: z.boolean().optional(),
    type: z.boolean().optional(),
    name: z.boolean().optional(),
    email: z.boolean().optional(),
    dateStart: z.boolean().optional(),
    dateEnd: z.boolean().optional(),
    comment: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    blockId: z.boolean().optional(),
    affiliateId: z.boolean().optional(),
    block: z.union([z.boolean(), z.lazy(() => BlockArgsSchema)]).optional(),
    affiliate: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

// CATEGORY
//------------------------------------------------------

export const CategoryIncludeSchema: z.ZodType<Prisma.CategoryInclude> = z
  .object({
    inventories: z
      .union([z.boolean(), z.lazy(() => InventoryFindManyArgsSchema)])
      .optional(),
    categories: z
      .union([z.boolean(), z.lazy(() => CategoryFindManyArgsSchema)])
      .optional(),
    category: z
      .union([z.boolean(), z.lazy(() => CategoryArgsSchema)])
      .optional(),
    block: z.union([z.boolean(), z.lazy(() => BlockArgsSchema)]).optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => CategoryCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const CategoryArgsSchema: z.ZodType<Prisma.CategoryDefaultArgs> = z
  .object({
    select: z.lazy(() => CategorySelectSchema).optional(),
    include: z.lazy(() => CategoryIncludeSchema).optional()
  })
  .strict();

export const CategoryCountOutputTypeArgsSchema: z.ZodType<Prisma.CategoryCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => CategoryCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const CategoryCountOutputTypeSelectSchema: z.ZodType<Prisma.CategoryCountOutputTypeSelect> =
  z
    .object({
      inventories: z.boolean().optional(),
      categories: z.boolean().optional()
    })
    .strict();

export const CategorySelectSchema: z.ZodType<Prisma.CategorySelect> = z
  .object({
    id: z.boolean().optional(),
    name: z.boolean().optional(),
    description: z.boolean().optional(),
    slug: z.boolean().optional(),
    active: z.boolean().optional(),
    position: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    categoryId: z.boolean().optional(),
    blockId: z.boolean().optional(),
    inventories: z
      .union([z.boolean(), z.lazy(() => InventoryFindManyArgsSchema)])
      .optional(),
    categories: z
      .union([z.boolean(), z.lazy(() => CategoryFindManyArgsSchema)])
      .optional(),
    category: z
      .union([z.boolean(), z.lazy(() => CategoryArgsSchema)])
      .optional(),
    block: z.union([z.boolean(), z.lazy(() => BlockArgsSchema)]).optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => CategoryCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// INVENTORY
//------------------------------------------------------

export const InventoryIncludeSchema: z.ZodType<Prisma.InventoryInclude> = z
  .object({
    category: z
      .union([z.boolean(), z.lazy(() => CategoryArgsSchema)])
      .optional(),
    variants: z
      .union([z.boolean(), z.lazy(() => InventoryVariantFindManyArgsSchema)])
      .optional(),
    block: z.union([z.boolean(), z.lazy(() => BlockArgsSchema)]).optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => InventoryCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const InventoryArgsSchema: z.ZodType<Prisma.InventoryDefaultArgs> = z
  .object({
    select: z.lazy(() => InventorySelectSchema).optional(),
    include: z.lazy(() => InventoryIncludeSchema).optional()
  })
  .strict();

export const InventoryCountOutputTypeArgsSchema: z.ZodType<Prisma.InventoryCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => InventoryCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const InventoryCountOutputTypeSelectSchema: z.ZodType<Prisma.InventoryCountOutputTypeSelect> =
  z
    .object({
      variants: z.boolean().optional()
    })
    .strict();

export const InventorySelectSchema: z.ZodType<Prisma.InventorySelect> = z
  .object({
    id: z.boolean().optional(),
    name: z.boolean().optional(),
    description: z.boolean().optional(),
    slug: z.boolean().optional(),
    sku: z.boolean().optional(),
    basePrice: z.boolean().optional(),
    active: z.boolean().optional(),
    isFeatured: z.boolean().optional(),
    metaTitle: z.boolean().optional(),
    metaDescription: z.boolean().optional(),
    tags: z.boolean().optional(),
    stock: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    categoryId: z.boolean().optional(),
    blockId: z.boolean().optional(),
    category: z
      .union([z.boolean(), z.lazy(() => CategoryArgsSchema)])
      .optional(),
    variants: z
      .union([z.boolean(), z.lazy(() => InventoryVariantFindManyArgsSchema)])
      .optional(),
    block: z.union([z.boolean(), z.lazy(() => BlockArgsSchema)]).optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => InventoryCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// INVENTORY VARIANT
//------------------------------------------------------

export const InventoryVariantIncludeSchema: z.ZodType<Prisma.InventoryVariantInclude> =
  z
    .object({
      inventory: z
        .union([z.boolean(), z.lazy(() => InventoryArgsSchema)])
        .optional()
    })
    .strict();

export const InventoryVariantArgsSchema: z.ZodType<Prisma.InventoryVariantDefaultArgs> =
  z
    .object({
      select: z.lazy(() => InventoryVariantSelectSchema).optional(),
      include: z.lazy(() => InventoryVariantIncludeSchema).optional()
    })
    .strict();

export const InventoryVariantSelectSchema: z.ZodType<Prisma.InventoryVariantSelect> =
  z
    .object({
      id: z.boolean().optional(),
      inventoryId: z.boolean().optional(),
      name: z.boolean().optional(),
      value: z.boolean().optional(),
      type: z.boolean().optional(),
      price: z.boolean().optional(),
      stock: z.boolean().optional(),
      active: z.boolean().optional(),
      position: z.boolean().optional(),
      createdAt: z.boolean().optional(),
      updatedAt: z.boolean().optional(),
      inventory: z
        .union([z.boolean(), z.lazy(() => InventoryArgsSchema)])
        .optional()
    })
    .strict();

// CRON
//------------------------------------------------------

export const CronIncludeSchema: z.ZodType<Prisma.CronInclude> = z
  .object({
    history: z
      .union([z.boolean(), z.lazy(() => HistoryFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => CronCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const CronArgsSchema: z.ZodType<Prisma.CronDefaultArgs> = z
  .object({
    select: z.lazy(() => CronSelectSchema).optional(),
    include: z.lazy(() => CronIncludeSchema).optional()
  })
  .strict();

export const CronCountOutputTypeArgsSchema: z.ZodType<Prisma.CronCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => CronCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const CronCountOutputTypeSelectSchema: z.ZodType<Prisma.CronCountOutputTypeSelect> =
  z
    .object({
      history: z.boolean().optional()
    })
    .strict();

export const CronSelectSchema: z.ZodType<Prisma.CronSelect> = z
  .object({
    id: z.boolean().optional(),
    name: z.boolean().optional(),
    cronExpr: z.boolean().optional(),
    timezone: z.boolean().optional(),
    modulePath: z.boolean().optional(),
    functionName: z.boolean().optional(),
    enabled: z.boolean().optional(),
    lastRunAt: z.boolean().optional(),
    lastStatus: z.boolean().optional(),
    lastDurationMs: z.boolean().optional(),
    lockedAt: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    history: z
      .union([z.boolean(), z.lazy(() => HistoryFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => CronCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// HISTORY
//------------------------------------------------------

export const HistoryIncludeSchema: z.ZodType<Prisma.HistoryInclude> = z
  .object({
    cron: z.union([z.boolean(), z.lazy(() => CronArgsSchema)]).optional()
  })
  .strict();

export const HistoryArgsSchema: z.ZodType<Prisma.HistoryDefaultArgs> = z
  .object({
    select: z.lazy(() => HistorySelectSchema).optional(),
    include: z.lazy(() => HistoryIncludeSchema).optional()
  })
  .strict();

export const HistorySelectSchema: z.ZodType<Prisma.HistorySelect> = z
  .object({
    id: z.boolean().optional(),
    status: z.boolean().optional(),
    startedAt: z.boolean().optional(),
    endedAt: z.boolean().optional(),
    durationMs: z.boolean().optional(),
    message: z.boolean().optional(),
    cronId: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    cron: z.union([z.boolean(), z.lazy(() => CronArgsSchema)]).optional()
  })
  .strict();

// USER
//------------------------------------------------------

export const UserIncludeSchema: z.ZodType<Prisma.UserInclude> = z
  .object({
    accounts: z
      .union([z.boolean(), z.lazy(() => AccountFindManyArgsSchema)])
      .optional(),
    sessions: z
      .union([z.boolean(), z.lazy(() => SessionFindManyArgsSchema)])
      .optional(),
    sites: z
      .union([z.boolean(), z.lazy(() => SiteFindManyArgsSchema)])
      .optional(),
    subscriptions: z
      .union([z.boolean(), z.lazy(() => SubscriptionFindManyArgsSchema)])
      .optional(),
    authenticator: z
      .union([z.boolean(), z.lazy(() => AuthenticatorFindManyArgsSchema)])
      .optional(),
    links: z
      .union([z.boolean(), z.lazy(() => LinkFindManyArgsSchema)])
      .optional(),
    customer: z
      .union([z.boolean(), z.lazy(() => CustomerArgsSchema)])
      .optional(),
    twoFactorConfirmation: z
      .union([z.boolean(), z.lazy(() => TwoFactorConfirmationArgsSchema)])
      .optional(),
    referer: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    naf: z.union([z.boolean(), z.lazy(() => NafCodeArgsSchema)]).optional(),
    feedback: z
      .union([z.boolean(), z.lazy(() => FeedbackFindManyArgsSchema)])
      .optional(),
    likes: z
      .union([z.boolean(), z.lazy(() => LikeFindManyArgsSchema)])
      .optional(),
    affiliates: z
      .union([z.boolean(), z.lazy(() => UserFindManyArgsSchema)])
      .optional(),
    events: z
      .union([z.boolean(), z.lazy(() => EventFindManyArgsSchema)])
      .optional(),
    workflowStates: z
      .union([z.boolean(), z.lazy(() => WorkflowStateFindManyArgsSchema)])
      .optional(),
    executions: z
      .union([z.boolean(), z.lazy(() => ExecutionFindManyArgsSchema)])
      .optional(),
    jobs: z
      .union([z.boolean(), z.lazy(() => QueueFindManyArgsSchema)])
      .optional(),
    outbox: z
      .union([z.boolean(), z.lazy(() => OutboxFindManyArgsSchema)])
      .optional(),
    feed: z
      .union([z.boolean(), z.lazy(() => FeedFindManyArgsSchema)])
      .optional(),
    comments: z
      .union([z.boolean(), z.lazy(() => CommentFindManyArgsSchema)])
      .optional(),
    sent: z
      .union([z.boolean(), z.lazy(() => MessageFindManyArgsSchema)])
      .optional(),
    received: z
      .union([z.boolean(), z.lazy(() => MessageFindManyArgsSchema)])
      .optional(),
    reservations: z
      .union([z.boolean(), z.lazy(() => ReservationFindManyArgsSchema)])
      .optional(),
    lists: z
      .union([z.boolean(), z.lazy(() => ListFindManyArgsSchema)])
      .optional(),
    listsManage: z
      .union([z.boolean(), z.lazy(() => ListFindManyArgsSchema)])
      .optional(),
    emails: z
      .union([z.boolean(), z.lazy(() => EmailFindManyArgsSchema)])
      .optional(),
    clicks: z
      .union([z.boolean(), z.lazy(() => ClickFindManyArgsSchema)])
      .optional(),
    referrals: z
      .union([z.boolean(), z.lazy(() => ClickFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => UserCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const UserArgsSchema: z.ZodType<Prisma.UserDefaultArgs> = z
  .object({
    select: z.lazy(() => UserSelectSchema).optional(),
    include: z.lazy(() => UserIncludeSchema).optional()
  })
  .strict();

export const UserCountOutputTypeArgsSchema: z.ZodType<Prisma.UserCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => UserCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const UserCountOutputTypeSelectSchema: z.ZodType<Prisma.UserCountOutputTypeSelect> =
  z
    .object({
      accounts: z.boolean().optional(),
      sessions: z.boolean().optional(),
      sites: z.boolean().optional(),
      subscriptions: z.boolean().optional(),
      authenticator: z.boolean().optional(),
      links: z.boolean().optional(),
      feedback: z.boolean().optional(),
      likes: z.boolean().optional(),
      affiliates: z.boolean().optional(),
      events: z.boolean().optional(),
      workflowStates: z.boolean().optional(),
      executions: z.boolean().optional(),
      jobs: z.boolean().optional(),
      outbox: z.boolean().optional(),
      feed: z.boolean().optional(),
      comments: z.boolean().optional(),
      sent: z.boolean().optional(),
      received: z.boolean().optional(),
      reservations: z.boolean().optional(),
      lists: z.boolean().optional(),
      listsManage: z.boolean().optional(),
      emails: z.boolean().optional(),
      clicks: z.boolean().optional(),
      referrals: z.boolean().optional()
    })
    .strict();

export const UserSelectSchema: z.ZodType<Prisma.UserSelect> = z
  .object({
    id: z.boolean().optional(),
    name: z.boolean().optional(),
    email: z.boolean().optional(),
    emailVerified: z.boolean().optional(),
    image: z.boolean().optional(),
    isTwoFactorEnabled: z.boolean().optional(),
    billing_address: z.boolean().optional(),
    payment_method: z.boolean().optional(),
    company: z.boolean().optional(),
    address: z.boolean().optional(),
    location: z.boolean().optional(),
    postcode: z.boolean().optional(),
    city: z.boolean().optional(),
    phone: z.boolean().optional(),
    activity: z.boolean().optional(),
    bounced: z.boolean().optional(),
    affiliateRate: z.boolean().optional(),
    isAnonymous: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    role: z.boolean().optional(),
    refererId: z.boolean().optional(),
    codeNaf: z.boolean().optional(),
    accounts: z
      .union([z.boolean(), z.lazy(() => AccountFindManyArgsSchema)])
      .optional(),
    sessions: z
      .union([z.boolean(), z.lazy(() => SessionFindManyArgsSchema)])
      .optional(),
    sites: z
      .union([z.boolean(), z.lazy(() => SiteFindManyArgsSchema)])
      .optional(),
    subscriptions: z
      .union([z.boolean(), z.lazy(() => SubscriptionFindManyArgsSchema)])
      .optional(),
    authenticator: z
      .union([z.boolean(), z.lazy(() => AuthenticatorFindManyArgsSchema)])
      .optional(),
    links: z
      .union([z.boolean(), z.lazy(() => LinkFindManyArgsSchema)])
      .optional(),
    customer: z
      .union([z.boolean(), z.lazy(() => CustomerArgsSchema)])
      .optional(),
    twoFactorConfirmation: z
      .union([z.boolean(), z.lazy(() => TwoFactorConfirmationArgsSchema)])
      .optional(),
    referer: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    naf: z.union([z.boolean(), z.lazy(() => NafCodeArgsSchema)]).optional(),
    feedback: z
      .union([z.boolean(), z.lazy(() => FeedbackFindManyArgsSchema)])
      .optional(),
    likes: z
      .union([z.boolean(), z.lazy(() => LikeFindManyArgsSchema)])
      .optional(),
    affiliates: z
      .union([z.boolean(), z.lazy(() => UserFindManyArgsSchema)])
      .optional(),
    events: z
      .union([z.boolean(), z.lazy(() => EventFindManyArgsSchema)])
      .optional(),
    workflowStates: z
      .union([z.boolean(), z.lazy(() => WorkflowStateFindManyArgsSchema)])
      .optional(),
    executions: z
      .union([z.boolean(), z.lazy(() => ExecutionFindManyArgsSchema)])
      .optional(),
    jobs: z
      .union([z.boolean(), z.lazy(() => QueueFindManyArgsSchema)])
      .optional(),
    outbox: z
      .union([z.boolean(), z.lazy(() => OutboxFindManyArgsSchema)])
      .optional(),
    feed: z
      .union([z.boolean(), z.lazy(() => FeedFindManyArgsSchema)])
      .optional(),
    comments: z
      .union([z.boolean(), z.lazy(() => CommentFindManyArgsSchema)])
      .optional(),
    sent: z
      .union([z.boolean(), z.lazy(() => MessageFindManyArgsSchema)])
      .optional(),
    received: z
      .union([z.boolean(), z.lazy(() => MessageFindManyArgsSchema)])
      .optional(),
    reservations: z
      .union([z.boolean(), z.lazy(() => ReservationFindManyArgsSchema)])
      .optional(),
    lists: z
      .union([z.boolean(), z.lazy(() => ListFindManyArgsSchema)])
      .optional(),
    listsManage: z
      .union([z.boolean(), z.lazy(() => ListFindManyArgsSchema)])
      .optional(),
    emails: z
      .union([z.boolean(), z.lazy(() => EmailFindManyArgsSchema)])
      .optional(),
    clicks: z
      .union([z.boolean(), z.lazy(() => ClickFindManyArgsSchema)])
      .optional(),
    referrals: z
      .union([z.boolean(), z.lazy(() => ClickFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => UserCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// MESSAGE
//------------------------------------------------------

export const MessageIncludeSchema: z.ZodType<Prisma.MessageInclude> = z
  .object({
    sender: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    receiver: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

export const MessageArgsSchema: z.ZodType<Prisma.MessageDefaultArgs> = z
  .object({
    select: z.lazy(() => MessageSelectSchema).optional(),
    include: z.lazy(() => MessageIncludeSchema).optional()
  })
  .strict();

export const MessageSelectSchema: z.ZodType<Prisma.MessageSelect> = z
  .object({
    id: z.boolean().optional(),
    content: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    senderEmail: z.boolean().optional(),
    receiveEmail: z.boolean().optional(),
    sender: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    receiver: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

// FEEDBACK
//------------------------------------------------------

export const FeedbackIncludeSchema: z.ZodType<Prisma.FeedbackInclude> = z
  .object({
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

export const FeedbackArgsSchema: z.ZodType<Prisma.FeedbackDefaultArgs> = z
  .object({
    select: z.lazy(() => FeedbackSelectSchema).optional(),
    include: z.lazy(() => FeedbackIncludeSchema).optional()
  })
  .strict();

export const FeedbackSelectSchema: z.ZodType<Prisma.FeedbackSelect> = z
  .object({
    id: z.boolean().optional(),
    message: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    userId: z.boolean().optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

// QUEUE
//------------------------------------------------------

export const QueueIncludeSchema: z.ZodType<Prisma.QueueInclude> = z
  .object({
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

export const QueueArgsSchema: z.ZodType<Prisma.QueueDefaultArgs> = z
  .object({
    select: z.lazy(() => QueueSelectSchema).optional(),
    include: z.lazy(() => QueueIncludeSchema).optional()
  })
  .strict();

export const QueueSelectSchema: z.ZodType<Prisma.QueueSelect> = z
  .object({
    id: z.boolean().optional(),
    job: z.boolean().optional(),
    payload: z.boolean().optional(),
    status: z.boolean().optional(),
    attempts: z.boolean().optional(),
    lastError: z.boolean().optional(),
    runAt: z.boolean().optional(),
    priority: z.boolean().optional(),
    processingStartedAt: z.boolean().optional(),
    correlationId: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    userId: z.boolean().optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

// ACTION
//------------------------------------------------------

export const ActionIncludeSchema: z.ZodType<Prisma.ActionInclude> = z
  .object({
    rules: z
      .union([z.boolean(), z.lazy(() => RuleFindManyArgsSchema)])
      .optional(),
    executions: z
      .union([z.boolean(), z.lazy(() => ExecutionFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => ActionCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const ActionArgsSchema: z.ZodType<Prisma.ActionDefaultArgs> = z
  .object({
    select: z.lazy(() => ActionSelectSchema).optional(),
    include: z.lazy(() => ActionIncludeSchema).optional()
  })
  .strict();

export const ActionCountOutputTypeArgsSchema: z.ZodType<Prisma.ActionCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => ActionCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const ActionCountOutputTypeSelectSchema: z.ZodType<Prisma.ActionCountOutputTypeSelect> =
  z
    .object({
      rules: z.boolean().optional(),
      executions: z.boolean().optional()
    })
    .strict();

export const ActionSelectSchema: z.ZodType<Prisma.ActionSelect> = z
  .object({
    id: z.boolean().optional(),
    code: z.boolean().optional(),
    description: z.boolean().optional(),
    type: z.boolean().optional(),
    config: z.boolean().optional(),
    isPublished: z.boolean().optional(),
    version: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    rules: z
      .union([z.boolean(), z.lazy(() => RuleFindManyArgsSchema)])
      .optional(),
    executions: z
      .union([z.boolean(), z.lazy(() => ExecutionFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => ActionCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// WORKFLOW
//------------------------------------------------------

export const WorkflowIncludeSchema: z.ZodType<Prisma.WorkflowInclude> = z
  .object({
    rules: z
      .union([z.boolean(), z.lazy(() => RuleFindManyArgsSchema)])
      .optional(),
    states: z
      .union([z.boolean(), z.lazy(() => WorkflowStateFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => WorkflowCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const WorkflowArgsSchema: z.ZodType<Prisma.WorkflowDefaultArgs> = z
  .object({
    select: z.lazy(() => WorkflowSelectSchema).optional(),
    include: z.lazy(() => WorkflowIncludeSchema).optional()
  })
  .strict();

export const WorkflowCountOutputTypeArgsSchema: z.ZodType<Prisma.WorkflowCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => WorkflowCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const WorkflowCountOutputTypeSelectSchema: z.ZodType<Prisma.WorkflowCountOutputTypeSelect> =
  z
    .object({
      rules: z.boolean().optional(),
      states: z.boolean().optional()
    })
    .strict();

export const WorkflowSelectSchema: z.ZodType<Prisma.WorkflowSelect> = z
  .object({
    id: z.boolean().optional(),
    name: z.boolean().optional(),
    description: z.boolean().optional(),
    isDefault: z.boolean().optional(),
    isActive: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    rules: z
      .union([z.boolean(), z.lazy(() => RuleFindManyArgsSchema)])
      .optional(),
    states: z
      .union([z.boolean(), z.lazy(() => WorkflowStateFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => WorkflowCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// TRIGGER
//------------------------------------------------------

export const TriggerIncludeSchema: z.ZodType<Prisma.TriggerInclude> = z
  .object({
    rules: z
      .union([z.boolean(), z.lazy(() => RuleFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => TriggerCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const TriggerArgsSchema: z.ZodType<Prisma.TriggerDefaultArgs> = z
  .object({
    select: z.lazy(() => TriggerSelectSchema).optional(),
    include: z.lazy(() => TriggerIncludeSchema).optional()
  })
  .strict();

export const TriggerCountOutputTypeArgsSchema: z.ZodType<Prisma.TriggerCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => TriggerCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const TriggerCountOutputTypeSelectSchema: z.ZodType<Prisma.TriggerCountOutputTypeSelect> =
  z
    .object({
      rules: z.boolean().optional()
    })
    .strict();

export const TriggerSelectSchema: z.ZodType<Prisma.TriggerSelect> = z
  .object({
    id: z.boolean().optional(),
    code: z.boolean().optional(),
    description: z.boolean().optional(),
    rules: z
      .union([z.boolean(), z.lazy(() => RuleFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => TriggerCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// RULE
//------------------------------------------------------

export const RuleIncludeSchema: z.ZodType<Prisma.RuleInclude> = z
  .object({
    ruleConditions: z
      .union([z.boolean(), z.lazy(() => RuleConditionFindManyArgsSchema)])
      .optional(),
    workflow: z
      .union([z.boolean(), z.lazy(() => WorkflowArgsSchema)])
      .optional(),
    action: z.union([z.boolean(), z.lazy(() => ActionArgsSchema)]).optional(),
    trigger: z.union([z.boolean(), z.lazy(() => TriggerArgsSchema)]).optional(),
    executions: z
      .union([z.boolean(), z.lazy(() => ExecutionFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => RuleCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const RuleArgsSchema: z.ZodType<Prisma.RuleDefaultArgs> = z
  .object({
    select: z.lazy(() => RuleSelectSchema).optional(),
    include: z.lazy(() => RuleIncludeSchema).optional()
  })
  .strict();

export const RuleCountOutputTypeArgsSchema: z.ZodType<Prisma.RuleCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => RuleCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const RuleCountOutputTypeSelectSchema: z.ZodType<Prisma.RuleCountOutputTypeSelect> =
  z
    .object({
      ruleConditions: z.boolean().optional(),
      executions: z.boolean().optional()
    })
    .strict();

export const RuleSelectSchema: z.ZodType<Prisma.RuleSelect> = z
  .object({
    id: z.boolean().optional(),
    workflowId: z.boolean().optional(),
    actionId: z.boolean().optional(),
    triggerId: z.boolean().optional(),
    delayMinutes: z.boolean().optional(),
    order: z.boolean().optional(),
    isActive: z.boolean().optional(),
    version: z.boolean().optional(),
    ruleConditions: z
      .union([z.boolean(), z.lazy(() => RuleConditionFindManyArgsSchema)])
      .optional(),
    workflow: z
      .union([z.boolean(), z.lazy(() => WorkflowArgsSchema)])
      .optional(),
    action: z.union([z.boolean(), z.lazy(() => ActionArgsSchema)]).optional(),
    trigger: z.union([z.boolean(), z.lazy(() => TriggerArgsSchema)]).optional(),
    executions: z
      .union([z.boolean(), z.lazy(() => ExecutionFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => RuleCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// CONDITION
//------------------------------------------------------

export const ConditionIncludeSchema: z.ZodType<Prisma.ConditionInclude> = z
  .object({
    rules: z
      .union([z.boolean(), z.lazy(() => RuleConditionFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => ConditionCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

export const ConditionArgsSchema: z.ZodType<Prisma.ConditionDefaultArgs> = z
  .object({
    select: z.lazy(() => ConditionSelectSchema).optional(),
    include: z.lazy(() => ConditionIncludeSchema).optional()
  })
  .strict();

export const ConditionCountOutputTypeArgsSchema: z.ZodType<Prisma.ConditionCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => ConditionCountOutputTypeSelectSchema).nullish()
    })
    .strict();

export const ConditionCountOutputTypeSelectSchema: z.ZodType<Prisma.ConditionCountOutputTypeSelect> =
  z
    .object({
      rules: z.boolean().optional()
    })
    .strict();

export const ConditionSelectSchema: z.ZodType<Prisma.ConditionSelect> = z
  .object({
    id: z.boolean().optional(),
    name: z.boolean().optional(),
    description: z.boolean().optional(),
    type: z.boolean().optional(),
    parameters: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    rules: z
      .union([z.boolean(), z.lazy(() => RuleConditionFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => ConditionCountOutputTypeArgsSchema)])
      .optional()
  })
  .strict();

// RULE CONDITION
//------------------------------------------------------

export const RuleConditionIncludeSchema: z.ZodType<Prisma.RuleConditionInclude> =
  z
    .object({
      rule: z.union([z.boolean(), z.lazy(() => RuleArgsSchema)]).optional(),
      condition: z
        .union([z.boolean(), z.lazy(() => ConditionArgsSchema)])
        .optional()
    })
    .strict();

export const RuleConditionArgsSchema: z.ZodType<Prisma.RuleConditionDefaultArgs> =
  z
    .object({
      select: z.lazy(() => RuleConditionSelectSchema).optional(),
      include: z.lazy(() => RuleConditionIncludeSchema).optional()
    })
    .strict();

export const RuleConditionSelectSchema: z.ZodType<Prisma.RuleConditionSelect> =
  z
    .object({
      ruleId: z.boolean().optional(),
      conditionId: z.boolean().optional(),
      group: z.boolean().optional(),
      logic: z.boolean().optional(),
      rule: z.union([z.boolean(), z.lazy(() => RuleArgsSchema)]).optional(),
      condition: z
        .union([z.boolean(), z.lazy(() => ConditionArgsSchema)])
        .optional()
    })
    .strict();

// EVENT
//------------------------------------------------------

export const EventIncludeSchema: z.ZodType<Prisma.EventInclude> = z
  .object({
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

export const EventArgsSchema: z.ZodType<Prisma.EventDefaultArgs> = z
  .object({
    select: z.lazy(() => EventSelectSchema).optional(),
    include: z.lazy(() => EventIncludeSchema).optional()
  })
  .strict();

export const EventSelectSchema: z.ZodType<Prisma.EventSelect> = z
  .object({
    id: z.boolean().optional(),
    userId: z.boolean().optional(),
    eventType: z.boolean().optional(),
    payload: z.boolean().optional(),
    correlationId: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    status: z.boolean().optional(),
    attempts: z.boolean().optional(),
    lastError: z.boolean().optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional()
  })
  .strict();

// WORKFLOW STATE
//------------------------------------------------------

export const WorkflowStateIncludeSchema: z.ZodType<Prisma.WorkflowStateInclude> =
  z
    .object({
      user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
      workflow: z
        .union([z.boolean(), z.lazy(() => WorkflowArgsSchema)])
        .optional()
    })
    .strict();

export const WorkflowStateArgsSchema: z.ZodType<Prisma.WorkflowStateDefaultArgs> =
  z
    .object({
      select: z.lazy(() => WorkflowStateSelectSchema).optional(),
      include: z.lazy(() => WorkflowStateIncludeSchema).optional()
    })
    .strict();

export const WorkflowStateSelectSchema: z.ZodType<Prisma.WorkflowStateSelect> =
  z
    .object({
      id: z.boolean().optional(),
      userId: z.boolean().optional(),
      workflowId: z.boolean().optional(),
      status: z.boolean().optional(),
      startedAt: z.boolean().optional(),
      updatedAt: z.boolean().optional(),
      user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
      workflow: z
        .union([z.boolean(), z.lazy(() => WorkflowArgsSchema)])
        .optional()
    })
    .strict();

// EXECUTION
//------------------------------------------------------

export const ExecutionIncludeSchema: z.ZodType<Prisma.ExecutionInclude> = z
  .object({
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    action: z.union([z.boolean(), z.lazy(() => ActionArgsSchema)]).optional(),
    rule: z.union([z.boolean(), z.lazy(() => RuleArgsSchema)]).optional()
  })
  .strict();

export const ExecutionArgsSchema: z.ZodType<Prisma.ExecutionDefaultArgs> = z
  .object({
    select: z.lazy(() => ExecutionSelectSchema).optional(),
    include: z.lazy(() => ExecutionIncludeSchema).optional()
  })
  .strict();

export const ExecutionSelectSchema: z.ZodType<Prisma.ExecutionSelect> = z
  .object({
    id: z.boolean().optional(),
    userId: z.boolean().optional(),
    actionId: z.boolean().optional(),
    ruleId: z.boolean().optional(),
    executedAt: z.boolean().optional(),
    status: z.boolean().optional(),
    errorMessage: z.boolean().optional(),
    resultPayload: z.boolean().optional(),
    correlationId: z.boolean().optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    action: z.union([z.boolean(), z.lazy(() => ActionArgsSchema)]).optional(),
    rule: z.union([z.boolean(), z.lazy(() => RuleArgsSchema)]).optional()
  })
  .strict();

/////////////////////////////////////////
// INPUT TYPES
/////////////////////////////////////////

export const TwoFactorConfirmationWhereInputSchema: z.ZodType<Prisma.TwoFactorConfirmationWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => TwoFactorConfirmationWhereInputSchema),
          z.lazy(() => TwoFactorConfirmationWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => TwoFactorConfirmationWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => TwoFactorConfirmationWhereInputSchema),
          z.lazy(() => TwoFactorConfirmationWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      userId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      user: z
        .union([
          z.lazy(() => UserScalarRelationFilterSchema),
          z.lazy(() => UserWhereInputSchema)
        ])
        .optional()
    })
    .strict();

export const TwoFactorConfirmationOrderByWithRelationInputSchema: z.ZodType<Prisma.TwoFactorConfirmationOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const TwoFactorConfirmationWhereUniqueInputSchema: z.ZodType<Prisma.TwoFactorConfirmationWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        userId: z.string()
      }),
      z.object({
        id: z.string().cuid()
      }),
      z.object({
        userId: z.string()
      })
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          userId: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => TwoFactorConfirmationWhereInputSchema),
              z.lazy(() => TwoFactorConfirmationWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => TwoFactorConfirmationWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => TwoFactorConfirmationWhereInputSchema),
              z.lazy(() => TwoFactorConfirmationWhereInputSchema).array()
            ])
            .optional(),
          user: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional()
        })
        .strict()
    );

export const TwoFactorConfirmationOrderByWithAggregationInputSchema: z.ZodType<Prisma.TwoFactorConfirmationOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => TwoFactorConfirmationCountOrderByAggregateInputSchema)
        .optional(),
      _max: z
        .lazy(() => TwoFactorConfirmationMaxOrderByAggregateInputSchema)
        .optional(),
      _min: z
        .lazy(() => TwoFactorConfirmationMinOrderByAggregateInputSchema)
        .optional()
    })
    .strict();

export const TwoFactorConfirmationScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.TwoFactorConfirmationScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(
            () => TwoFactorConfirmationScalarWhereWithAggregatesInputSchema
          ),
          z
            .lazy(
              () => TwoFactorConfirmationScalarWhereWithAggregatesInputSchema
            )
            .array()
        ])
        .optional(),
      OR: z
        .lazy(() => TwoFactorConfirmationScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(
            () => TwoFactorConfirmationScalarWhereWithAggregatesInputSchema
          ),
          z
            .lazy(
              () => TwoFactorConfirmationScalarWhereWithAggregatesInputSchema
            )
            .array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      userId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const AccountWhereInputSchema: z.ZodType<Prisma.AccountWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => AccountWhereInputSchema),
        z.lazy(() => AccountWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => AccountWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => AccountWhereInputSchema),
        z.lazy(() => AccountWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    providerId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    providerAccountId: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    password: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    refresh_token: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    access_token: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    expires_at: z
      .union([z.lazy(() => IntNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    scope: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    id_token: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    user: z
      .union([
        z.lazy(() => UserScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema)
      ])
      .optional()
  })
  .strict();

export const AccountOrderByWithRelationInputSchema: z.ZodType<Prisma.AccountOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      providerId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      providerAccountId: z.lazy(() => SortOrderSchema).optional(),
      password: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      refresh_token: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      access_token: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      expires_at: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      scope: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      id_token: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const AccountWhereUniqueInputSchema: z.ZodType<Prisma.AccountWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        providerId_providerAccountId: z.lazy(
          () => AccountProviderIdProviderAccountIdCompoundUniqueInputSchema
        )
      }),
      z.object({
        id: z.string().cuid()
      }),
      z.object({
        providerId_providerAccountId: z.lazy(
          () => AccountProviderIdProviderAccountIdCompoundUniqueInputSchema
        )
      })
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          providerId_providerAccountId: z
            .lazy(
              () => AccountProviderIdProviderAccountIdCompoundUniqueInputSchema
            )
            .optional(),
          AND: z
            .union([
              z.lazy(() => AccountWhereInputSchema),
              z.lazy(() => AccountWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => AccountWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => AccountWhereInputSchema),
              z.lazy(() => AccountWhereInputSchema).array()
            ])
            .optional(),
          providerId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          providerAccountId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          password: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          refresh_token: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          access_token: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          expires_at: z
            .union([z.lazy(() => IntNullableFilterSchema), z.number().int()])
            .optional()
            .nullable(),
          scope: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          id_token: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          userId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          user: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional()
        })
        .strict()
    );

export const AccountOrderByWithAggregationInputSchema: z.ZodType<Prisma.AccountOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      providerId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      providerAccountId: z.lazy(() => SortOrderSchema).optional(),
      password: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      refresh_token: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      access_token: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      expires_at: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      scope: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      id_token: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => AccountCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => AccountAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => AccountMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => AccountMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => AccountSumOrderByAggregateInputSchema).optional()
    })
    .strict();

export const AccountScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.AccountScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => AccountScalarWhereWithAggregatesInputSchema),
          z.lazy(() => AccountScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => AccountScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => AccountScalarWhereWithAggregatesInputSchema),
          z.lazy(() => AccountScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      providerId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      providerAccountId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      password: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      refresh_token: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      access_token: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      expires_at: z
        .union([
          z.lazy(() => IntNullableWithAggregatesFilterSchema),
          z.number()
        ])
        .optional()
        .nullable(),
      scope: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      id_token: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      userId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const SessionWhereInputSchema: z.ZodType<Prisma.SessionWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => SessionWhereInputSchema),
        z.lazy(() => SessionWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => SessionWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => SessionWhereInputSchema),
        z.lazy(() => SessionWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    sessionToken: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    expires: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    ipAddress: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    userAgent: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    user: z
      .union([
        z.lazy(() => UserScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema)
      ])
      .optional()
  })
  .strict();

export const SessionOrderByWithRelationInputSchema: z.ZodType<Prisma.SessionOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      sessionToken: z.lazy(() => SortOrderSchema).optional(),
      expires: z.lazy(() => SortOrderSchema).optional(),
      ipAddress: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      userAgent: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const SessionWhereUniqueInputSchema: z.ZodType<Prisma.SessionWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        sessionToken: z.string()
      }),
      z.object({
        id: z.string().cuid()
      }),
      z.object({
        sessionToken: z.string()
      })
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          sessionToken: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => SessionWhereInputSchema),
              z.lazy(() => SessionWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => SessionWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => SessionWhereInputSchema),
              z.lazy(() => SessionWhereInputSchema).array()
            ])
            .optional(),
          expires: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          ipAddress: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          userAgent: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          userId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          user: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional()
        })
        .strict()
    );

export const SessionOrderByWithAggregationInputSchema: z.ZodType<Prisma.SessionOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      sessionToken: z.lazy(() => SortOrderSchema).optional(),
      expires: z.lazy(() => SortOrderSchema).optional(),
      ipAddress: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      userAgent: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => SessionCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => SessionMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => SessionMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const SessionScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.SessionScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => SessionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => SessionScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => SessionScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => SessionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => SessionScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      sessionToken: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      expires: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      ipAddress: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      userAgent: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      userId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const VerificationWhereInputSchema: z.ZodType<Prisma.VerificationWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => VerificationWhereInputSchema),
          z.lazy(() => VerificationWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => VerificationWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => VerificationWhereInputSchema),
          z.lazy(() => VerificationWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      identifier: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      value: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      expiresAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional()
    })
    .strict();

export const VerificationOrderByWithRelationInputSchema: z.ZodType<Prisma.VerificationOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      identifier: z.lazy(() => SortOrderSchema).optional(),
      value: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const VerificationWhereUniqueInputSchema: z.ZodType<Prisma.VerificationWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid()
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => VerificationWhereInputSchema),
              z.lazy(() => VerificationWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => VerificationWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => VerificationWhereInputSchema),
              z.lazy(() => VerificationWhereInputSchema).array()
            ])
            .optional(),
          identifier: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          value: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          expiresAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional()
        })
        .strict()
    );

export const VerificationOrderByWithAggregationInputSchema: z.ZodType<Prisma.VerificationOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      identifier: z.lazy(() => SortOrderSchema).optional(),
      value: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => VerificationCountOrderByAggregateInputSchema)
        .optional(),
      _max: z.lazy(() => VerificationMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => VerificationMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const VerificationScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.VerificationScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => VerificationScalarWhereWithAggregatesInputSchema),
          z.lazy(() => VerificationScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => VerificationScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => VerificationScalarWhereWithAggregatesInputSchema),
          z.lazy(() => VerificationScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      identifier: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      value: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      expiresAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional()
    })
    .strict();

export const AuthenticatorWhereInputSchema: z.ZodType<Prisma.AuthenticatorWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => AuthenticatorWhereInputSchema),
          z.lazy(() => AuthenticatorWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => AuthenticatorWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => AuthenticatorWhereInputSchema),
          z.lazy(() => AuthenticatorWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      credentialID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      providerAccountId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      credentialPublicKey: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      counter: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      credentialDeviceType: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      credentialBackedUp: z
        .union([z.lazy(() => BoolFilterSchema), z.boolean()])
        .optional(),
      transports: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      userId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      user: z
        .union([
          z.lazy(() => UserScalarRelationFilterSchema),
          z.lazy(() => UserWhereInputSchema)
        ])
        .optional()
    })
    .strict();

export const AuthenticatorOrderByWithRelationInputSchema: z.ZodType<Prisma.AuthenticatorOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      credentialID: z.lazy(() => SortOrderSchema).optional(),
      providerAccountId: z.lazy(() => SortOrderSchema).optional(),
      credentialPublicKey: z.lazy(() => SortOrderSchema).optional(),
      counter: z.lazy(() => SortOrderSchema).optional(),
      credentialDeviceType: z.lazy(() => SortOrderSchema).optional(),
      credentialBackedUp: z.lazy(() => SortOrderSchema).optional(),
      transports: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const AuthenticatorWhereUniqueInputSchema: z.ZodType<Prisma.AuthenticatorWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        credentialID: z.string(),
        userId_credentialID: z.lazy(
          () => AuthenticatorUserIdCredentialIDCompoundUniqueInputSchema
        )
      }),
      z.object({
        id: z.string().cuid(),
        credentialID: z.string()
      }),
      z.object({
        id: z.string().cuid(),
        userId_credentialID: z.lazy(
          () => AuthenticatorUserIdCredentialIDCompoundUniqueInputSchema
        )
      }),
      z.object({
        id: z.string().cuid()
      }),
      z.object({
        credentialID: z.string(),
        userId_credentialID: z.lazy(
          () => AuthenticatorUserIdCredentialIDCompoundUniqueInputSchema
        )
      }),
      z.object({
        credentialID: z.string()
      }),
      z.object({
        userId_credentialID: z.lazy(
          () => AuthenticatorUserIdCredentialIDCompoundUniqueInputSchema
        )
      })
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          credentialID: z.string().optional(),
          userId_credentialID: z
            .lazy(
              () => AuthenticatorUserIdCredentialIDCompoundUniqueInputSchema
            )
            .optional(),
          AND: z
            .union([
              z.lazy(() => AuthenticatorWhereInputSchema),
              z.lazy(() => AuthenticatorWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => AuthenticatorWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => AuthenticatorWhereInputSchema),
              z.lazy(() => AuthenticatorWhereInputSchema).array()
            ])
            .optional(),
          providerAccountId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          credentialPublicKey: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          counter: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          credentialDeviceType: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          credentialBackedUp: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          transports: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          userId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          user: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional()
        })
        .strict()
    );

export const AuthenticatorOrderByWithAggregationInputSchema: z.ZodType<Prisma.AuthenticatorOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      credentialID: z.lazy(() => SortOrderSchema).optional(),
      providerAccountId: z.lazy(() => SortOrderSchema).optional(),
      credentialPublicKey: z.lazy(() => SortOrderSchema).optional(),
      counter: z.lazy(() => SortOrderSchema).optional(),
      credentialDeviceType: z.lazy(() => SortOrderSchema).optional(),
      credentialBackedUp: z.lazy(() => SortOrderSchema).optional(),
      transports: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => AuthenticatorCountOrderByAggregateInputSchema)
        .optional(),
      _avg: z
        .lazy(() => AuthenticatorAvgOrderByAggregateInputSchema)
        .optional(),
      _max: z
        .lazy(() => AuthenticatorMaxOrderByAggregateInputSchema)
        .optional(),
      _min: z
        .lazy(() => AuthenticatorMinOrderByAggregateInputSchema)
        .optional(),
      _sum: z.lazy(() => AuthenticatorSumOrderByAggregateInputSchema).optional()
    })
    .strict();

export const AuthenticatorScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.AuthenticatorScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => AuthenticatorScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => AuthenticatorScalarWhereWithAggregatesInputSchema)
            .array()
        ])
        .optional(),
      OR: z
        .lazy(() => AuthenticatorScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => AuthenticatorScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => AuthenticatorScalarWhereWithAggregatesInputSchema)
            .array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      credentialID: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      providerAccountId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      credentialPublicKey: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      counter: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      credentialDeviceType: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      credentialBackedUp: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      transports: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      userId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const PasswordResetTokenWhereInputSchema: z.ZodType<Prisma.PasswordResetTokenWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => PasswordResetTokenWhereInputSchema),
          z.lazy(() => PasswordResetTokenWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => PasswordResetTokenWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => PasswordResetTokenWhereInputSchema),
          z.lazy(() => PasswordResetTokenWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      email: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      token: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      expires: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional()
    })
    .strict();

export const PasswordResetTokenOrderByWithRelationInputSchema: z.ZodType<Prisma.PasswordResetTokenOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      token: z.lazy(() => SortOrderSchema).optional(),
      expires: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const PasswordResetTokenWhereUniqueInputSchema: z.ZodType<Prisma.PasswordResetTokenWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        token: z.string(),
        email_token: z.lazy(
          () => PasswordResetTokenEmailTokenCompoundUniqueInputSchema
        )
      }),
      z.object({
        id: z.string().cuid(),
        token: z.string()
      }),
      z.object({
        id: z.string().cuid(),
        email_token: z.lazy(
          () => PasswordResetTokenEmailTokenCompoundUniqueInputSchema
        )
      }),
      z.object({
        id: z.string().cuid()
      }),
      z.object({
        token: z.string(),
        email_token: z.lazy(
          () => PasswordResetTokenEmailTokenCompoundUniqueInputSchema
        )
      }),
      z.object({
        token: z.string()
      }),
      z.object({
        email_token: z.lazy(
          () => PasswordResetTokenEmailTokenCompoundUniqueInputSchema
        )
      })
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          token: z.string().optional(),
          email_token: z
            .lazy(() => PasswordResetTokenEmailTokenCompoundUniqueInputSchema)
            .optional(),
          AND: z
            .union([
              z.lazy(() => PasswordResetTokenWhereInputSchema),
              z.lazy(() => PasswordResetTokenWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => PasswordResetTokenWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => PasswordResetTokenWhereInputSchema),
              z.lazy(() => PasswordResetTokenWhereInputSchema).array()
            ])
            .optional(),
          email: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          expires: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional()
        })
        .strict()
    );

export const PasswordResetTokenOrderByWithAggregationInputSchema: z.ZodType<Prisma.PasswordResetTokenOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      token: z.lazy(() => SortOrderSchema).optional(),
      expires: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => PasswordResetTokenCountOrderByAggregateInputSchema)
        .optional(),
      _max: z
        .lazy(() => PasswordResetTokenMaxOrderByAggregateInputSchema)
        .optional(),
      _min: z
        .lazy(() => PasswordResetTokenMinOrderByAggregateInputSchema)
        .optional()
    })
    .strict();

export const PasswordResetTokenScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.PasswordResetTokenScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => PasswordResetTokenScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => PasswordResetTokenScalarWhereWithAggregatesInputSchema)
            .array()
        ])
        .optional(),
      OR: z
        .lazy(() => PasswordResetTokenScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => PasswordResetTokenScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => PasswordResetTokenScalarWhereWithAggregatesInputSchema)
            .array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      email: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      token: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      expires: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional()
    })
    .strict();

export const TwoFactorTokenWhereInputSchema: z.ZodType<Prisma.TwoFactorTokenWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => TwoFactorTokenWhereInputSchema),
          z.lazy(() => TwoFactorTokenWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => TwoFactorTokenWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => TwoFactorTokenWhereInputSchema),
          z.lazy(() => TwoFactorTokenWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      email: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      token: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      expires: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional()
    })
    .strict();

export const TwoFactorTokenOrderByWithRelationInputSchema: z.ZodType<Prisma.TwoFactorTokenOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      token: z.lazy(() => SortOrderSchema).optional(),
      expires: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const TwoFactorTokenWhereUniqueInputSchema: z.ZodType<Prisma.TwoFactorTokenWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        token: z.string(),
        email_token: z.lazy(
          () => TwoFactorTokenEmailTokenCompoundUniqueInputSchema
        )
      }),
      z.object({
        id: z.string().cuid(),
        token: z.string()
      }),
      z.object({
        id: z.string().cuid(),
        email_token: z.lazy(
          () => TwoFactorTokenEmailTokenCompoundUniqueInputSchema
        )
      }),
      z.object({
        id: z.string().cuid()
      }),
      z.object({
        token: z.string(),
        email_token: z.lazy(
          () => TwoFactorTokenEmailTokenCompoundUniqueInputSchema
        )
      }),
      z.object({
        token: z.string()
      }),
      z.object({
        email_token: z.lazy(
          () => TwoFactorTokenEmailTokenCompoundUniqueInputSchema
        )
      })
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          token: z.string().optional(),
          email_token: z
            .lazy(() => TwoFactorTokenEmailTokenCompoundUniqueInputSchema)
            .optional(),
          AND: z
            .union([
              z.lazy(() => TwoFactorTokenWhereInputSchema),
              z.lazy(() => TwoFactorTokenWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => TwoFactorTokenWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => TwoFactorTokenWhereInputSchema),
              z.lazy(() => TwoFactorTokenWhereInputSchema).array()
            ])
            .optional(),
          email: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          expires: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional()
        })
        .strict()
    );

export const TwoFactorTokenOrderByWithAggregationInputSchema: z.ZodType<Prisma.TwoFactorTokenOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      token: z.lazy(() => SortOrderSchema).optional(),
      expires: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => TwoFactorTokenCountOrderByAggregateInputSchema)
        .optional(),
      _max: z
        .lazy(() => TwoFactorTokenMaxOrderByAggregateInputSchema)
        .optional(),
      _min: z
        .lazy(() => TwoFactorTokenMinOrderByAggregateInputSchema)
        .optional()
    })
    .strict();

export const TwoFactorTokenScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.TwoFactorTokenScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => TwoFactorTokenScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => TwoFactorTokenScalarWhereWithAggregatesInputSchema)
            .array()
        ])
        .optional(),
      OR: z
        .lazy(() => TwoFactorTokenScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => TwoFactorTokenScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => TwoFactorTokenScalarWhereWithAggregatesInputSchema)
            .array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      email: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      token: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      expires: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional()
    })
    .strict();

export const CustomerWhereInputSchema: z.ZodType<Prisma.CustomerWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => CustomerWhereInputSchema),
        z.lazy(() => CustomerWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => CustomerWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => CustomerWhereInputSchema),
        z.lazy(() => CustomerWhereInputSchema).array()
      ])
      .optional(),
    stripe_customer_id: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    user: z
      .union([
        z.lazy(() => UserScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema)
      ])
      .optional()
  })
  .strict();

export const CustomerOrderByWithRelationInputSchema: z.ZodType<Prisma.CustomerOrderByWithRelationInput> =
  z
    .object({
      stripe_customer_id: z.lazy(() => SortOrderSchema).optional(),
      id: z.lazy(() => SortOrderSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const CustomerWhereUniqueInputSchema: z.ZodType<Prisma.CustomerWhereUniqueInput> =
  z
    .union([
      z.object({
        stripe_customer_id: z.string(),
        id: z.string()
      }),
      z.object({
        stripe_customer_id: z.string()
      }),
      z.object({
        id: z.string()
      })
    ])
    .and(
      z
        .object({
          stripe_customer_id: z.string().optional(),
          id: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => CustomerWhereInputSchema),
              z.lazy(() => CustomerWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => CustomerWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => CustomerWhereInputSchema),
              z.lazy(() => CustomerWhereInputSchema).array()
            ])
            .optional(),
          user: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional()
        })
        .strict()
    );

export const CustomerOrderByWithAggregationInputSchema: z.ZodType<Prisma.CustomerOrderByWithAggregationInput> =
  z
    .object({
      stripe_customer_id: z.lazy(() => SortOrderSchema).optional(),
      id: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => CustomerCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => CustomerMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => CustomerMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const CustomerScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.CustomerScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CustomerScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CustomerScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => CustomerScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CustomerScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CustomerScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      stripe_customer_id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const ProductWhereInputSchema: z.ZodType<Prisma.ProductWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => ProductWhereInputSchema),
        z.lazy(() => ProductWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => ProductWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => ProductWhereInputSchema),
        z.lazy(() => ProductWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    active: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    description: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    image: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    metadata: z.lazy(() => JsonFilterSchema).optional(),
    prices: z.lazy(() => PriceListRelationFilterSchema).optional()
  })
  .strict();

export const ProductOrderByWithRelationInputSchema: z.ZodType<Prisma.ProductOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      image: z.lazy(() => SortOrderSchema).optional(),
      metadata: z.lazy(() => SortOrderSchema).optional(),
      prices: z.lazy(() => PriceOrderByRelationAggregateInputSchema).optional()
    })
    .strict();

export const ProductWhereUniqueInputSchema: z.ZodType<Prisma.ProductWhereUniqueInput> =
  z
    .object({
      id: z.string()
    })
    .and(
      z
        .object({
          id: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => ProductWhereInputSchema),
              z.lazy(() => ProductWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => ProductWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => ProductWhereInputSchema),
              z.lazy(() => ProductWhereInputSchema).array()
            ])
            .optional(),
          active: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          name: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          description: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          image: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          metadata: z.lazy(() => JsonFilterSchema).optional(),
          prices: z.lazy(() => PriceListRelationFilterSchema).optional()
        })
        .strict()
    );

export const ProductOrderByWithAggregationInputSchema: z.ZodType<Prisma.ProductOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      image: z.lazy(() => SortOrderSchema).optional(),
      metadata: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => ProductCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => ProductMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => ProductMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const ProductScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.ProductScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ProductScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ProductScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => ProductScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ProductScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ProductScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      active: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      name: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      description: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      image: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      metadata: z.lazy(() => JsonWithAggregatesFilterSchema).optional()
    })
    .strict();

export const PriceWhereInputSchema: z.ZodType<Prisma.PriceWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => PriceWhereInputSchema),
        z.lazy(() => PriceWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => PriceWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => PriceWhereInputSchema),
        z.lazy(() => PriceWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    active: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    description: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    unit_amount: z
      .union([z.lazy(() => IntNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    currency: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    type: z
      .union([
        z.lazy(() => EnumPricingTypeFilterSchema),
        z.lazy(() => PricingTypeSchema)
      ])
      .optional(),
    interval: z
      .union([
        z.lazy(() => EnumPricingPlanIntervalNullableFilterSchema),
        z.lazy(() => PricingPlanIntervalSchema)
      ])
      .optional()
      .nullable(),
    interval_count: z
      .union([z.lazy(() => IntNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    trial_period_days: z
      .union([z.lazy(() => IntNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    metadata: z.lazy(() => JsonFilterSchema).optional(),
    productId: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    subscriptions: z
      .lazy(() => SubscriptionListRelationFilterSchema)
      .optional(),
    product: z
      .union([
        z.lazy(() => ProductScalarRelationFilterSchema),
        z.lazy(() => ProductWhereInputSchema)
      ])
      .optional()
  })
  .strict();

export const PriceOrderByWithRelationInputSchema: z.ZodType<Prisma.PriceOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      unit_amount: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      interval: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      interval_count: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      trial_period_days: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      metadata: z.lazy(() => SortOrderSchema).optional(),
      productId: z.lazy(() => SortOrderSchema).optional(),
      subscriptions: z
        .lazy(() => SubscriptionOrderByRelationAggregateInputSchema)
        .optional(),
      product: z.lazy(() => ProductOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const PriceWhereUniqueInputSchema: z.ZodType<Prisma.PriceWhereUniqueInput> =
  z
    .object({
      id: z.string()
    })
    .and(
      z
        .object({
          id: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => PriceWhereInputSchema),
              z.lazy(() => PriceWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => PriceWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => PriceWhereInputSchema),
              z.lazy(() => PriceWhereInputSchema).array()
            ])
            .optional(),
          active: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          description: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          unit_amount: z
            .union([z.lazy(() => IntNullableFilterSchema), z.number().int()])
            .optional()
            .nullable(),
          currency: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          type: z
            .union([
              z.lazy(() => EnumPricingTypeFilterSchema),
              z.lazy(() => PricingTypeSchema)
            ])
            .optional(),
          interval: z
            .union([
              z.lazy(() => EnumPricingPlanIntervalNullableFilterSchema),
              z.lazy(() => PricingPlanIntervalSchema)
            ])
            .optional()
            .nullable(),
          interval_count: z
            .union([z.lazy(() => IntNullableFilterSchema), z.number().int()])
            .optional()
            .nullable(),
          trial_period_days: z
            .union([z.lazy(() => IntNullableFilterSchema), z.number().int()])
            .optional()
            .nullable(),
          metadata: z.lazy(() => JsonFilterSchema).optional(),
          productId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          subscriptions: z
            .lazy(() => SubscriptionListRelationFilterSchema)
            .optional(),
          product: z
            .union([
              z.lazy(() => ProductScalarRelationFilterSchema),
              z.lazy(() => ProductWhereInputSchema)
            ])
            .optional()
        })
        .strict()
    );

export const PriceOrderByWithAggregationInputSchema: z.ZodType<Prisma.PriceOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      unit_amount: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      interval: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      interval_count: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      trial_period_days: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      metadata: z.lazy(() => SortOrderSchema).optional(),
      productId: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => PriceCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => PriceAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => PriceMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => PriceMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => PriceSumOrderByAggregateInputSchema).optional()
    })
    .strict();

export const PriceScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.PriceScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => PriceScalarWhereWithAggregatesInputSchema),
          z.lazy(() => PriceScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => PriceScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => PriceScalarWhereWithAggregatesInputSchema),
          z.lazy(() => PriceScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      active: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      description: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      unit_amount: z
        .union([
          z.lazy(() => IntNullableWithAggregatesFilterSchema),
          z.number()
        ])
        .optional()
        .nullable(),
      currency: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      type: z
        .union([
          z.lazy(() => EnumPricingTypeWithAggregatesFilterSchema),
          z.lazy(() => PricingTypeSchema)
        ])
        .optional(),
      interval: z
        .union([
          z.lazy(
            () => EnumPricingPlanIntervalNullableWithAggregatesFilterSchema
          ),
          z.lazy(() => PricingPlanIntervalSchema)
        ])
        .optional()
        .nullable(),
      interval_count: z
        .union([
          z.lazy(() => IntNullableWithAggregatesFilterSchema),
          z.number()
        ])
        .optional()
        .nullable(),
      trial_period_days: z
        .union([
          z.lazy(() => IntNullableWithAggregatesFilterSchema),
          z.number()
        ])
        .optional()
        .nullable(),
      metadata: z.lazy(() => JsonWithAggregatesFilterSchema).optional(),
      productId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const SubscriptionWhereInputSchema: z.ZodType<Prisma.SubscriptionWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => SubscriptionWhereInputSchema),
          z.lazy(() => SubscriptionWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => SubscriptionWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => SubscriptionWhereInputSchema),
          z.lazy(() => SubscriptionWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      status: z
        .union([
          z.lazy(() => EnumSubscriptionStatusFilterSchema),
          z.lazy(() => SubscriptionStatusSchema)
        ])
        .optional(),
      metadata: z.lazy(() => JsonFilterSchema).optional(),
      quantity: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      cancel_at_period_end: z
        .union([z.lazy(() => BoolFilterSchema), z.boolean()])
        .optional(),
      created: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      current_period_start: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      current_period_end: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      ended_at: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      cancel_at: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      canceled_at: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      trial_start: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      trial_end: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      priceId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      userId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      price: z
        .union([
          z.lazy(() => PriceScalarRelationFilterSchema),
          z.lazy(() => PriceWhereInputSchema)
        ])
        .optional(),
      user: z
        .union([
          z.lazy(() => UserScalarRelationFilterSchema),
          z.lazy(() => UserWhereInputSchema)
        ])
        .optional()
    })
    .strict();

export const SubscriptionOrderByWithRelationInputSchema: z.ZodType<Prisma.SubscriptionOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      metadata: z.lazy(() => SortOrderSchema).optional(),
      quantity: z.lazy(() => SortOrderSchema).optional(),
      cancel_at_period_end: z.lazy(() => SortOrderSchema).optional(),
      created: z.lazy(() => SortOrderSchema).optional(),
      current_period_start: z.lazy(() => SortOrderSchema).optional(),
      current_period_end: z.lazy(() => SortOrderSchema).optional(),
      ended_at: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      cancel_at: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      canceled_at: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      trial_start: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      trial_end: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      priceId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      price: z.lazy(() => PriceOrderByWithRelationInputSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const SubscriptionWhereUniqueInputSchema: z.ZodType<Prisma.SubscriptionWhereUniqueInput> =
  z
    .object({
      id: z.string()
    })
    .and(
      z
        .object({
          id: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => SubscriptionWhereInputSchema),
              z.lazy(() => SubscriptionWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => SubscriptionWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => SubscriptionWhereInputSchema),
              z.lazy(() => SubscriptionWhereInputSchema).array()
            ])
            .optional(),
          status: z
            .union([
              z.lazy(() => EnumSubscriptionStatusFilterSchema),
              z.lazy(() => SubscriptionStatusSchema)
            ])
            .optional(),
          metadata: z.lazy(() => JsonFilterSchema).optional(),
          quantity: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          cancel_at_period_end: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          created: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          current_period_start: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          current_period_end: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          ended_at: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date()
            ])
            .optional()
            .nullable(),
          cancel_at: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date()
            ])
            .optional()
            .nullable(),
          canceled_at: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date()
            ])
            .optional()
            .nullable(),
          trial_start: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date()
            ])
            .optional()
            .nullable(),
          trial_end: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date()
            ])
            .optional()
            .nullable(),
          priceId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          userId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          price: z
            .union([
              z.lazy(() => PriceScalarRelationFilterSchema),
              z.lazy(() => PriceWhereInputSchema)
            ])
            .optional(),
          user: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional()
        })
        .strict()
    );

export const SubscriptionOrderByWithAggregationInputSchema: z.ZodType<Prisma.SubscriptionOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      metadata: z.lazy(() => SortOrderSchema).optional(),
      quantity: z.lazy(() => SortOrderSchema).optional(),
      cancel_at_period_end: z.lazy(() => SortOrderSchema).optional(),
      created: z.lazy(() => SortOrderSchema).optional(),
      current_period_start: z.lazy(() => SortOrderSchema).optional(),
      current_period_end: z.lazy(() => SortOrderSchema).optional(),
      ended_at: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      cancel_at: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      canceled_at: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      trial_start: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      trial_end: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      priceId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => SubscriptionCountOrderByAggregateInputSchema)
        .optional(),
      _avg: z.lazy(() => SubscriptionAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => SubscriptionMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => SubscriptionMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => SubscriptionSumOrderByAggregateInputSchema).optional()
    })
    .strict();

export const SubscriptionScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.SubscriptionScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => SubscriptionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => SubscriptionScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => SubscriptionScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => SubscriptionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => SubscriptionScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumSubscriptionStatusWithAggregatesFilterSchema),
          z.lazy(() => SubscriptionStatusSchema)
        ])
        .optional(),
      metadata: z.lazy(() => JsonWithAggregatesFilterSchema).optional(),
      quantity: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      cancel_at_period_end: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      created: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      current_period_start: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      current_period_end: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      ended_at: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional()
        .nullable(),
      cancel_at: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional()
        .nullable(),
      canceled_at: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional()
        .nullable(),
      trial_start: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional()
        .nullable(),
      trial_end: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional()
        .nullable(),
      priceId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      userId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const FeedWhereInputSchema: z.ZodType<Prisma.FeedWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => FeedWhereInputSchema),
        z.lazy(() => FeedWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => FeedWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => FeedWhereInputSchema),
        z.lazy(() => FeedWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    type: z
      .union([
        z.lazy(() => EnumFeedTypeFilterSchema),
        z.lazy(() => FeedTypeSchema)
      ])
      .optional(),
    content: z.lazy(() => JsonFilterSchema).optional(),
    commentable: z
      .union([z.lazy(() => BoolFilterSchema), z.boolean()])
      .optional(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    siteId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    site: z
      .union([
        z.lazy(() => SiteScalarRelationFilterSchema),
        z.lazy(() => SiteWhereInputSchema)
      ])
      .optional(),
    user: z
      .union([
        z.lazy(() => UserScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema)
      ])
      .optional(),
    comments: z.lazy(() => CommentListRelationFilterSchema).optional(),
    likes: z.lazy(() => LikeListRelationFilterSchema).optional()
  })
  .strict();

export const FeedOrderByWithRelationInputSchema: z.ZodType<Prisma.FeedOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      commentable: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      site: z.lazy(() => SiteOrderByWithRelationInputSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      comments: z
        .lazy(() => CommentOrderByRelationAggregateInputSchema)
        .optional(),
      likes: z.lazy(() => LikeOrderByRelationAggregateInputSchema).optional()
    })
    .strict();

export const FeedWhereUniqueInputSchema: z.ZodType<Prisma.FeedWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid()
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => FeedWhereInputSchema),
              z.lazy(() => FeedWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => FeedWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => FeedWhereInputSchema),
              z.lazy(() => FeedWhereInputSchema).array()
            ])
            .optional(),
          type: z
            .union([
              z.lazy(() => EnumFeedTypeFilterSchema),
              z.lazy(() => FeedTypeSchema)
            ])
            .optional(),
          content: z.lazy(() => JsonFilterSchema).optional(),
          commentable: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          siteId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          userId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          site: z
            .union([
              z.lazy(() => SiteScalarRelationFilterSchema),
              z.lazy(() => SiteWhereInputSchema)
            ])
            .optional(),
          user: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional(),
          comments: z.lazy(() => CommentListRelationFilterSchema).optional(),
          likes: z.lazy(() => LikeListRelationFilterSchema).optional()
        })
        .strict()
    );

export const FeedOrderByWithAggregationInputSchema: z.ZodType<Prisma.FeedOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      commentable: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => FeedCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => FeedMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => FeedMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const FeedScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.FeedScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => FeedScalarWhereWithAggregatesInputSchema),
          z.lazy(() => FeedScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => FeedScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => FeedScalarWhereWithAggregatesInputSchema),
          z.lazy(() => FeedScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      type: z
        .union([
          z.lazy(() => EnumFeedTypeWithAggregatesFilterSchema),
          z.lazy(() => FeedTypeSchema)
        ])
        .optional(),
      content: z.lazy(() => JsonWithAggregatesFilterSchema).optional(),
      commentable: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      siteId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      userId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const CommentWhereInputSchema: z.ZodType<Prisma.CommentWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => CommentWhereInputSchema),
        z.lazy(() => CommentWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => CommentWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => CommentWhereInputSchema),
        z.lazy(() => CommentWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    content: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    feedId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    feed: z
      .union([
        z.lazy(() => FeedNullableScalarRelationFilterSchema),
        z.lazy(() => FeedWhereInputSchema)
      ])
      .optional()
      .nullable(),
    user: z
      .union([
        z.lazy(() => UserScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema)
      ])
      .optional()
  })
  .strict();

export const CommentOrderByWithRelationInputSchema: z.ZodType<Prisma.CommentOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      feedId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      feed: z.lazy(() => FeedOrderByWithRelationInputSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const CommentWhereUniqueInputSchema: z.ZodType<Prisma.CommentWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid()
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => CommentWhereInputSchema),
              z.lazy(() => CommentWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => CommentWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => CommentWhereInputSchema),
              z.lazy(() => CommentWhereInputSchema).array()
            ])
            .optional(),
          content: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          feedId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          userId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          feed: z
            .union([
              z.lazy(() => FeedNullableScalarRelationFilterSchema),
              z.lazy(() => FeedWhereInputSchema)
            ])
            .optional()
            .nullable(),
          user: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional()
        })
        .strict()
    );

export const CommentOrderByWithAggregationInputSchema: z.ZodType<Prisma.CommentOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      feedId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => CommentCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => CommentMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => CommentMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const CommentScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.CommentScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CommentScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CommentScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => CommentScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CommentScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CommentScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      content: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      feedId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      userId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const CityWhereInputSchema: z.ZodType<Prisma.CityWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => CityWhereInputSchema),
        z.lazy(() => CityWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => CityWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => CityWhereInputSchema),
        z.lazy(() => CityWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    departement: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    slug: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    nom: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    nomSimple: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    nomReel: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    nomSoundex: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    nomMetaphone: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    codePostal: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    commune: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    codeCommune: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    arrondissement: z
      .union([z.lazy(() => IntNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    canton: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    amdi: z
      .union([z.lazy(() => IntNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    population2010: z
      .union([z.lazy(() => IntNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    population1999: z
      .union([z.lazy(() => IntNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    population2012: z
      .union([z.lazy(() => IntNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    densite2010: z
      .union([z.lazy(() => IntNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    surface: z
      .union([z.lazy(() => FloatNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    longitudeDeg: z
      .union([z.lazy(() => FloatNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    latitudeDeg: z
      .union([z.lazy(() => FloatNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    longitudeGrd: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    latitudeGrd: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    longitudeDms: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    latitudeDms: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    zmin: z
      .union([z.lazy(() => IntNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    zmax: z
      .union([z.lazy(() => IntNullableFilterSchema), z.number()])
      .optional()
      .nullable()
  })
  .strict();

export const CityOrderByWithRelationInputSchema: z.ZodType<Prisma.CityOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      departement: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      slug: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      nom: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      nomSimple: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      nomReel: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      nomSoundex: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      nomMetaphone: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      codePostal: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      commune: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      codeCommune: z.lazy(() => SortOrderSchema).optional(),
      arrondissement: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      canton: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      amdi: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      population2010: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      population1999: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      population2012: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      densite2010: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      surface: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      longitudeDeg: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      latitudeDeg: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      longitudeGrd: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      latitudeGrd: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      longitudeDms: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      latitudeDms: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      zmin: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      zmax: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional()
    })
    .strict();

export const CityWhereUniqueInputSchema: z.ZodType<Prisma.CityWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.number().int(),
        slug: z.string(),
        codeCommune: z.string()
      }),
      z.object({
        id: z.number().int(),
        slug: z.string()
      }),
      z.object({
        id: z.number().int(),
        codeCommune: z.string()
      }),
      z.object({
        id: z.number().int()
      }),
      z.object({
        slug: z.string(),
        codeCommune: z.string()
      }),
      z.object({
        slug: z.string()
      }),
      z.object({
        codeCommune: z.string()
      })
    ])
    .and(
      z
        .object({
          id: z.number().int().optional(),
          slug: z.string().optional(),
          codeCommune: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => CityWhereInputSchema),
              z.lazy(() => CityWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => CityWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => CityWhereInputSchema),
              z.lazy(() => CityWhereInputSchema).array()
            ])
            .optional(),
          departement: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          nom: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          nomSimple: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          nomReel: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          nomSoundex: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          nomMetaphone: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          codePostal: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          commune: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          arrondissement: z
            .union([z.lazy(() => IntNullableFilterSchema), z.number().int()])
            .optional()
            .nullable(),
          canton: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          amdi: z
            .union([z.lazy(() => IntNullableFilterSchema), z.number().int()])
            .optional()
            .nullable(),
          population2010: z
            .union([z.lazy(() => IntNullableFilterSchema), z.number().int()])
            .optional()
            .nullable(),
          population1999: z
            .union([z.lazy(() => IntNullableFilterSchema), z.number().int()])
            .optional()
            .nullable(),
          population2012: z
            .union([z.lazy(() => IntNullableFilterSchema), z.number().int()])
            .optional()
            .nullable(),
          densite2010: z
            .union([z.lazy(() => IntNullableFilterSchema), z.number().int()])
            .optional()
            .nullable(),
          surface: z
            .union([z.lazy(() => FloatNullableFilterSchema), z.number()])
            .optional()
            .nullable(),
          longitudeDeg: z
            .union([z.lazy(() => FloatNullableFilterSchema), z.number()])
            .optional()
            .nullable(),
          latitudeDeg: z
            .union([z.lazy(() => FloatNullableFilterSchema), z.number()])
            .optional()
            .nullable(),
          longitudeGrd: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          latitudeGrd: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          longitudeDms: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          latitudeDms: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          zmin: z
            .union([z.lazy(() => IntNullableFilterSchema), z.number().int()])
            .optional()
            .nullable(),
          zmax: z
            .union([z.lazy(() => IntNullableFilterSchema), z.number().int()])
            .optional()
            .nullable()
        })
        .strict()
    );

export const CityOrderByWithAggregationInputSchema: z.ZodType<Prisma.CityOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      departement: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      slug: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      nom: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      nomSimple: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      nomReel: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      nomSoundex: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      nomMetaphone: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      codePostal: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      commune: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      codeCommune: z.lazy(() => SortOrderSchema).optional(),
      arrondissement: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      canton: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      amdi: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      population2010: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      population1999: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      population2012: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      densite2010: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      surface: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      longitudeDeg: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      latitudeDeg: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      longitudeGrd: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      latitudeGrd: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      longitudeDms: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      latitudeDms: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      zmin: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      zmax: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      _count: z.lazy(() => CityCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => CityAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => CityMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => CityMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => CitySumOrderByAggregateInputSchema).optional()
    })
    .strict();

export const CityScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.CityScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CityScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CityScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => CityScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CityScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CityScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      departement: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      nom: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      nomSimple: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      nomReel: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      nomSoundex: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      nomMetaphone: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      codePostal: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      commune: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      codeCommune: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      arrondissement: z
        .union([
          z.lazy(() => IntNullableWithAggregatesFilterSchema),
          z.number()
        ])
        .optional()
        .nullable(),
      canton: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      amdi: z
        .union([
          z.lazy(() => IntNullableWithAggregatesFilterSchema),
          z.number()
        ])
        .optional()
        .nullable(),
      population2010: z
        .union([
          z.lazy(() => IntNullableWithAggregatesFilterSchema),
          z.number()
        ])
        .optional()
        .nullable(),
      population1999: z
        .union([
          z.lazy(() => IntNullableWithAggregatesFilterSchema),
          z.number()
        ])
        .optional()
        .nullable(),
      population2012: z
        .union([
          z.lazy(() => IntNullableWithAggregatesFilterSchema),
          z.number()
        ])
        .optional()
        .nullable(),
      densite2010: z
        .union([
          z.lazy(() => IntNullableWithAggregatesFilterSchema),
          z.number()
        ])
        .optional()
        .nullable(),
      surface: z
        .union([
          z.lazy(() => FloatNullableWithAggregatesFilterSchema),
          z.number()
        ])
        .optional()
        .nullable(),
      longitudeDeg: z
        .union([
          z.lazy(() => FloatNullableWithAggregatesFilterSchema),
          z.number()
        ])
        .optional()
        .nullable(),
      latitudeDeg: z
        .union([
          z.lazy(() => FloatNullableWithAggregatesFilterSchema),
          z.number()
        ])
        .optional()
        .nullable(),
      longitudeGrd: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      latitudeGrd: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      longitudeDms: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      latitudeDms: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      zmin: z
        .union([
          z.lazy(() => IntNullableWithAggregatesFilterSchema),
          z.number()
        ])
        .optional()
        .nullable(),
      zmax: z
        .union([
          z.lazy(() => IntNullableWithAggregatesFilterSchema),
          z.number()
        ])
        .optional()
        .nullable()
    })
    .strict();

export const NafSectionWhereInputSchema: z.ZodType<Prisma.NafSectionWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => NafSectionWhereInputSchema),
          z.lazy(() => NafSectionWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => NafSectionWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => NafSectionWhereInputSchema),
          z.lazy(() => NafSectionWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      title: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      divisions: z.lazy(() => NafDivisionListRelationFilterSchema).optional()
    })
    .strict();

export const NafSectionOrderByWithRelationInputSchema: z.ZodType<Prisma.NafSectionOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      divisions: z
        .lazy(() => NafDivisionOrderByRelationAggregateInputSchema)
        .optional()
    })
    .strict();

export const NafSectionWhereUniqueInputSchema: z.ZodType<Prisma.NafSectionWhereUniqueInput> =
  z
    .object({
      id: z.string()
    })
    .and(
      z
        .object({
          id: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => NafSectionWhereInputSchema),
              z.lazy(() => NafSectionWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => NafSectionWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => NafSectionWhereInputSchema),
              z.lazy(() => NafSectionWhereInputSchema).array()
            ])
            .optional(),
          title: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          divisions: z
            .lazy(() => NafDivisionListRelationFilterSchema)
            .optional()
        })
        .strict()
    );

export const NafSectionOrderByWithAggregationInputSchema: z.ZodType<Prisma.NafSectionOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => NafSectionCountOrderByAggregateInputSchema)
        .optional(),
      _max: z.lazy(() => NafSectionMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => NafSectionMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const NafSectionScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.NafSectionScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => NafSectionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => NafSectionScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => NafSectionScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => NafSectionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => NafSectionScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      title: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const NafDivisionWhereInputSchema: z.ZodType<Prisma.NafDivisionWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => NafDivisionWhereInputSchema),
          z.lazy(() => NafDivisionWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => NafDivisionWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => NafDivisionWhereInputSchema),
          z.lazy(() => NafDivisionWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      title: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      sectionId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      groups: z.lazy(() => NafGroupListRelationFilterSchema).optional(),
      section: z
        .union([
          z.lazy(() => NafSectionScalarRelationFilterSchema),
          z.lazy(() => NafSectionWhereInputSchema)
        ])
        .optional()
    })
    .strict();

export const NafDivisionOrderByWithRelationInputSchema: z.ZodType<Prisma.NafDivisionOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      sectionId: z.lazy(() => SortOrderSchema).optional(),
      groups: z
        .lazy(() => NafGroupOrderByRelationAggregateInputSchema)
        .optional(),
      section: z.lazy(() => NafSectionOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const NafDivisionWhereUniqueInputSchema: z.ZodType<Prisma.NafDivisionWhereUniqueInput> =
  z
    .object({
      id: z.string()
    })
    .and(
      z
        .object({
          id: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => NafDivisionWhereInputSchema),
              z.lazy(() => NafDivisionWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => NafDivisionWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => NafDivisionWhereInputSchema),
              z.lazy(() => NafDivisionWhereInputSchema).array()
            ])
            .optional(),
          title: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          sectionId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          groups: z.lazy(() => NafGroupListRelationFilterSchema).optional(),
          section: z
            .union([
              z.lazy(() => NafSectionScalarRelationFilterSchema),
              z.lazy(() => NafSectionWhereInputSchema)
            ])
            .optional()
        })
        .strict()
    );

export const NafDivisionOrderByWithAggregationInputSchema: z.ZodType<Prisma.NafDivisionOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      sectionId: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => NafDivisionCountOrderByAggregateInputSchema)
        .optional(),
      _max: z.lazy(() => NafDivisionMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => NafDivisionMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const NafDivisionScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.NafDivisionScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => NafDivisionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => NafDivisionScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => NafDivisionScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => NafDivisionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => NafDivisionScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      title: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      sectionId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const NafGroupWhereInputSchema: z.ZodType<Prisma.NafGroupWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => NafGroupWhereInputSchema),
        z.lazy(() => NafGroupWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => NafGroupWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => NafGroupWhereInputSchema),
        z.lazy(() => NafGroupWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    title: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    divisionId: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    classes: z.lazy(() => NafClassListRelationFilterSchema).optional(),
    division: z
      .union([
        z.lazy(() => NafDivisionScalarRelationFilterSchema),
        z.lazy(() => NafDivisionWhereInputSchema)
      ])
      .optional()
  })
  .strict();

export const NafGroupOrderByWithRelationInputSchema: z.ZodType<Prisma.NafGroupOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      divisionId: z.lazy(() => SortOrderSchema).optional(),
      classes: z
        .lazy(() => NafClassOrderByRelationAggregateInputSchema)
        .optional(),
      division: z
        .lazy(() => NafDivisionOrderByWithRelationInputSchema)
        .optional()
    })
    .strict();

export const NafGroupWhereUniqueInputSchema: z.ZodType<Prisma.NafGroupWhereUniqueInput> =
  z
    .object({
      id: z.string()
    })
    .and(
      z
        .object({
          id: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => NafGroupWhereInputSchema),
              z.lazy(() => NafGroupWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => NafGroupWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => NafGroupWhereInputSchema),
              z.lazy(() => NafGroupWhereInputSchema).array()
            ])
            .optional(),
          title: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          divisionId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          classes: z.lazy(() => NafClassListRelationFilterSchema).optional(),
          division: z
            .union([
              z.lazy(() => NafDivisionScalarRelationFilterSchema),
              z.lazy(() => NafDivisionWhereInputSchema)
            ])
            .optional()
        })
        .strict()
    );

export const NafGroupOrderByWithAggregationInputSchema: z.ZodType<Prisma.NafGroupOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      divisionId: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => NafGroupCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => NafGroupMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => NafGroupMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const NafGroupScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.NafGroupScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => NafGroupScalarWhereWithAggregatesInputSchema),
          z.lazy(() => NafGroupScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => NafGroupScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => NafGroupScalarWhereWithAggregatesInputSchema),
          z.lazy(() => NafGroupScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      title: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      divisionId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const NafClassWhereInputSchema: z.ZodType<Prisma.NafClassWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => NafClassWhereInputSchema),
        z.lazy(() => NafClassWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => NafClassWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => NafClassWhereInputSchema),
        z.lazy(() => NafClassWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    title: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    groupId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    codes: z.lazy(() => NafCodeListRelationFilterSchema).optional(),
    group: z
      .union([
        z.lazy(() => NafGroupScalarRelationFilterSchema),
        z.lazy(() => NafGroupWhereInputSchema)
      ])
      .optional()
  })
  .strict();

export const NafClassOrderByWithRelationInputSchema: z.ZodType<Prisma.NafClassOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      groupId: z.lazy(() => SortOrderSchema).optional(),
      codes: z
        .lazy(() => NafCodeOrderByRelationAggregateInputSchema)
        .optional(),
      group: z.lazy(() => NafGroupOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const NafClassWhereUniqueInputSchema: z.ZodType<Prisma.NafClassWhereUniqueInput> =
  z
    .object({
      id: z.string()
    })
    .and(
      z
        .object({
          id: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => NafClassWhereInputSchema),
              z.lazy(() => NafClassWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => NafClassWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => NafClassWhereInputSchema),
              z.lazy(() => NafClassWhereInputSchema).array()
            ])
            .optional(),
          title: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          groupId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          codes: z.lazy(() => NafCodeListRelationFilterSchema).optional(),
          group: z
            .union([
              z.lazy(() => NafGroupScalarRelationFilterSchema),
              z.lazy(() => NafGroupWhereInputSchema)
            ])
            .optional()
        })
        .strict()
    );

export const NafClassOrderByWithAggregationInputSchema: z.ZodType<Prisma.NafClassOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      groupId: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => NafClassCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => NafClassMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => NafClassMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const NafClassScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.NafClassScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => NafClassScalarWhereWithAggregatesInputSchema),
          z.lazy(() => NafClassScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => NafClassScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => NafClassScalarWhereWithAggregatesInputSchema),
          z.lazy(() => NafClassScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      title: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      groupId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const NafCodeWhereInputSchema: z.ZodType<Prisma.NafCodeWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => NafCodeWhereInputSchema),
        z.lazy(() => NafCodeWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => NafCodeWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => NafCodeWhereInputSchema),
        z.lazy(() => NafCodeWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    title: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    classId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    class: z
      .union([
        z.lazy(() => NafClassScalarRelationFilterSchema),
        z.lazy(() => NafClassWhereInputSchema)
      ])
      .optional(),
    users: z.lazy(() => UserListRelationFilterSchema).optional()
  })
  .strict();

export const NafCodeOrderByWithRelationInputSchema: z.ZodType<Prisma.NafCodeOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      classId: z.lazy(() => SortOrderSchema).optional(),
      class: z.lazy(() => NafClassOrderByWithRelationInputSchema).optional(),
      users: z.lazy(() => UserOrderByRelationAggregateInputSchema).optional()
    })
    .strict();

export const NafCodeWhereUniqueInputSchema: z.ZodType<Prisma.NafCodeWhereUniqueInput> =
  z
    .object({
      id: z.string()
    })
    .and(
      z
        .object({
          id: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => NafCodeWhereInputSchema),
              z.lazy(() => NafCodeWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => NafCodeWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => NafCodeWhereInputSchema),
              z.lazy(() => NafCodeWhereInputSchema).array()
            ])
            .optional(),
          title: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          classId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          class: z
            .union([
              z.lazy(() => NafClassScalarRelationFilterSchema),
              z.lazy(() => NafClassWhereInputSchema)
            ])
            .optional(),
          users: z.lazy(() => UserListRelationFilterSchema).optional()
        })
        .strict()
    );

export const NafCodeOrderByWithAggregationInputSchema: z.ZodType<Prisma.NafCodeOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      classId: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => NafCodeCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => NafCodeMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => NafCodeMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const NafCodeScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.NafCodeScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => NafCodeScalarWhereWithAggregatesInputSchema),
          z.lazy(() => NafCodeScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => NafCodeScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => NafCodeScalarWhereWithAggregatesInputSchema),
          z.lazy(() => NafCodeScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      title: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      classId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const OutboxWhereInputSchema: z.ZodType<Prisma.OutboxWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => OutboxWhereInputSchema),
        z.lazy(() => OutboxWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => OutboxWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => OutboxWhereInputSchema),
        z.lazy(() => OutboxWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    email: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    subject: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    body: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    status: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    metadata: z.lazy(() => JsonNullableFilterSchema).optional(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    campaignId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    campaign: z
      .union([
        z.lazy(() => CampaignNullableScalarRelationFilterSchema),
        z.lazy(() => CampaignWhereInputSchema)
      ])
      .optional()
      .nullable(),
    user: z
      .union([
        z.lazy(() => UserNullableScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema)
      ])
      .optional()
      .nullable()
  })
  .strict();

export const OutboxOrderByWithRelationInputSchema: z.ZodType<Prisma.OutboxOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      subject: z.lazy(() => SortOrderSchema).optional(),
      body: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      metadata: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      campaignId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      campaign: z.lazy(() => CampaignOrderByWithRelationInputSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const OutboxWhereUniqueInputSchema: z.ZodType<Prisma.OutboxWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid()
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => OutboxWhereInputSchema),
              z.lazy(() => OutboxWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => OutboxWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => OutboxWhereInputSchema),
              z.lazy(() => OutboxWhereInputSchema).array()
            ])
            .optional(),
          email: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          subject: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          body: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          status: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          metadata: z.lazy(() => JsonNullableFilterSchema).optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          campaignId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          campaign: z
            .union([
              z.lazy(() => CampaignNullableScalarRelationFilterSchema),
              z.lazy(() => CampaignWhereInputSchema)
            ])
            .optional()
            .nullable(),
          user: z
            .union([
              z.lazy(() => UserNullableScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional()
            .nullable()
        })
        .strict()
    );

export const OutboxOrderByWithAggregationInputSchema: z.ZodType<Prisma.OutboxOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      subject: z.lazy(() => SortOrderSchema).optional(),
      body: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      metadata: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      campaignId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      _count: z.lazy(() => OutboxCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => OutboxMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => OutboxMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const OutboxScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.OutboxScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OutboxScalarWhereWithAggregatesInputSchema),
          z.lazy(() => OutboxScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => OutboxScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OutboxScalarWhereWithAggregatesInputSchema),
          z.lazy(() => OutboxScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      email: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      subject: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      body: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      status: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      metadata: z.lazy(() => JsonNullableWithAggregatesFilterSchema).optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      campaignId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ListWhereInputSchema: z.ZodType<Prisma.ListWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => ListWhereInputSchema),
        z.lazy(() => ListWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => ListWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => ListWhereInputSchema),
        z.lazy(() => ListWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    title: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    description: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    owners: z.lazy(() => UserListRelationFilterSchema).optional(),
    contacts: z.lazy(() => UserListRelationFilterSchema).optional(),
    campaigns: z.lazy(() => CampaignListRelationFilterSchema).optional()
  })
  .strict();

export const ListOrderByWithRelationInputSchema: z.ZodType<Prisma.ListOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      owners: z.lazy(() => UserOrderByRelationAggregateInputSchema).optional(),
      contacts: z
        .lazy(() => UserOrderByRelationAggregateInputSchema)
        .optional(),
      campaigns: z
        .lazy(() => CampaignOrderByRelationAggregateInputSchema)
        .optional()
    })
    .strict();

export const ListWhereUniqueInputSchema: z.ZodType<Prisma.ListWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid()
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => ListWhereInputSchema),
              z.lazy(() => ListWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => ListWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => ListWhereInputSchema),
              z.lazy(() => ListWhereInputSchema).array()
            ])
            .optional(),
          title: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          owners: z.lazy(() => UserListRelationFilterSchema).optional(),
          contacts: z.lazy(() => UserListRelationFilterSchema).optional(),
          campaigns: z.lazy(() => CampaignListRelationFilterSchema).optional()
        })
        .strict()
    );

export const ListOrderByWithAggregationInputSchema: z.ZodType<Prisma.ListOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => ListCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => ListMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => ListMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const ListScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.ListScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ListScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ListScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => ListScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ListScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ListScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      title: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      description: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional()
    })
    .strict();

export const CampaignWhereInputSchema: z.ZodType<Prisma.CampaignWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => CampaignWhereInputSchema),
        z.lazy(() => CampaignWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => CampaignWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => CampaignWhereInputSchema),
        z.lazy(() => CampaignWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    type: z
      .union([
        z.lazy(() => EnumCampaignTypeFilterSchema),
        z.lazy(() => CampaignTypeSchema)
      ])
      .optional(),
    smart: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    title: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    description: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    active: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    listId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    emailId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    list: z
      .union([
        z.lazy(() => ListNullableScalarRelationFilterSchema),
        z.lazy(() => ListWhereInputSchema)
      ])
      .optional()
      .nullable(),
    email: z
      .union([
        z.lazy(() => EmailScalarRelationFilterSchema),
        z.lazy(() => EmailWhereInputSchema)
      ])
      .optional(),
    outboxes: z.lazy(() => OutboxListRelationFilterSchema).optional()
  })
  .strict();

export const CampaignOrderByWithRelationInputSchema: z.ZodType<Prisma.CampaignOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      smart: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      listId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      emailId: z.lazy(() => SortOrderSchema).optional(),
      list: z.lazy(() => ListOrderByWithRelationInputSchema).optional(),
      email: z.lazy(() => EmailOrderByWithRelationInputSchema).optional(),
      outboxes: z
        .lazy(() => OutboxOrderByRelationAggregateInputSchema)
        .optional()
    })
    .strict();

export const CampaignWhereUniqueInputSchema: z.ZodType<Prisma.CampaignWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid()
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => CampaignWhereInputSchema),
              z.lazy(() => CampaignWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => CampaignWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => CampaignWhereInputSchema),
              z.lazy(() => CampaignWhereInputSchema).array()
            ])
            .optional(),
          type: z
            .union([
              z.lazy(() => EnumCampaignTypeFilterSchema),
              z.lazy(() => CampaignTypeSchema)
            ])
            .optional(),
          smart: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          title: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          active: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          listId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          emailId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          list: z
            .union([
              z.lazy(() => ListNullableScalarRelationFilterSchema),
              z.lazy(() => ListWhereInputSchema)
            ])
            .optional()
            .nullable(),
          email: z
            .union([
              z.lazy(() => EmailScalarRelationFilterSchema),
              z.lazy(() => EmailWhereInputSchema)
            ])
            .optional(),
          outboxes: z.lazy(() => OutboxListRelationFilterSchema).optional()
        })
        .strict()
    );

export const CampaignOrderByWithAggregationInputSchema: z.ZodType<Prisma.CampaignOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      smart: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      listId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      emailId: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => CampaignCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => CampaignMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => CampaignMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const CampaignScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.CampaignScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CampaignScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CampaignScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => CampaignScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CampaignScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CampaignScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      type: z
        .union([
          z.lazy(() => EnumCampaignTypeWithAggregatesFilterSchema),
          z.lazy(() => CampaignTypeSchema)
        ])
        .optional(),
      smart: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      title: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      description: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      active: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      listId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      emailId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const EmailWhereInputSchema: z.ZodType<Prisma.EmailWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => EmailWhereInputSchema),
        z.lazy(() => EmailWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => EmailWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => EmailWhereInputSchema),
        z.lazy(() => EmailWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    title: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    description: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    subject: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    content: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    design: z.lazy(() => JsonFilterSchema).optional(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    user: z
      .union([
        z.lazy(() => UserScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema)
      ])
      .optional(),
    campaigns: z.lazy(() => CampaignListRelationFilterSchema).optional()
  })
  .strict();

export const EmailOrderByWithRelationInputSchema: z.ZodType<Prisma.EmailOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      subject: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      design: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      campaigns: z
        .lazy(() => CampaignOrderByRelationAggregateInputSchema)
        .optional()
    })
    .strict();

export const EmailWhereUniqueInputSchema: z.ZodType<Prisma.EmailWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid()
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => EmailWhereInputSchema),
              z.lazy(() => EmailWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => EmailWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => EmailWhereInputSchema),
              z.lazy(() => EmailWhereInputSchema).array()
            ])
            .optional(),
          title: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          subject: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          content: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          design: z.lazy(() => JsonFilterSchema).optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          userId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          user: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional(),
          campaigns: z.lazy(() => CampaignListRelationFilterSchema).optional()
        })
        .strict()
    );

export const EmailOrderByWithAggregationInputSchema: z.ZodType<Prisma.EmailOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      subject: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      design: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => EmailCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => EmailMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => EmailMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const EmailScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.EmailScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => EmailScalarWhereWithAggregatesInputSchema),
          z.lazy(() => EmailScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => EmailScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => EmailScalarWhereWithAggregatesInputSchema),
          z.lazy(() => EmailScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      title: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      description: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      subject: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      content: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      design: z.lazy(() => JsonWithAggregatesFilterSchema).optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      userId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const MediaWhereInputSchema: z.ZodType<Prisma.MediaWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => MediaWhereInputSchema),
        z.lazy(() => MediaWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => MediaWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => MediaWhereInputSchema),
        z.lazy(() => MediaWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    entityId: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    entityType: z
      .union([
        z.lazy(() => EnumEntityTypeFilterSchema),
        z.lazy(() => EntityTypeSchema)
      ])
      .optional(),
    url: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    alt: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    type: z
      .union([
        z.lazy(() => EnumMediaTypeFilterSchema),
        z.lazy(() => MediaTypeSchema)
      ])
      .optional(),
    position: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    isMain: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional()
  })
  .strict();

export const MediaOrderByWithRelationInputSchema: z.ZodType<Prisma.MediaOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      entityId: z.lazy(() => SortOrderSchema).optional(),
      entityType: z.lazy(() => SortOrderSchema).optional(),
      url: z.lazy(() => SortOrderSchema).optional(),
      alt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      position: z.lazy(() => SortOrderSchema).optional(),
      isMain: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const MediaWhereUniqueInputSchema: z.ZodType<Prisma.MediaWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid()
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => MediaWhereInputSchema),
              z.lazy(() => MediaWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => MediaWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => MediaWhereInputSchema),
              z.lazy(() => MediaWhereInputSchema).array()
            ])
            .optional(),
          entityId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          entityType: z
            .union([
              z.lazy(() => EnumEntityTypeFilterSchema),
              z.lazy(() => EntityTypeSchema)
            ])
            .optional(),
          url: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          alt: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          type: z
            .union([
              z.lazy(() => EnumMediaTypeFilterSchema),
              z.lazy(() => MediaTypeSchema)
            ])
            .optional(),
          position: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          isMain: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional()
        })
        .strict()
    );

export const MediaOrderByWithAggregationInputSchema: z.ZodType<Prisma.MediaOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      entityId: z.lazy(() => SortOrderSchema).optional(),
      entityType: z.lazy(() => SortOrderSchema).optional(),
      url: z.lazy(() => SortOrderSchema).optional(),
      alt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      position: z.lazy(() => SortOrderSchema).optional(),
      isMain: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => MediaCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => MediaAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => MediaMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => MediaMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => MediaSumOrderByAggregateInputSchema).optional()
    })
    .strict();

export const MediaScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.MediaScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => MediaScalarWhereWithAggregatesInputSchema),
          z.lazy(() => MediaScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => MediaScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => MediaScalarWhereWithAggregatesInputSchema),
          z.lazy(() => MediaScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      entityId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      entityType: z
        .union([
          z.lazy(() => EnumEntityTypeWithAggregatesFilterSchema),
          z.lazy(() => EntityTypeSchema)
        ])
        .optional(),
      url: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      alt: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => EnumMediaTypeWithAggregatesFilterSchema),
          z.lazy(() => MediaTypeSchema)
        ])
        .optional(),
      position: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      isMain: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional()
    })
    .strict();

export const ClickWhereInputSchema: z.ZodType<Prisma.ClickWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => ClickWhereInputSchema),
        z.lazy(() => ClickWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => ClickWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => ClickWhereInputSchema),
        z.lazy(() => ClickWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    part: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    path: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    request: z.lazy(() => JsonNullableFilterSchema).optional(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    blockId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    siteId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    linkId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    userId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    refererId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    block: z
      .union([
        z.lazy(() => BlockNullableScalarRelationFilterSchema),
        z.lazy(() => BlockWhereInputSchema)
      ])
      .optional()
      .nullable(),
    site: z
      .union([
        z.lazy(() => SiteNullableScalarRelationFilterSchema),
        z.lazy(() => SiteWhereInputSchema)
      ])
      .optional()
      .nullable(),
    link: z
      .union([
        z.lazy(() => LinkNullableScalarRelationFilterSchema),
        z.lazy(() => LinkWhereInputSchema)
      ])
      .optional()
      .nullable(),
    user: z
      .union([
        z.lazy(() => UserNullableScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema)
      ])
      .optional()
      .nullable(),
    referer: z
      .union([
        z.lazy(() => UserNullableScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema)
      ])
      .optional()
      .nullable()
  })
  .strict();

export const ClickOrderByWithRelationInputSchema: z.ZodType<Prisma.ClickOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      part: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      path: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      request: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      blockId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      linkId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      block: z.lazy(() => BlockOrderByWithRelationInputSchema).optional(),
      site: z.lazy(() => SiteOrderByWithRelationInputSchema).optional(),
      link: z.lazy(() => LinkOrderByWithRelationInputSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      referer: z.lazy(() => UserOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const ClickWhereUniqueInputSchema: z.ZodType<Prisma.ClickWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid()
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => ClickWhereInputSchema),
              z.lazy(() => ClickWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => ClickWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => ClickWhereInputSchema),
              z.lazy(() => ClickWhereInputSchema).array()
            ])
            .optional(),
          part: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          path: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          request: z.lazy(() => JsonNullableFilterSchema).optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          blockId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          siteId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          linkId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          userId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          refererId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          block: z
            .union([
              z.lazy(() => BlockNullableScalarRelationFilterSchema),
              z.lazy(() => BlockWhereInputSchema)
            ])
            .optional()
            .nullable(),
          site: z
            .union([
              z.lazy(() => SiteNullableScalarRelationFilterSchema),
              z.lazy(() => SiteWhereInputSchema)
            ])
            .optional()
            .nullable(),
          link: z
            .union([
              z.lazy(() => LinkNullableScalarRelationFilterSchema),
              z.lazy(() => LinkWhereInputSchema)
            ])
            .optional()
            .nullable(),
          user: z
            .union([
              z.lazy(() => UserNullableScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional()
            .nullable(),
          referer: z
            .union([
              z.lazy(() => UserNullableScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional()
            .nullable()
        })
        .strict()
    );

export const ClickOrderByWithAggregationInputSchema: z.ZodType<Prisma.ClickOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      part: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      path: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      request: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      blockId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      linkId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      _count: z.lazy(() => ClickCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => ClickMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => ClickMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const ClickScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.ClickScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ClickScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ClickScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => ClickScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ClickScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ClickScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      part: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      path: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      request: z.lazy(() => JsonNullableWithAggregatesFilterSchema).optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      blockId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      siteId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      linkId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      userId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      refererId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable()
    })
    .strict();

export const LinkWhereInputSchema: z.ZodType<Prisma.LinkWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => LinkWhereInputSchema),
        z.lazy(() => LinkWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => LinkWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => LinkWhereInputSchema),
        z.lazy(() => LinkWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    url: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    name: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    description: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    userId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    clicks: z.lazy(() => ClickListRelationFilterSchema).optional(),
    user: z
      .union([
        z.lazy(() => UserNullableScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema)
      ])
      .optional()
      .nullable()
  })
  .strict();

export const LinkOrderByWithRelationInputSchema: z.ZodType<Prisma.LinkOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      url: z.lazy(() => SortOrderSchema).optional(),
      name: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      clicks: z.lazy(() => ClickOrderByRelationAggregateInputSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const LinkWhereUniqueInputSchema: z.ZodType<Prisma.LinkWhereUniqueInput> =
  z
    .object({
      id: z.string()
    })
    .and(
      z
        .object({
          id: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => LinkWhereInputSchema),
              z.lazy(() => LinkWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => LinkWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => LinkWhereInputSchema),
              z.lazy(() => LinkWhereInputSchema).array()
            ])
            .optional(),
          url: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          name: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          userId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          clicks: z.lazy(() => ClickListRelationFilterSchema).optional(),
          user: z
            .union([
              z.lazy(() => UserNullableScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional()
            .nullable()
        })
        .strict()
    );

export const LinkOrderByWithAggregationInputSchema: z.ZodType<Prisma.LinkOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      url: z.lazy(() => SortOrderSchema).optional(),
      name: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      _count: z.lazy(() => LinkCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => LinkMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => LinkMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const LinkScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.LinkScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => LinkScalarWhereWithAggregatesInputSchema),
          z.lazy(() => LinkScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => LinkScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => LinkScalarWhereWithAggregatesInputSchema),
          z.lazy(() => LinkScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      url: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      name: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      userId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable()
    })
    .strict();

export const BlockWhereInputSchema: z.ZodType<Prisma.BlockWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => BlockWhereInputSchema),
        z.lazy(() => BlockWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => BlockWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => BlockWhereInputSchema),
        z.lazy(() => BlockWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    type: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    position: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    label: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    href: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    logo: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    style: z.lazy(() => JsonNullableFilterSchema).optional(),
    widget: z.lazy(() => JsonNullableFilterSchema).optional(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    siteId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    clicks: z.lazy(() => ClickListRelationFilterSchema).optional(),
    reservations: z.lazy(() => ReservationListRelationFilterSchema).optional(),
    site: z
      .union([
        z.lazy(() => SiteScalarRelationFilterSchema),
        z.lazy(() => SiteWhereInputSchema)
      ])
      .optional(),
    categories: z.lazy(() => CategoryListRelationFilterSchema).optional(),
    inventories: z.lazy(() => InventoryListRelationFilterSchema).optional()
  })
  .strict();

export const BlockOrderByWithRelationInputSchema: z.ZodType<Prisma.BlockOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      position: z.lazy(() => SortOrderSchema).optional(),
      label: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      href: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      logo: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      style: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional(),
      clicks: z.lazy(() => ClickOrderByRelationAggregateInputSchema).optional(),
      reservations: z
        .lazy(() => ReservationOrderByRelationAggregateInputSchema)
        .optional(),
      site: z.lazy(() => SiteOrderByWithRelationInputSchema).optional(),
      categories: z
        .lazy(() => CategoryOrderByRelationAggregateInputSchema)
        .optional(),
      inventories: z
        .lazy(() => InventoryOrderByRelationAggregateInputSchema)
        .optional()
    })
    .strict();

export const BlockWhereUniqueInputSchema: z.ZodType<Prisma.BlockWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid()
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => BlockWhereInputSchema),
              z.lazy(() => BlockWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => BlockWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => BlockWhereInputSchema),
              z.lazy(() => BlockWhereInputSchema).array()
            ])
            .optional(),
          type: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          position: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          label: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          href: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          logo: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          style: z.lazy(() => JsonNullableFilterSchema).optional(),
          widget: z.lazy(() => JsonNullableFilterSchema).optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          siteId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          clicks: z.lazy(() => ClickListRelationFilterSchema).optional(),
          reservations: z
            .lazy(() => ReservationListRelationFilterSchema)
            .optional(),
          site: z
            .union([
              z.lazy(() => SiteScalarRelationFilterSchema),
              z.lazy(() => SiteWhereInputSchema)
            ])
            .optional(),
          categories: z.lazy(() => CategoryListRelationFilterSchema).optional(),
          inventories: z
            .lazy(() => InventoryListRelationFilterSchema)
            .optional()
        })
        .strict()
    );

export const BlockOrderByWithAggregationInputSchema: z.ZodType<Prisma.BlockOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      position: z.lazy(() => SortOrderSchema).optional(),
      label: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      href: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      logo: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      style: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => BlockCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => BlockAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => BlockMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => BlockMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => BlockSumOrderByAggregateInputSchema).optional()
    })
    .strict();

export const BlockScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.BlockScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => BlockScalarWhereWithAggregatesInputSchema),
          z.lazy(() => BlockScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => BlockScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => BlockScalarWhereWithAggregatesInputSchema),
          z.lazy(() => BlockScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      type: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      position: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      label: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      href: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      style: z.lazy(() => JsonNullableWithAggregatesFilterSchema).optional(),
      widget: z.lazy(() => JsonNullableWithAggregatesFilterSchema).optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      siteId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const LikeWhereInputSchema: z.ZodType<Prisma.LikeWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => LikeWhereInputSchema),
        z.lazy(() => LikeWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => LikeWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => LikeWhereInputSchema),
        z.lazy(() => LikeWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    ip: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    siteId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    userId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    feedId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    site: z
      .union([
        z.lazy(() => SiteScalarRelationFilterSchema),
        z.lazy(() => SiteWhereInputSchema)
      ])
      .optional(),
    user: z
      .union([
        z.lazy(() => UserNullableScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema)
      ])
      .optional()
      .nullable(),
    feed: z
      .union([
        z.lazy(() => FeedNullableScalarRelationFilterSchema),
        z.lazy(() => FeedWhereInputSchema)
      ])
      .optional()
      .nullable()
  })
  .strict();

export const LikeOrderByWithRelationInputSchema: z.ZodType<Prisma.LikeOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      ip: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional(),
      userId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      feedId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      site: z.lazy(() => SiteOrderByWithRelationInputSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      feed: z.lazy(() => FeedOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const LikeWhereUniqueInputSchema: z.ZodType<Prisma.LikeWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid()
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => LikeWhereInputSchema),
              z.lazy(() => LikeWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => LikeWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => LikeWhereInputSchema),
              z.lazy(() => LikeWhereInputSchema).array()
            ])
            .optional(),
          ip: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          siteId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          userId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          feedId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          site: z
            .union([
              z.lazy(() => SiteScalarRelationFilterSchema),
              z.lazy(() => SiteWhereInputSchema)
            ])
            .optional(),
          user: z
            .union([
              z.lazy(() => UserNullableScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional()
            .nullable(),
          feed: z
            .union([
              z.lazy(() => FeedNullableScalarRelationFilterSchema),
              z.lazy(() => FeedWhereInputSchema)
            ])
            .optional()
            .nullable()
        })
        .strict()
    );

export const LikeOrderByWithAggregationInputSchema: z.ZodType<Prisma.LikeOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      ip: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional(),
      userId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      feedId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      _count: z.lazy(() => LikeCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => LikeMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => LikeMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const LikeScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.LikeScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => LikeScalarWhereWithAggregatesInputSchema),
          z.lazy(() => LikeScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => LikeScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => LikeScalarWhereWithAggregatesInputSchema),
          z.lazy(() => LikeScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      ip: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      siteId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      userId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      feedId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable()
    })
    .strict();

export const SiteWhereInputSchema: z.ZodType<Prisma.SiteWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => SiteWhereInputSchema),
        z.lazy(() => SiteWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => SiteWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => SiteWhereInputSchema),
        z.lazy(() => SiteWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    name: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    display_name: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    description: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    logo: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    font: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    image: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    imageBlurhash: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    subdomain: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    customDomain: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    message404: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    background: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    user: z
      .union([
        z.lazy(() => UserScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema)
      ])
      .optional(),
    blocks: z.lazy(() => BlockListRelationFilterSchema).optional(),
    clicks: z.lazy(() => ClickListRelationFilterSchema).optional(),
    subscribers: z.lazy(() => SubscriberListRelationFilterSchema).optional(),
    likes: z.lazy(() => LikeListRelationFilterSchema).optional(),
    feed: z.lazy(() => FeedListRelationFilterSchema).optional()
  })
  .strict();

export const SiteOrderByWithRelationInputSchema: z.ZodType<Prisma.SiteOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      display_name: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      logo: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      font: z.lazy(() => SortOrderSchema).optional(),
      image: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      imageBlurhash: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      subdomain: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      customDomain: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      message404: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      background: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      blocks: z.lazy(() => BlockOrderByRelationAggregateInputSchema).optional(),
      clicks: z.lazy(() => ClickOrderByRelationAggregateInputSchema).optional(),
      subscribers: z
        .lazy(() => SubscriberOrderByRelationAggregateInputSchema)
        .optional(),
      likes: z.lazy(() => LikeOrderByRelationAggregateInputSchema).optional(),
      feed: z.lazy(() => FeedOrderByRelationAggregateInputSchema).optional()
    })
    .strict();

export const SiteWhereUniqueInputSchema: z.ZodType<Prisma.SiteWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        subdomain: z.string(),
        customDomain: z.string()
      }),
      z.object({
        id: z.string().cuid(),
        subdomain: z.string()
      }),
      z.object({
        id: z.string().cuid(),
        customDomain: z.string()
      }),
      z.object({
        id: z.string().cuid()
      }),
      z.object({
        subdomain: z.string(),
        customDomain: z.string()
      }),
      z.object({
        subdomain: z.string()
      }),
      z.object({
        customDomain: z.string()
      })
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          subdomain: z.string().optional(),
          customDomain: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => SiteWhereInputSchema),
              z.lazy(() => SiteWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => SiteWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => SiteWhereInputSchema),
              z.lazy(() => SiteWhereInputSchema).array()
            ])
            .optional(),
          name: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          display_name: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          logo: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          font: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          image: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          imageBlurhash: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          message404: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          background: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          userId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          user: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional(),
          blocks: z.lazy(() => BlockListRelationFilterSchema).optional(),
          clicks: z.lazy(() => ClickListRelationFilterSchema).optional(),
          subscribers: z
            .lazy(() => SubscriberListRelationFilterSchema)
            .optional(),
          likes: z.lazy(() => LikeListRelationFilterSchema).optional(),
          feed: z.lazy(() => FeedListRelationFilterSchema).optional()
        })
        .strict()
    );

export const SiteOrderByWithAggregationInputSchema: z.ZodType<Prisma.SiteOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      display_name: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      logo: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      font: z.lazy(() => SortOrderSchema).optional(),
      image: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      imageBlurhash: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      subdomain: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      customDomain: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      message404: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      background: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => SiteCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => SiteMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => SiteMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const SiteScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.SiteScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => SiteScalarWhereWithAggregatesInputSchema),
          z.lazy(() => SiteScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => SiteScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => SiteScalarWhereWithAggregatesInputSchema),
          z.lazy(() => SiteScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      name: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      display_name: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      font: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      image: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      imageBlurhash: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      subdomain: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      customDomain: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      message404: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      background: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      userId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const SubscriberWhereInputSchema: z.ZodType<Prisma.SubscriberWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => SubscriberWhereInputSchema),
          z.lazy(() => SubscriberWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => SubscriberWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => SubscriberWhereInputSchema),
          z.lazy(() => SubscriberWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      email: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      siteId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      site: z
        .union([
          z.lazy(() => SiteScalarRelationFilterSchema),
          z.lazy(() => SiteWhereInputSchema)
        ])
        .optional()
    })
    .strict();

export const SubscriberOrderByWithRelationInputSchema: z.ZodType<Prisma.SubscriberOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional(),
      site: z.lazy(() => SiteOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const SubscriberWhereUniqueInputSchema: z.ZodType<Prisma.SubscriberWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid()
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => SubscriberWhereInputSchema),
              z.lazy(() => SubscriberWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => SubscriberWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => SubscriberWhereInputSchema),
              z.lazy(() => SubscriberWhereInputSchema).array()
            ])
            .optional(),
          email: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          siteId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          site: z
            .union([
              z.lazy(() => SiteScalarRelationFilterSchema),
              z.lazy(() => SiteWhereInputSchema)
            ])
            .optional()
        })
        .strict()
    );

export const SubscriberOrderByWithAggregationInputSchema: z.ZodType<Prisma.SubscriberOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => SubscriberCountOrderByAggregateInputSchema)
        .optional(),
      _max: z.lazy(() => SubscriberMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => SubscriberMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const SubscriberScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.SubscriberScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => SubscriberScalarWhereWithAggregatesInputSchema),
          z.lazy(() => SubscriberScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => SubscriberScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => SubscriberScalarWhereWithAggregatesInputSchema),
          z.lazy(() => SubscriberScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      email: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      siteId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const ReservationWhereInputSchema: z.ZodType<Prisma.ReservationWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ReservationWhereInputSchema),
          z.lazy(() => ReservationWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => ReservationWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ReservationWhereInputSchema),
          z.lazy(() => ReservationWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      type: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      name: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      email: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      dateStart: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      dateEnd: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      comment: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      blockId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      affiliateId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      block: z
        .union([
          z.lazy(() => BlockNullableScalarRelationFilterSchema),
          z.lazy(() => BlockWhereInputSchema)
        ])
        .optional()
        .nullable(),
      affiliate: z
        .union([
          z.lazy(() => UserNullableScalarRelationFilterSchema),
          z.lazy(() => UserWhereInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ReservationOrderByWithRelationInputSchema: z.ZodType<Prisma.ReservationOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      type: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      dateStart: z.lazy(() => SortOrderSchema).optional(),
      dateEnd: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      comment: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      blockId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      affiliateId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      block: z.lazy(() => BlockOrderByWithRelationInputSchema).optional(),
      affiliate: z.lazy(() => UserOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const ReservationWhereUniqueInputSchema: z.ZodType<Prisma.ReservationWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid()
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => ReservationWhereInputSchema),
              z.lazy(() => ReservationWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => ReservationWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => ReservationWhereInputSchema),
              z.lazy(() => ReservationWhereInputSchema).array()
            ])
            .optional(),
          type: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          name: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          email: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          dateStart: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          dateEnd: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date()
            ])
            .optional()
            .nullable(),
          comment: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          blockId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          affiliateId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          block: z
            .union([
              z.lazy(() => BlockNullableScalarRelationFilterSchema),
              z.lazy(() => BlockWhereInputSchema)
            ])
            .optional()
            .nullable(),
          affiliate: z
            .union([
              z.lazy(() => UserNullableScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional()
            .nullable()
        })
        .strict()
    );

export const ReservationOrderByWithAggregationInputSchema: z.ZodType<Prisma.ReservationOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      type: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      dateStart: z.lazy(() => SortOrderSchema).optional(),
      dateEnd: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      comment: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      blockId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      affiliateId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      _count: z
        .lazy(() => ReservationCountOrderByAggregateInputSchema)
        .optional(),
      _max: z.lazy(() => ReservationMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => ReservationMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const ReservationScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.ReservationScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ReservationScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ReservationScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => ReservationScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ReservationScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ReservationScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      type: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      name: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      email: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      dateStart: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      dateEnd: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional()
        .nullable(),
      comment: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      blockId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      affiliateId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable()
    })
    .strict();

export const CategoryWhereInputSchema: z.ZodType<Prisma.CategoryWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => CategoryWhereInputSchema),
        z.lazy(() => CategoryWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => CategoryWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => CategoryWhereInputSchema),
        z.lazy(() => CategoryWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    description: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    slug: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    active: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    position: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    categoryId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    blockId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    inventories: z.lazy(() => InventoryListRelationFilterSchema).optional(),
    categories: z.lazy(() => CategoryListRelationFilterSchema).optional(),
    category: z
      .union([
        z.lazy(() => CategoryNullableScalarRelationFilterSchema),
        z.lazy(() => CategoryWhereInputSchema)
      ])
      .optional()
      .nullable(),
    block: z
      .union([
        z.lazy(() => BlockScalarRelationFilterSchema),
        z.lazy(() => BlockWhereInputSchema)
      ])
      .optional()
  })
  .strict();

export const CategoryOrderByWithRelationInputSchema: z.ZodType<Prisma.CategoryOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      position: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      categoryId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      blockId: z.lazy(() => SortOrderSchema).optional(),
      inventories: z
        .lazy(() => InventoryOrderByRelationAggregateInputSchema)
        .optional(),
      categories: z
        .lazy(() => CategoryOrderByRelationAggregateInputSchema)
        .optional(),
      category: z.lazy(() => CategoryOrderByWithRelationInputSchema).optional(),
      block: z.lazy(() => BlockOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const CategoryWhereUniqueInputSchema: z.ZodType<Prisma.CategoryWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        name: z.string(),
        slug: z.string()
      }),
      z.object({
        id: z.string().cuid(),
        name: z.string()
      }),
      z.object({
        id: z.string().cuid(),
        slug: z.string()
      }),
      z.object({
        id: z.string().cuid()
      }),
      z.object({
        name: z.string(),
        slug: z.string()
      }),
      z.object({
        name: z.string()
      }),
      z.object({
        slug: z.string()
      })
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          name: z.string().optional(),
          slug: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => CategoryWhereInputSchema),
              z.lazy(() => CategoryWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => CategoryWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => CategoryWhereInputSchema),
              z.lazy(() => CategoryWhereInputSchema).array()
            ])
            .optional(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          active: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          position: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          categoryId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          blockId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          inventories: z
            .lazy(() => InventoryListRelationFilterSchema)
            .optional(),
          categories: z.lazy(() => CategoryListRelationFilterSchema).optional(),
          category: z
            .union([
              z.lazy(() => CategoryNullableScalarRelationFilterSchema),
              z.lazy(() => CategoryWhereInputSchema)
            ])
            .optional()
            .nullable(),
          block: z
            .union([
              z.lazy(() => BlockScalarRelationFilterSchema),
              z.lazy(() => BlockWhereInputSchema)
            ])
            .optional()
        })
        .strict()
    );

export const CategoryOrderByWithAggregationInputSchema: z.ZodType<Prisma.CategoryOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      position: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      categoryId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      blockId: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => CategoryCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => CategoryAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => CategoryMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => CategoryMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => CategorySumOrderByAggregateInputSchema).optional()
    })
    .strict();

export const CategoryScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.CategoryScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CategoryScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CategoryScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => CategoryScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CategoryScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CategoryScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      name: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      description: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      slug: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      active: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      position: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      categoryId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      blockId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const InventoryWhereInputSchema: z.ZodType<Prisma.InventoryWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => InventoryWhereInputSchema),
          z.lazy(() => InventoryWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => InventoryWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => InventoryWhereInputSchema),
          z.lazy(() => InventoryWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      slug: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      sku: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      basePrice: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      active: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      isFeatured: z
        .union([z.lazy(() => BoolFilterSchema), z.boolean()])
        .optional(),
      metaTitle: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      metaDescription: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      tags: z.lazy(() => StringNullableListFilterSchema).optional(),
      stock: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      categoryId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      blockId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      category: z
        .union([
          z.lazy(() => CategoryNullableScalarRelationFilterSchema),
          z.lazy(() => CategoryWhereInputSchema)
        ])
        .optional()
        .nullable(),
      variants: z
        .lazy(() => InventoryVariantListRelationFilterSchema)
        .optional(),
      block: z
        .union([
          z.lazy(() => BlockScalarRelationFilterSchema),
          z.lazy(() => BlockWhereInputSchema)
        ])
        .optional()
    })
    .strict();

export const InventoryOrderByWithRelationInputSchema: z.ZodType<Prisma.InventoryOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      sku: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      basePrice: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      isFeatured: z.lazy(() => SortOrderSchema).optional(),
      metaTitle: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      metaDescription: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      tags: z.lazy(() => SortOrderSchema).optional(),
      stock: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      categoryId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      blockId: z.lazy(() => SortOrderSchema).optional(),
      category: z.lazy(() => CategoryOrderByWithRelationInputSchema).optional(),
      variants: z
        .lazy(() => InventoryVariantOrderByRelationAggregateInputSchema)
        .optional(),
      block: z.lazy(() => BlockOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const InventoryWhereUniqueInputSchema: z.ZodType<Prisma.InventoryWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        slug: z.string(),
        sku: z.string()
      }),
      z.object({
        id: z.string().cuid(),
        slug: z.string()
      }),
      z.object({
        id: z.string().cuid(),
        sku: z.string()
      }),
      z.object({
        id: z.string().cuid()
      }),
      z.object({
        slug: z.string(),
        sku: z.string()
      }),
      z.object({
        slug: z.string()
      }),
      z.object({
        sku: z.string()
      })
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          slug: z.string().optional(),
          sku: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => InventoryWhereInputSchema),
              z.lazy(() => InventoryWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => InventoryWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => InventoryWhereInputSchema),
              z.lazy(() => InventoryWhereInputSchema).array()
            ])
            .optional(),
          name: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          basePrice: z
            .union([z.lazy(() => FloatFilterSchema), z.number()])
            .optional(),
          active: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          isFeatured: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          metaTitle: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          metaDescription: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          tags: z.lazy(() => StringNullableListFilterSchema).optional(),
          stock: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          categoryId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          blockId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          category: z
            .union([
              z.lazy(() => CategoryNullableScalarRelationFilterSchema),
              z.lazy(() => CategoryWhereInputSchema)
            ])
            .optional()
            .nullable(),
          variants: z
            .lazy(() => InventoryVariantListRelationFilterSchema)
            .optional(),
          block: z
            .union([
              z.lazy(() => BlockScalarRelationFilterSchema),
              z.lazy(() => BlockWhereInputSchema)
            ])
            .optional()
        })
        .strict()
    );

export const InventoryOrderByWithAggregationInputSchema: z.ZodType<Prisma.InventoryOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      sku: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      basePrice: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      isFeatured: z.lazy(() => SortOrderSchema).optional(),
      metaTitle: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      metaDescription: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      tags: z.lazy(() => SortOrderSchema).optional(),
      stock: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      categoryId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      blockId: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => InventoryCountOrderByAggregateInputSchema)
        .optional(),
      _avg: z.lazy(() => InventoryAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => InventoryMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => InventoryMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => InventorySumOrderByAggregateInputSchema).optional()
    })
    .strict();

export const InventoryScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.InventoryScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => InventoryScalarWhereWithAggregatesInputSchema),
          z.lazy(() => InventoryScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => InventoryScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => InventoryScalarWhereWithAggregatesInputSchema),
          z.lazy(() => InventoryScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      name: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      description: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      slug: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      sku: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      basePrice: z
        .union([z.lazy(() => FloatWithAggregatesFilterSchema), z.number()])
        .optional(),
      active: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      isFeatured: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      metaTitle: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      metaDescription: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      tags: z.lazy(() => StringNullableListFilterSchema).optional(),
      stock: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      categoryId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      blockId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const InventoryVariantWhereInputSchema: z.ZodType<Prisma.InventoryVariantWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => InventoryVariantWhereInputSchema),
          z.lazy(() => InventoryVariantWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => InventoryVariantWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => InventoryVariantWhereInputSchema),
          z.lazy(() => InventoryVariantWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      inventoryId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      value: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      type: z
        .union([
          z.lazy(() => EnumVariantTypeFilterSchema),
          z.lazy(() => VariantTypeSchema)
        ])
        .optional(),
      price: z
        .union([
          z.lazy(() => DecimalNullableFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema
            ])
            .refine(v => isValidDecimalInput(v), {
              message: 'Must be a Decimal'
            })
        ])
        .optional()
        .nullable(),
      stock: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      active: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      position: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      inventory: z
        .union([
          z.lazy(() => InventoryScalarRelationFilterSchema),
          z.lazy(() => InventoryWhereInputSchema)
        ])
        .optional()
    })
    .strict();

export const InventoryVariantOrderByWithRelationInputSchema: z.ZodType<Prisma.InventoryVariantOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      inventoryId: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      value: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      price: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      stock: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      position: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      inventory: z
        .lazy(() => InventoryOrderByWithRelationInputSchema)
        .optional()
    })
    .strict();

export const InventoryVariantWhereUniqueInputSchema: z.ZodType<Prisma.InventoryVariantWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        inventoryId_type_value: z.lazy(
          () => InventoryVariantInventoryIdTypeValueCompoundUniqueInputSchema
        )
      }),
      z.object({
        id: z.string().cuid()
      }),
      z.object({
        inventoryId_type_value: z.lazy(
          () => InventoryVariantInventoryIdTypeValueCompoundUniqueInputSchema
        )
      })
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          inventoryId_type_value: z
            .lazy(
              () =>
                InventoryVariantInventoryIdTypeValueCompoundUniqueInputSchema
            )
            .optional(),
          AND: z
            .union([
              z.lazy(() => InventoryVariantWhereInputSchema),
              z.lazy(() => InventoryVariantWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => InventoryVariantWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => InventoryVariantWhereInputSchema),
              z.lazy(() => InventoryVariantWhereInputSchema).array()
            ])
            .optional(),
          inventoryId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          name: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          value: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          type: z
            .union([
              z.lazy(() => EnumVariantTypeFilterSchema),
              z.lazy(() => VariantTypeSchema)
            ])
            .optional(),
          price: z
            .union([
              z.lazy(() => DecimalNullableFilterSchema),
              z
                .union([
                  z.number(),
                  z.string(),
                  z.instanceof(Decimal),
                  z.instanceof(Prisma.Decimal),
                  DecimalJsLikeSchema
                ])
                .refine(v => isValidDecimalInput(v), {
                  message: 'Must be a Decimal'
                })
            ])
            .optional()
            .nullable(),
          stock: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          active: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          position: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          inventory: z
            .union([
              z.lazy(() => InventoryScalarRelationFilterSchema),
              z.lazy(() => InventoryWhereInputSchema)
            ])
            .optional()
        })
        .strict()
    );

export const InventoryVariantOrderByWithAggregationInputSchema: z.ZodType<Prisma.InventoryVariantOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      inventoryId: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      value: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      price: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      stock: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      position: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => InventoryVariantCountOrderByAggregateInputSchema)
        .optional(),
      _avg: z
        .lazy(() => InventoryVariantAvgOrderByAggregateInputSchema)
        .optional(),
      _max: z
        .lazy(() => InventoryVariantMaxOrderByAggregateInputSchema)
        .optional(),
      _min: z
        .lazy(() => InventoryVariantMinOrderByAggregateInputSchema)
        .optional(),
      _sum: z
        .lazy(() => InventoryVariantSumOrderByAggregateInputSchema)
        .optional()
    })
    .strict();

export const InventoryVariantScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.InventoryVariantScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => InventoryVariantScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => InventoryVariantScalarWhereWithAggregatesInputSchema)
            .array()
        ])
        .optional(),
      OR: z
        .lazy(() => InventoryVariantScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => InventoryVariantScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => InventoryVariantScalarWhereWithAggregatesInputSchema)
            .array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      inventoryId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      name: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      value: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      type: z
        .union([
          z.lazy(() => EnumVariantTypeWithAggregatesFilterSchema),
          z.lazy(() => VariantTypeSchema)
        ])
        .optional(),
      price: z
        .union([
          z.lazy(() => DecimalNullableWithAggregatesFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema
            ])
            .refine(v => isValidDecimalInput(v), {
              message: 'Must be a Decimal'
            })
        ])
        .optional()
        .nullable(),
      stock: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      active: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      position: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional()
    })
    .strict();

export const CronWhereInputSchema: z.ZodType<Prisma.CronWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => CronWhereInputSchema),
        z.lazy(() => CronWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => CronWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => CronWhereInputSchema),
        z.lazy(() => CronWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    cronExpr: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    timezone: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    modulePath: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    functionName: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    enabled: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    lastRunAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    lastStatus: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    lastDurationMs: z
      .union([z.lazy(() => IntNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    lockedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    history: z.lazy(() => HistoryListRelationFilterSchema).optional()
  })
  .strict();

export const CronOrderByWithRelationInputSchema: z.ZodType<Prisma.CronOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      cronExpr: z.lazy(() => SortOrderSchema).optional(),
      timezone: z.lazy(() => SortOrderSchema).optional(),
      modulePath: z.lazy(() => SortOrderSchema).optional(),
      functionName: z.lazy(() => SortOrderSchema).optional(),
      enabled: z.lazy(() => SortOrderSchema).optional(),
      lastRunAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      lastStatus: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      lastDurationMs: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      lockedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      history: z
        .lazy(() => HistoryOrderByRelationAggregateInputSchema)
        .optional()
    })
    .strict();

export const CronWhereUniqueInputSchema: z.ZodType<Prisma.CronWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        name: z.string()
      }),
      z.object({
        id: z.string().cuid()
      }),
      z.object({
        name: z.string()
      })
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          name: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => CronWhereInputSchema),
              z.lazy(() => CronWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => CronWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => CronWhereInputSchema),
              z.lazy(() => CronWhereInputSchema).array()
            ])
            .optional(),
          cronExpr: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          timezone: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          modulePath: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          functionName: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          enabled: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          lastRunAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date()
            ])
            .optional()
            .nullable(),
          lastStatus: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          lastDurationMs: z
            .union([z.lazy(() => IntNullableFilterSchema), z.number().int()])
            .optional()
            .nullable(),
          lockedAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date()
            ])
            .optional()
            .nullable(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          history: z.lazy(() => HistoryListRelationFilterSchema).optional()
        })
        .strict()
    );

export const CronOrderByWithAggregationInputSchema: z.ZodType<Prisma.CronOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      cronExpr: z.lazy(() => SortOrderSchema).optional(),
      timezone: z.lazy(() => SortOrderSchema).optional(),
      modulePath: z.lazy(() => SortOrderSchema).optional(),
      functionName: z.lazy(() => SortOrderSchema).optional(),
      enabled: z.lazy(() => SortOrderSchema).optional(),
      lastRunAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      lastStatus: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      lastDurationMs: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      lockedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => CronCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => CronAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => CronMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => CronMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => CronSumOrderByAggregateInputSchema).optional()
    })
    .strict();

export const CronScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.CronScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CronScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CronScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => CronScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CronScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CronScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      name: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      cronExpr: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      timezone: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      modulePath: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      functionName: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      enabled: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      lastRunAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional()
        .nullable(),
      lastStatus: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      lastDurationMs: z
        .union([
          z.lazy(() => IntNullableWithAggregatesFilterSchema),
          z.number()
        ])
        .optional()
        .nullable(),
      lockedAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional()
    })
    .strict();

export const HistoryWhereInputSchema: z.ZodType<Prisma.HistoryWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => HistoryWhereInputSchema),
        z.lazy(() => HistoryWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => HistoryWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => HistoryWhereInputSchema),
        z.lazy(() => HistoryWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    status: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    startedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    endedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    durationMs: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    message: z.lazy(() => JsonNullableFilterSchema).optional(),
    cronId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    cron: z
      .union([
        z.lazy(() => CronScalarRelationFilterSchema),
        z.lazy(() => CronWhereInputSchema)
      ])
      .optional()
  })
  .strict();

export const HistoryOrderByWithRelationInputSchema: z.ZodType<Prisma.HistoryOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      startedAt: z.lazy(() => SortOrderSchema).optional(),
      endedAt: z.lazy(() => SortOrderSchema).optional(),
      durationMs: z.lazy(() => SortOrderSchema).optional(),
      message: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      cronId: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      cron: z.lazy(() => CronOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const HistoryWhereUniqueInputSchema: z.ZodType<Prisma.HistoryWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid()
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => HistoryWhereInputSchema),
              z.lazy(() => HistoryWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => HistoryWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => HistoryWhereInputSchema),
              z.lazy(() => HistoryWhereInputSchema).array()
            ])
            .optional(),
          status: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          startedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          endedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          durationMs: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          message: z.lazy(() => JsonNullableFilterSchema).optional(),
          cronId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          cron: z
            .union([
              z.lazy(() => CronScalarRelationFilterSchema),
              z.lazy(() => CronWhereInputSchema)
            ])
            .optional()
        })
        .strict()
    );

export const HistoryOrderByWithAggregationInputSchema: z.ZodType<Prisma.HistoryOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      startedAt: z.lazy(() => SortOrderSchema).optional(),
      endedAt: z.lazy(() => SortOrderSchema).optional(),
      durationMs: z.lazy(() => SortOrderSchema).optional(),
      message: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      cronId: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => HistoryCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => HistoryAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => HistoryMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => HistoryMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => HistorySumOrderByAggregateInputSchema).optional()
    })
    .strict();

export const HistoryScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.HistoryScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => HistoryScalarWhereWithAggregatesInputSchema),
          z.lazy(() => HistoryScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => HistoryScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => HistoryScalarWhereWithAggregatesInputSchema),
          z.lazy(() => HistoryScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      status: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      startedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      endedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      durationMs: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      message: z.lazy(() => JsonNullableWithAggregatesFilterSchema).optional(),
      cronId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional()
    })
    .strict();

export const UserWhereInputSchema: z.ZodType<Prisma.UserWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => UserWhereInputSchema),
        z.lazy(() => UserWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => UserWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => UserWhereInputSchema),
        z.lazy(() => UserWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    name: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    email: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    emailVerified: z
      .union([z.lazy(() => BoolFilterSchema), z.boolean()])
      .optional(),
    image: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    isTwoFactorEnabled: z
      .union([z.lazy(() => BoolFilterSchema), z.boolean()])
      .optional(),
    billing_address: z.lazy(() => JsonFilterSchema).optional(),
    payment_method: z.lazy(() => JsonFilterSchema).optional(),
    company: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    address: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    location: z.lazy(() => JsonNullableFilterSchema).optional(),
    postcode: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    city: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    phone: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    activity: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    bounced: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    affiliateRate: z
      .union([z.lazy(() => FloatNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    isAnonymous: z
      .union([z.lazy(() => BoolNullableFilterSchema), z.boolean()])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    role: z
      .union([
        z.lazy(() => EnumUserRoleFilterSchema),
        z.lazy(() => UserRoleSchema)
      ])
      .optional(),
    refererId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    codeNaf: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    accounts: z.lazy(() => AccountListRelationFilterSchema).optional(),
    sessions: z.lazy(() => SessionListRelationFilterSchema).optional(),
    sites: z.lazy(() => SiteListRelationFilterSchema).optional(),
    subscriptions: z
      .lazy(() => SubscriptionListRelationFilterSchema)
      .optional(),
    authenticator: z
      .lazy(() => AuthenticatorListRelationFilterSchema)
      .optional(),
    links: z.lazy(() => LinkListRelationFilterSchema).optional(),
    customer: z
      .union([
        z.lazy(() => CustomerNullableScalarRelationFilterSchema),
        z.lazy(() => CustomerWhereInputSchema)
      ])
      .optional()
      .nullable(),
    twoFactorConfirmation: z
      .union([
        z.lazy(() => TwoFactorConfirmationNullableScalarRelationFilterSchema),
        z.lazy(() => TwoFactorConfirmationWhereInputSchema)
      ])
      .optional()
      .nullable(),
    referer: z
      .union([
        z.lazy(() => UserNullableScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema)
      ])
      .optional()
      .nullable(),
    naf: z
      .union([
        z.lazy(() => NafCodeNullableScalarRelationFilterSchema),
        z.lazy(() => NafCodeWhereInputSchema)
      ])
      .optional()
      .nullable(),
    feedback: z.lazy(() => FeedbackListRelationFilterSchema).optional(),
    likes: z.lazy(() => LikeListRelationFilterSchema).optional(),
    affiliates: z.lazy(() => UserListRelationFilterSchema).optional(),
    events: z.lazy(() => EventListRelationFilterSchema).optional(),
    workflowStates: z
      .lazy(() => WorkflowStateListRelationFilterSchema)
      .optional(),
    executions: z.lazy(() => ExecutionListRelationFilterSchema).optional(),
    jobs: z.lazy(() => QueueListRelationFilterSchema).optional(),
    outbox: z.lazy(() => OutboxListRelationFilterSchema).optional(),
    feed: z.lazy(() => FeedListRelationFilterSchema).optional(),
    comments: z.lazy(() => CommentListRelationFilterSchema).optional(),
    sent: z.lazy(() => MessageListRelationFilterSchema).optional(),
    received: z.lazy(() => MessageListRelationFilterSchema).optional(),
    reservations: z.lazy(() => ReservationListRelationFilterSchema).optional(),
    lists: z.lazy(() => ListListRelationFilterSchema).optional(),
    listsManage: z.lazy(() => ListListRelationFilterSchema).optional(),
    emails: z.lazy(() => EmailListRelationFilterSchema).optional(),
    clicks: z.lazy(() => ClickListRelationFilterSchema).optional(),
    referrals: z.lazy(() => ClickListRelationFilterSchema).optional()
  })
  .strict();

export const UserOrderByWithRelationInputSchema: z.ZodType<Prisma.UserOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      emailVerified: z.lazy(() => SortOrderSchema).optional(),
      image: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      isTwoFactorEnabled: z.lazy(() => SortOrderSchema).optional(),
      billing_address: z.lazy(() => SortOrderSchema).optional(),
      payment_method: z.lazy(() => SortOrderSchema).optional(),
      company: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      address: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      location: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      postcode: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      city: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      phone: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      activity: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      bounced: z.lazy(() => SortOrderSchema).optional(),
      affiliateRate: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      isAnonymous: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      refererId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      codeNaf: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountOrderByRelationAggregateInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionOrderByRelationAggregateInputSchema)
        .optional(),
      sites: z.lazy(() => SiteOrderByRelationAggregateInputSchema).optional(),
      subscriptions: z
        .lazy(() => SubscriptionOrderByRelationAggregateInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorOrderByRelationAggregateInputSchema)
        .optional(),
      links: z.lazy(() => LinkOrderByRelationAggregateInputSchema).optional(),
      customer: z.lazy(() => CustomerOrderByWithRelationInputSchema).optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationOrderByWithRelationInputSchema)
        .optional(),
      referer: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      naf: z.lazy(() => NafCodeOrderByWithRelationInputSchema).optional(),
      feedback: z
        .lazy(() => FeedbackOrderByRelationAggregateInputSchema)
        .optional(),
      likes: z.lazy(() => LikeOrderByRelationAggregateInputSchema).optional(),
      affiliates: z
        .lazy(() => UserOrderByRelationAggregateInputSchema)
        .optional(),
      events: z.lazy(() => EventOrderByRelationAggregateInputSchema).optional(),
      workflowStates: z
        .lazy(() => WorkflowStateOrderByRelationAggregateInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionOrderByRelationAggregateInputSchema)
        .optional(),
      jobs: z.lazy(() => QueueOrderByRelationAggregateInputSchema).optional(),
      outbox: z
        .lazy(() => OutboxOrderByRelationAggregateInputSchema)
        .optional(),
      feed: z.lazy(() => FeedOrderByRelationAggregateInputSchema).optional(),
      comments: z
        .lazy(() => CommentOrderByRelationAggregateInputSchema)
        .optional(),
      sent: z.lazy(() => MessageOrderByRelationAggregateInputSchema).optional(),
      received: z
        .lazy(() => MessageOrderByRelationAggregateInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationOrderByRelationAggregateInputSchema)
        .optional(),
      lists: z.lazy(() => ListOrderByRelationAggregateInputSchema).optional(),
      listsManage: z
        .lazy(() => ListOrderByRelationAggregateInputSchema)
        .optional(),
      emails: z.lazy(() => EmailOrderByRelationAggregateInputSchema).optional(),
      clicks: z.lazy(() => ClickOrderByRelationAggregateInputSchema).optional(),
      referrals: z
        .lazy(() => ClickOrderByRelationAggregateInputSchema)
        .optional()
    })
    .strict();

export const UserWhereUniqueInputSchema: z.ZodType<Prisma.UserWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        email: z.string()
      }),
      z.object({
        id: z.string().cuid()
      }),
      z.object({
        email: z.string()
      })
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          email: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => UserWhereInputSchema),
              z.lazy(() => UserWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => UserWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => UserWhereInputSchema),
              z.lazy(() => UserWhereInputSchema).array()
            ])
            .optional(),
          name: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          emailVerified: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          image: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          isTwoFactorEnabled: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          billing_address: z.lazy(() => JsonFilterSchema).optional(),
          payment_method: z.lazy(() => JsonFilterSchema).optional(),
          company: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          address: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          location: z.lazy(() => JsonNullableFilterSchema).optional(),
          postcode: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          city: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          phone: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          activity: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          bounced: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          affiliateRate: z
            .union([z.lazy(() => FloatNullableFilterSchema), z.number()])
            .optional()
            .nullable(),
          isAnonymous: z
            .union([z.lazy(() => BoolNullableFilterSchema), z.boolean()])
            .optional()
            .nullable(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          role: z
            .union([
              z.lazy(() => EnumUserRoleFilterSchema),
              z.lazy(() => UserRoleSchema)
            ])
            .optional(),
          refererId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          codeNaf: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          accounts: z.lazy(() => AccountListRelationFilterSchema).optional(),
          sessions: z.lazy(() => SessionListRelationFilterSchema).optional(),
          sites: z.lazy(() => SiteListRelationFilterSchema).optional(),
          subscriptions: z
            .lazy(() => SubscriptionListRelationFilterSchema)
            .optional(),
          authenticator: z
            .lazy(() => AuthenticatorListRelationFilterSchema)
            .optional(),
          links: z.lazy(() => LinkListRelationFilterSchema).optional(),
          customer: z
            .union([
              z.lazy(() => CustomerNullableScalarRelationFilterSchema),
              z.lazy(() => CustomerWhereInputSchema)
            ])
            .optional()
            .nullable(),
          twoFactorConfirmation: z
            .union([
              z.lazy(
                () => TwoFactorConfirmationNullableScalarRelationFilterSchema
              ),
              z.lazy(() => TwoFactorConfirmationWhereInputSchema)
            ])
            .optional()
            .nullable(),
          referer: z
            .union([
              z.lazy(() => UserNullableScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional()
            .nullable(),
          naf: z
            .union([
              z.lazy(() => NafCodeNullableScalarRelationFilterSchema),
              z.lazy(() => NafCodeWhereInputSchema)
            ])
            .optional()
            .nullable(),
          feedback: z.lazy(() => FeedbackListRelationFilterSchema).optional(),
          likes: z.lazy(() => LikeListRelationFilterSchema).optional(),
          affiliates: z.lazy(() => UserListRelationFilterSchema).optional(),
          events: z.lazy(() => EventListRelationFilterSchema).optional(),
          workflowStates: z
            .lazy(() => WorkflowStateListRelationFilterSchema)
            .optional(),
          executions: z
            .lazy(() => ExecutionListRelationFilterSchema)
            .optional(),
          jobs: z.lazy(() => QueueListRelationFilterSchema).optional(),
          outbox: z.lazy(() => OutboxListRelationFilterSchema).optional(),
          feed: z.lazy(() => FeedListRelationFilterSchema).optional(),
          comments: z.lazy(() => CommentListRelationFilterSchema).optional(),
          sent: z.lazy(() => MessageListRelationFilterSchema).optional(),
          received: z.lazy(() => MessageListRelationFilterSchema).optional(),
          reservations: z
            .lazy(() => ReservationListRelationFilterSchema)
            .optional(),
          lists: z.lazy(() => ListListRelationFilterSchema).optional(),
          listsManage: z.lazy(() => ListListRelationFilterSchema).optional(),
          emails: z.lazy(() => EmailListRelationFilterSchema).optional(),
          clicks: z.lazy(() => ClickListRelationFilterSchema).optional(),
          referrals: z.lazy(() => ClickListRelationFilterSchema).optional()
        })
        .strict()
    );

export const UserOrderByWithAggregationInputSchema: z.ZodType<Prisma.UserOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      emailVerified: z.lazy(() => SortOrderSchema).optional(),
      image: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      isTwoFactorEnabled: z.lazy(() => SortOrderSchema).optional(),
      billing_address: z.lazy(() => SortOrderSchema).optional(),
      payment_method: z.lazy(() => SortOrderSchema).optional(),
      company: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      address: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      location: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      postcode: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      city: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      phone: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      activity: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      bounced: z.lazy(() => SortOrderSchema).optional(),
      affiliateRate: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      isAnonymous: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      refererId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      codeNaf: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      _count: z.lazy(() => UserCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => UserAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => UserMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => UserMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => UserSumOrderByAggregateInputSchema).optional()
    })
    .strict();

export const UserScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.UserScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => UserScalarWhereWithAggregatesInputSchema),
          z.lazy(() => UserScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => UserScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => UserScalarWhereWithAggregatesInputSchema),
          z.lazy(() => UserScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      name: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      email: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      emailVerified: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      image: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      billing_address: z.lazy(() => JsonWithAggregatesFilterSchema).optional(),
      payment_method: z.lazy(() => JsonWithAggregatesFilterSchema).optional(),
      company: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      location: z.lazy(() => JsonNullableWithAggregatesFilterSchema).optional(),
      postcode: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      affiliateRate: z
        .union([
          z.lazy(() => FloatNullableWithAggregatesFilterSchema),
          z.number()
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.lazy(() => BoolNullableWithAggregatesFilterSchema),
          z.boolean()
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => EnumUserRoleWithAggregatesFilterSchema),
          z.lazy(() => UserRoleSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable()
    })
    .strict();

export const MessageWhereInputSchema: z.ZodType<Prisma.MessageWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => MessageWhereInputSchema),
        z.lazy(() => MessageWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => MessageWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => MessageWhereInputSchema),
        z.lazy(() => MessageWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    content: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    senderEmail: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    receiveEmail: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    sender: z
      .union([
        z.lazy(() => UserScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema)
      ])
      .optional(),
    receiver: z
      .union([
        z.lazy(() => UserScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema)
      ])
      .optional()
  })
  .strict();

export const MessageOrderByWithRelationInputSchema: z.ZodType<Prisma.MessageOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      senderEmail: z.lazy(() => SortOrderSchema).optional(),
      receiveEmail: z.lazy(() => SortOrderSchema).optional(),
      sender: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      receiver: z.lazy(() => UserOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const MessageWhereUniqueInputSchema: z.ZodType<Prisma.MessageWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid()
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => MessageWhereInputSchema),
              z.lazy(() => MessageWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => MessageWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => MessageWhereInputSchema),
              z.lazy(() => MessageWhereInputSchema).array()
            ])
            .optional(),
          content: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          senderEmail: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          receiveEmail: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          sender: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional(),
          receiver: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional()
        })
        .strict()
    );

export const MessageOrderByWithAggregationInputSchema: z.ZodType<Prisma.MessageOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      senderEmail: z.lazy(() => SortOrderSchema).optional(),
      receiveEmail: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => MessageCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => MessageMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => MessageMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const MessageScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.MessageScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => MessageScalarWhereWithAggregatesInputSchema),
          z.lazy(() => MessageScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => MessageScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => MessageScalarWhereWithAggregatesInputSchema),
          z.lazy(() => MessageScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      content: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      senderEmail: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      receiveEmail: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const FeedbackWhereInputSchema: z.ZodType<Prisma.FeedbackWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => FeedbackWhereInputSchema),
        z.lazy(() => FeedbackWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => FeedbackWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => FeedbackWhereInputSchema),
        z.lazy(() => FeedbackWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    message: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    userId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    user: z
      .union([
        z.lazy(() => UserNullableScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema)
      ])
      .optional()
      .nullable()
  })
  .strict();

export const FeedbackOrderByWithRelationInputSchema: z.ZodType<Prisma.FeedbackOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      message: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const FeedbackWhereUniqueInputSchema: z.ZodType<Prisma.FeedbackWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid()
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => FeedbackWhereInputSchema),
              z.lazy(() => FeedbackWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => FeedbackWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => FeedbackWhereInputSchema),
              z.lazy(() => FeedbackWhereInputSchema).array()
            ])
            .optional(),
          message: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          userId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          user: z
            .union([
              z.lazy(() => UserNullableScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional()
            .nullable()
        })
        .strict()
    );

export const FeedbackOrderByWithAggregationInputSchema: z.ZodType<Prisma.FeedbackOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      message: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      _count: z.lazy(() => FeedbackCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => FeedbackMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => FeedbackMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const FeedbackScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.FeedbackScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => FeedbackScalarWhereWithAggregatesInputSchema),
          z.lazy(() => FeedbackScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => FeedbackScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => FeedbackScalarWhereWithAggregatesInputSchema),
          z.lazy(() => FeedbackScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      message: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      userId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable()
    })
    .strict();

export const QueueWhereInputSchema: z.ZodType<Prisma.QueueWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => QueueWhereInputSchema),
        z.lazy(() => QueueWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => QueueWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => QueueWhereInputSchema),
        z.lazy(() => QueueWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    job: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    payload: z.lazy(() => JsonFilterSchema).optional(),
    status: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    attempts: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    lastError: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    runAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    priority: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    processingStartedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    correlationId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    userId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    user: z
      .union([
        z.lazy(() => UserNullableScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema)
      ])
      .optional()
      .nullable()
  })
  .strict();

export const QueueOrderByWithRelationInputSchema: z.ZodType<Prisma.QueueOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      job: z.lazy(() => SortOrderSchema).optional(),
      payload: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      attempts: z.lazy(() => SortOrderSchema).optional(),
      lastError: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      runAt: z.lazy(() => SortOrderSchema).optional(),
      priority: z.lazy(() => SortOrderSchema).optional(),
      processingStartedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      correlationId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const QueueWhereUniqueInputSchema: z.ZodType<Prisma.QueueWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid()
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => QueueWhereInputSchema),
              z.lazy(() => QueueWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => QueueWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => QueueWhereInputSchema),
              z.lazy(() => QueueWhereInputSchema).array()
            ])
            .optional(),
          job: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          payload: z.lazy(() => JsonFilterSchema).optional(),
          status: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          attempts: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          lastError: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          runAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          priority: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          processingStartedAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date()
            ])
            .optional()
            .nullable(),
          correlationId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          userId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          user: z
            .union([
              z.lazy(() => UserNullableScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional()
            .nullable()
        })
        .strict()
    );

export const QueueOrderByWithAggregationInputSchema: z.ZodType<Prisma.QueueOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      job: z.lazy(() => SortOrderSchema).optional(),
      payload: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      attempts: z.lazy(() => SortOrderSchema).optional(),
      lastError: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      runAt: z.lazy(() => SortOrderSchema).optional(),
      priority: z.lazy(() => SortOrderSchema).optional(),
      processingStartedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      correlationId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      _count: z.lazy(() => QueueCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => QueueAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => QueueMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => QueueMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => QueueSumOrderByAggregateInputSchema).optional()
    })
    .strict();

export const QueueScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.QueueScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => QueueScalarWhereWithAggregatesInputSchema),
          z.lazy(() => QueueScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => QueueScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => QueueScalarWhereWithAggregatesInputSchema),
          z.lazy(() => QueueScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      job: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      payload: z.lazy(() => JsonWithAggregatesFilterSchema).optional(),
      status: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      attempts: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      lastError: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      runAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      priority: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      processingStartedAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional()
        .nullable(),
      correlationId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      userId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ActionWhereInputSchema: z.ZodType<Prisma.ActionWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => ActionWhereInputSchema),
        z.lazy(() => ActionWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => ActionWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => ActionWhereInputSchema),
        z.lazy(() => ActionWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    code: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    description: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    type: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    config: z.lazy(() => JsonFilterSchema).optional(),
    isPublished: z
      .union([z.lazy(() => BoolFilterSchema), z.boolean()])
      .optional(),
    version: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    rules: z.lazy(() => RuleListRelationFilterSchema).optional(),
    executions: z.lazy(() => ExecutionListRelationFilterSchema).optional()
  })
  .strict();

export const ActionOrderByWithRelationInputSchema: z.ZodType<Prisma.ActionOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      code: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      config: z.lazy(() => SortOrderSchema).optional(),
      isPublished: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      rules: z.lazy(() => RuleOrderByRelationAggregateInputSchema).optional(),
      executions: z
        .lazy(() => ExecutionOrderByRelationAggregateInputSchema)
        .optional()
    })
    .strict();

export const ActionWhereUniqueInputSchema: z.ZodType<Prisma.ActionWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        code: z.string()
      }),
      z.object({
        id: z.string().cuid()
      }),
      z.object({
        code: z.string()
      })
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          code: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => ActionWhereInputSchema),
              z.lazy(() => ActionWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => ActionWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => ActionWhereInputSchema),
              z.lazy(() => ActionWhereInputSchema).array()
            ])
            .optional(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          type: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          config: z.lazy(() => JsonFilterSchema).optional(),
          isPublished: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          version: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          rules: z.lazy(() => RuleListRelationFilterSchema).optional(),
          executions: z.lazy(() => ExecutionListRelationFilterSchema).optional()
        })
        .strict()
    );

export const ActionOrderByWithAggregationInputSchema: z.ZodType<Prisma.ActionOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      code: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      config: z.lazy(() => SortOrderSchema).optional(),
      isPublished: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => ActionCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => ActionAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => ActionMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => ActionMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => ActionSumOrderByAggregateInputSchema).optional()
    })
    .strict();

export const ActionScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.ActionScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ActionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ActionScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => ActionScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ActionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ActionScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      code: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      description: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      type: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      config: z.lazy(() => JsonWithAggregatesFilterSchema).optional(),
      isPublished: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      version: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional()
    })
    .strict();

export const WorkflowWhereInputSchema: z.ZodType<Prisma.WorkflowWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => WorkflowWhereInputSchema),
        z.lazy(() => WorkflowWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => WorkflowWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => WorkflowWhereInputSchema),
        z.lazy(() => WorkflowWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    description: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    isDefault: z
      .union([z.lazy(() => BoolFilterSchema), z.boolean()])
      .optional(),
    isActive: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    rules: z.lazy(() => RuleListRelationFilterSchema).optional(),
    states: z.lazy(() => WorkflowStateListRelationFilterSchema).optional()
  })
  .strict();

export const WorkflowOrderByWithRelationInputSchema: z.ZodType<Prisma.WorkflowOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      isDefault: z.lazy(() => SortOrderSchema).optional(),
      isActive: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      rules: z.lazy(() => RuleOrderByRelationAggregateInputSchema).optional(),
      states: z
        .lazy(() => WorkflowStateOrderByRelationAggregateInputSchema)
        .optional()
    })
    .strict();

export const WorkflowWhereUniqueInputSchema: z.ZodType<Prisma.WorkflowWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        name: z.string()
      }),
      z.object({
        id: z.string().cuid()
      }),
      z.object({
        name: z.string()
      })
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          name: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => WorkflowWhereInputSchema),
              z.lazy(() => WorkflowWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => WorkflowWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => WorkflowWhereInputSchema),
              z.lazy(() => WorkflowWhereInputSchema).array()
            ])
            .optional(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          isDefault: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          isActive: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          rules: z.lazy(() => RuleListRelationFilterSchema).optional(),
          states: z.lazy(() => WorkflowStateListRelationFilterSchema).optional()
        })
        .strict()
    );

export const WorkflowOrderByWithAggregationInputSchema: z.ZodType<Prisma.WorkflowOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      isDefault: z.lazy(() => SortOrderSchema).optional(),
      isActive: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => WorkflowCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => WorkflowMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => WorkflowMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const WorkflowScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.WorkflowScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => WorkflowScalarWhereWithAggregatesInputSchema),
          z.lazy(() => WorkflowScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => WorkflowScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => WorkflowScalarWhereWithAggregatesInputSchema),
          z.lazy(() => WorkflowScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      name: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      description: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      isDefault: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      isActive: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional()
    })
    .strict();

export const TriggerWhereInputSchema: z.ZodType<Prisma.TriggerWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => TriggerWhereInputSchema),
        z.lazy(() => TriggerWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => TriggerWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => TriggerWhereInputSchema),
        z.lazy(() => TriggerWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    code: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    description: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    rules: z.lazy(() => RuleListRelationFilterSchema).optional()
  })
  .strict();

export const TriggerOrderByWithRelationInputSchema: z.ZodType<Prisma.TriggerOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      code: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      rules: z.lazy(() => RuleOrderByRelationAggregateInputSchema).optional()
    })
    .strict();

export const TriggerWhereUniqueInputSchema: z.ZodType<Prisma.TriggerWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        code: z.string()
      }),
      z.object({
        id: z.string().cuid()
      }),
      z.object({
        code: z.string()
      })
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          code: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => TriggerWhereInputSchema),
              z.lazy(() => TriggerWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => TriggerWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => TriggerWhereInputSchema),
              z.lazy(() => TriggerWhereInputSchema).array()
            ])
            .optional(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          rules: z.lazy(() => RuleListRelationFilterSchema).optional()
        })
        .strict()
    );

export const TriggerOrderByWithAggregationInputSchema: z.ZodType<Prisma.TriggerOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      code: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      _count: z.lazy(() => TriggerCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => TriggerMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => TriggerMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const TriggerScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.TriggerScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => TriggerScalarWhereWithAggregatesInputSchema),
          z.lazy(() => TriggerScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => TriggerScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => TriggerScalarWhereWithAggregatesInputSchema),
          z.lazy(() => TriggerScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      code: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      description: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable()
    })
    .strict();

export const RuleWhereInputSchema: z.ZodType<Prisma.RuleWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => RuleWhereInputSchema),
        z.lazy(() => RuleWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => RuleWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => RuleWhereInputSchema),
        z.lazy(() => RuleWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    workflowId: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    actionId: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    triggerId: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    delayMinutes: z
      .union([z.lazy(() => IntFilterSchema), z.number()])
      .optional(),
    order: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    isActive: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    version: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    ruleConditions: z
      .lazy(() => RuleConditionListRelationFilterSchema)
      .optional(),
    workflow: z
      .union([
        z.lazy(() => WorkflowScalarRelationFilterSchema),
        z.lazy(() => WorkflowWhereInputSchema)
      ])
      .optional(),
    action: z
      .union([
        z.lazy(() => ActionScalarRelationFilterSchema),
        z.lazy(() => ActionWhereInputSchema)
      ])
      .optional(),
    trigger: z
      .union([
        z.lazy(() => TriggerScalarRelationFilterSchema),
        z.lazy(() => TriggerWhereInputSchema)
      ])
      .optional(),
    executions: z.lazy(() => ExecutionListRelationFilterSchema).optional()
  })
  .strict();

export const RuleOrderByWithRelationInputSchema: z.ZodType<Prisma.RuleOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      workflowId: z.lazy(() => SortOrderSchema).optional(),
      actionId: z.lazy(() => SortOrderSchema).optional(),
      triggerId: z.lazy(() => SortOrderSchema).optional(),
      delayMinutes: z.lazy(() => SortOrderSchema).optional(),
      order: z.lazy(() => SortOrderSchema).optional(),
      isActive: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
      ruleConditions: z
        .lazy(() => RuleConditionOrderByRelationAggregateInputSchema)
        .optional(),
      workflow: z.lazy(() => WorkflowOrderByWithRelationInputSchema).optional(),
      action: z.lazy(() => ActionOrderByWithRelationInputSchema).optional(),
      trigger: z.lazy(() => TriggerOrderByWithRelationInputSchema).optional(),
      executions: z
        .lazy(() => ExecutionOrderByRelationAggregateInputSchema)
        .optional()
    })
    .strict();

export const RuleWhereUniqueInputSchema: z.ZodType<Prisma.RuleWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid()
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => RuleWhereInputSchema),
              z.lazy(() => RuleWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => RuleWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => RuleWhereInputSchema),
              z.lazy(() => RuleWhereInputSchema).array()
            ])
            .optional(),
          workflowId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          actionId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          triggerId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          delayMinutes: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          order: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          isActive: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          version: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          ruleConditions: z
            .lazy(() => RuleConditionListRelationFilterSchema)
            .optional(),
          workflow: z
            .union([
              z.lazy(() => WorkflowScalarRelationFilterSchema),
              z.lazy(() => WorkflowWhereInputSchema)
            ])
            .optional(),
          action: z
            .union([
              z.lazy(() => ActionScalarRelationFilterSchema),
              z.lazy(() => ActionWhereInputSchema)
            ])
            .optional(),
          trigger: z
            .union([
              z.lazy(() => TriggerScalarRelationFilterSchema),
              z.lazy(() => TriggerWhereInputSchema)
            ])
            .optional(),
          executions: z.lazy(() => ExecutionListRelationFilterSchema).optional()
        })
        .strict()
    );

export const RuleOrderByWithAggregationInputSchema: z.ZodType<Prisma.RuleOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      workflowId: z.lazy(() => SortOrderSchema).optional(),
      actionId: z.lazy(() => SortOrderSchema).optional(),
      triggerId: z.lazy(() => SortOrderSchema).optional(),
      delayMinutes: z.lazy(() => SortOrderSchema).optional(),
      order: z.lazy(() => SortOrderSchema).optional(),
      isActive: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => RuleCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => RuleAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => RuleMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => RuleMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => RuleSumOrderByAggregateInputSchema).optional()
    })
    .strict();

export const RuleScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.RuleScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => RuleScalarWhereWithAggregatesInputSchema),
          z.lazy(() => RuleScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => RuleScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => RuleScalarWhereWithAggregatesInputSchema),
          z.lazy(() => RuleScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      workflowId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      actionId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      triggerId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      delayMinutes: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      order: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      isActive: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      version: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional()
    })
    .strict();

export const ConditionWhereInputSchema: z.ZodType<Prisma.ConditionWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ConditionWhereInputSchema),
          z.lazy(() => ConditionWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => ConditionWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ConditionWhereInputSchema),
          z.lazy(() => ConditionWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => EnumConditionTypeFilterSchema),
          z.lazy(() => ConditionTypeSchema)
        ])
        .optional(),
      parameters: z.lazy(() => JsonFilterSchema).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      rules: z.lazy(() => RuleConditionListRelationFilterSchema).optional()
    })
    .strict();

export const ConditionOrderByWithRelationInputSchema: z.ZodType<Prisma.ConditionOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      parameters: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      rules: z
        .lazy(() => RuleConditionOrderByRelationAggregateInputSchema)
        .optional()
    })
    .strict();

export const ConditionWhereUniqueInputSchema: z.ZodType<Prisma.ConditionWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        name: z.string()
      }),
      z.object({
        id: z.string().cuid()
      }),
      z.object({
        name: z.string()
      })
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          name: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => ConditionWhereInputSchema),
              z.lazy(() => ConditionWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => ConditionWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => ConditionWhereInputSchema),
              z.lazy(() => ConditionWhereInputSchema).array()
            ])
            .optional(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          type: z
            .union([
              z.lazy(() => EnumConditionTypeFilterSchema),
              z.lazy(() => ConditionTypeSchema)
            ])
            .optional(),
          parameters: z.lazy(() => JsonFilterSchema).optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          rules: z.lazy(() => RuleConditionListRelationFilterSchema).optional()
        })
        .strict()
    );

export const ConditionOrderByWithAggregationInputSchema: z.ZodType<Prisma.ConditionOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      parameters: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => ConditionCountOrderByAggregateInputSchema)
        .optional(),
      _max: z.lazy(() => ConditionMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => ConditionMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const ConditionScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.ConditionScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ConditionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ConditionScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => ConditionScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ConditionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ConditionScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      name: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      description: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => EnumConditionTypeWithAggregatesFilterSchema),
          z.lazy(() => ConditionTypeSchema)
        ])
        .optional(),
      parameters: z.lazy(() => JsonWithAggregatesFilterSchema).optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional()
    })
    .strict();

export const RuleConditionWhereInputSchema: z.ZodType<Prisma.RuleConditionWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => RuleConditionWhereInputSchema),
          z.lazy(() => RuleConditionWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => RuleConditionWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => RuleConditionWhereInputSchema),
          z.lazy(() => RuleConditionWhereInputSchema).array()
        ])
        .optional(),
      ruleId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      conditionId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      group: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      logic: z
        .union([
          z.lazy(() => EnumOperatorFilterSchema),
          z.lazy(() => OperatorSchema)
        ])
        .optional(),
      rule: z
        .union([
          z.lazy(() => RuleScalarRelationFilterSchema),
          z.lazy(() => RuleWhereInputSchema)
        ])
        .optional(),
      condition: z
        .union([
          z.lazy(() => ConditionScalarRelationFilterSchema),
          z.lazy(() => ConditionWhereInputSchema)
        ])
        .optional()
    })
    .strict();

export const RuleConditionOrderByWithRelationInputSchema: z.ZodType<Prisma.RuleConditionOrderByWithRelationInput> =
  z
    .object({
      ruleId: z.lazy(() => SortOrderSchema).optional(),
      conditionId: z.lazy(() => SortOrderSchema).optional(),
      group: z.lazy(() => SortOrderSchema).optional(),
      logic: z.lazy(() => SortOrderSchema).optional(),
      rule: z.lazy(() => RuleOrderByWithRelationInputSchema).optional(),
      condition: z
        .lazy(() => ConditionOrderByWithRelationInputSchema)
        .optional()
    })
    .strict();

export const RuleConditionWhereUniqueInputSchema: z.ZodType<Prisma.RuleConditionWhereUniqueInput> =
  z
    .object({
      ruleId_conditionId: z.lazy(
        () => RuleConditionRuleIdConditionIdCompoundUniqueInputSchema
      )
    })
    .and(
      z
        .object({
          ruleId_conditionId: z
            .lazy(() => RuleConditionRuleIdConditionIdCompoundUniqueInputSchema)
            .optional(),
          AND: z
            .union([
              z.lazy(() => RuleConditionWhereInputSchema),
              z.lazy(() => RuleConditionWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => RuleConditionWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => RuleConditionWhereInputSchema),
              z.lazy(() => RuleConditionWhereInputSchema).array()
            ])
            .optional(),
          ruleId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          conditionId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          group: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          logic: z
            .union([
              z.lazy(() => EnumOperatorFilterSchema),
              z.lazy(() => OperatorSchema)
            ])
            .optional(),
          rule: z
            .union([
              z.lazy(() => RuleScalarRelationFilterSchema),
              z.lazy(() => RuleWhereInputSchema)
            ])
            .optional(),
          condition: z
            .union([
              z.lazy(() => ConditionScalarRelationFilterSchema),
              z.lazy(() => ConditionWhereInputSchema)
            ])
            .optional()
        })
        .strict()
    );

export const RuleConditionOrderByWithAggregationInputSchema: z.ZodType<Prisma.RuleConditionOrderByWithAggregationInput> =
  z
    .object({
      ruleId: z.lazy(() => SortOrderSchema).optional(),
      conditionId: z.lazy(() => SortOrderSchema).optional(),
      group: z.lazy(() => SortOrderSchema).optional(),
      logic: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => RuleConditionCountOrderByAggregateInputSchema)
        .optional(),
      _avg: z
        .lazy(() => RuleConditionAvgOrderByAggregateInputSchema)
        .optional(),
      _max: z
        .lazy(() => RuleConditionMaxOrderByAggregateInputSchema)
        .optional(),
      _min: z
        .lazy(() => RuleConditionMinOrderByAggregateInputSchema)
        .optional(),
      _sum: z.lazy(() => RuleConditionSumOrderByAggregateInputSchema).optional()
    })
    .strict();

export const RuleConditionScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.RuleConditionScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => RuleConditionScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => RuleConditionScalarWhereWithAggregatesInputSchema)
            .array()
        ])
        .optional(),
      OR: z
        .lazy(() => RuleConditionScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => RuleConditionScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => RuleConditionScalarWhereWithAggregatesInputSchema)
            .array()
        ])
        .optional(),
      ruleId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      conditionId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      group: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      logic: z
        .union([
          z.lazy(() => EnumOperatorWithAggregatesFilterSchema),
          z.lazy(() => OperatorSchema)
        ])
        .optional()
    })
    .strict();

export const EventWhereInputSchema: z.ZodType<Prisma.EventWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => EventWhereInputSchema),
        z.lazy(() => EventWhereInputSchema).array()
      ])
      .optional(),
    OR: z
      .lazy(() => EventWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => EventWhereInputSchema),
        z.lazy(() => EventWhereInputSchema).array()
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    eventType: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    payload: z.lazy(() => JsonNullableFilterSchema).optional(),
    correlationId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    status: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    attempts: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    lastError: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    user: z
      .union([
        z.lazy(() => UserScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema)
      ])
      .optional()
  })
  .strict();

export const EventOrderByWithRelationInputSchema: z.ZodType<Prisma.EventOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      eventType: z.lazy(() => SortOrderSchema).optional(),
      payload: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      correlationId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      attempts: z.lazy(() => SortOrderSchema).optional(),
      lastError: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const EventWhereUniqueInputSchema: z.ZodType<Prisma.EventWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid()
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => EventWhereInputSchema),
              z.lazy(() => EventWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => EventWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => EventWhereInputSchema),
              z.lazy(() => EventWhereInputSchema).array()
            ])
            .optional(),
          userId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          eventType: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          payload: z.lazy(() => JsonNullableFilterSchema).optional(),
          correlationId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          status: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          attempts: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          lastError: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          user: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional()
        })
        .strict()
    );

export const EventOrderByWithAggregationInputSchema: z.ZodType<Prisma.EventOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      eventType: z.lazy(() => SortOrderSchema).optional(),
      payload: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      correlationId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      attempts: z.lazy(() => SortOrderSchema).optional(),
      lastError: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      _count: z.lazy(() => EventCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => EventAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => EventMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => EventMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => EventSumOrderByAggregateInputSchema).optional()
    })
    .strict();

export const EventScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.EventScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => EventScalarWhereWithAggregatesInputSchema),
          z.lazy(() => EventScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => EventScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => EventScalarWhereWithAggregatesInputSchema),
          z.lazy(() => EventScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      userId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      eventType: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      payload: z.lazy(() => JsonNullableWithAggregatesFilterSchema).optional(),
      correlationId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      status: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      attempts: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      lastError: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable()
    })
    .strict();

export const WorkflowStateWhereInputSchema: z.ZodType<Prisma.WorkflowStateWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => WorkflowStateWhereInputSchema),
          z.lazy(() => WorkflowStateWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => WorkflowStateWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => WorkflowStateWhereInputSchema),
          z.lazy(() => WorkflowStateWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      userId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      workflowId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumWorkflowStateStatusFilterSchema),
          z.lazy(() => WorkflowStateStatusSchema)
        ])
        .optional(),
      startedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      user: z
        .union([
          z.lazy(() => UserScalarRelationFilterSchema),
          z.lazy(() => UserWhereInputSchema)
        ])
        .optional(),
      workflow: z
        .union([
          z.lazy(() => WorkflowScalarRelationFilterSchema),
          z.lazy(() => WorkflowWhereInputSchema)
        ])
        .optional()
    })
    .strict();

export const WorkflowStateOrderByWithRelationInputSchema: z.ZodType<Prisma.WorkflowStateOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      workflowId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      startedAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      workflow: z.lazy(() => WorkflowOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const WorkflowStateWhereUniqueInputSchema: z.ZodType<Prisma.WorkflowStateWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        userId_workflowId: z.lazy(
          () => WorkflowStateUserIdWorkflowIdCompoundUniqueInputSchema
        )
      }),
      z.object({
        id: z.string().cuid()
      }),
      z.object({
        userId_workflowId: z.lazy(
          () => WorkflowStateUserIdWorkflowIdCompoundUniqueInputSchema
        )
      })
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          userId_workflowId: z
            .lazy(() => WorkflowStateUserIdWorkflowIdCompoundUniqueInputSchema)
            .optional(),
          AND: z
            .union([
              z.lazy(() => WorkflowStateWhereInputSchema),
              z.lazy(() => WorkflowStateWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => WorkflowStateWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => WorkflowStateWhereInputSchema),
              z.lazy(() => WorkflowStateWhereInputSchema).array()
            ])
            .optional(),
          userId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          workflowId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          status: z
            .union([
              z.lazy(() => EnumWorkflowStateStatusFilterSchema),
              z.lazy(() => WorkflowStateStatusSchema)
            ])
            .optional(),
          startedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          user: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional(),
          workflow: z
            .union([
              z.lazy(() => WorkflowScalarRelationFilterSchema),
              z.lazy(() => WorkflowWhereInputSchema)
            ])
            .optional()
        })
        .strict()
    );

export const WorkflowStateOrderByWithAggregationInputSchema: z.ZodType<Prisma.WorkflowStateOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      workflowId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      startedAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => WorkflowStateCountOrderByAggregateInputSchema)
        .optional(),
      _max: z
        .lazy(() => WorkflowStateMaxOrderByAggregateInputSchema)
        .optional(),
      _min: z.lazy(() => WorkflowStateMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const WorkflowStateScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.WorkflowStateScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => WorkflowStateScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => WorkflowStateScalarWhereWithAggregatesInputSchema)
            .array()
        ])
        .optional(),
      OR: z
        .lazy(() => WorkflowStateScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => WorkflowStateScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => WorkflowStateScalarWhereWithAggregatesInputSchema)
            .array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      userId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      workflowId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumWorkflowStateStatusWithAggregatesFilterSchema),
          z.lazy(() => WorkflowStateStatusSchema)
        ])
        .optional(),
      startedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional()
    })
    .strict();

export const ExecutionWhereInputSchema: z.ZodType<Prisma.ExecutionWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ExecutionWhereInputSchema),
          z.lazy(() => ExecutionWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => ExecutionWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ExecutionWhereInputSchema),
          z.lazy(() => ExecutionWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      userId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      actionId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      ruleId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      executedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => EnumExecutionStatusFilterSchema),
          z.lazy(() => ExecutionStatusSchema)
        ])
        .optional(),
      errorMessage: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      resultPayload: z.lazy(() => JsonNullableFilterSchema).optional(),
      correlationId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      user: z
        .union([
          z.lazy(() => UserScalarRelationFilterSchema),
          z.lazy(() => UserWhereInputSchema)
        ])
        .optional(),
      action: z
        .union([
          z.lazy(() => ActionScalarRelationFilterSchema),
          z.lazy(() => ActionWhereInputSchema)
        ])
        .optional(),
      rule: z
        .union([
          z.lazy(() => RuleNullableScalarRelationFilterSchema),
          z.lazy(() => RuleWhereInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ExecutionOrderByWithRelationInputSchema: z.ZodType<Prisma.ExecutionOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      actionId: z.lazy(() => SortOrderSchema).optional(),
      ruleId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      executedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      errorMessage: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      resultPayload: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      correlationId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      action: z.lazy(() => ActionOrderByWithRelationInputSchema).optional(),
      rule: z.lazy(() => RuleOrderByWithRelationInputSchema).optional()
    })
    .strict();

export const ExecutionWhereUniqueInputSchema: z.ZodType<Prisma.ExecutionWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid()
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => ExecutionWhereInputSchema),
              z.lazy(() => ExecutionWhereInputSchema).array()
            ])
            .optional(),
          OR: z
            .lazy(() => ExecutionWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => ExecutionWhereInputSchema),
              z.lazy(() => ExecutionWhereInputSchema).array()
            ])
            .optional(),
          userId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          actionId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          ruleId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          executedAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date()
            ])
            .optional()
            .nullable(),
          status: z
            .union([
              z.lazy(() => EnumExecutionStatusFilterSchema),
              z.lazy(() => ExecutionStatusSchema)
            ])
            .optional(),
          errorMessage: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          resultPayload: z.lazy(() => JsonNullableFilterSchema).optional(),
          correlationId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          user: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema)
            ])
            .optional(),
          action: z
            .union([
              z.lazy(() => ActionScalarRelationFilterSchema),
              z.lazy(() => ActionWhereInputSchema)
            ])
            .optional(),
          rule: z
            .union([
              z.lazy(() => RuleNullableScalarRelationFilterSchema),
              z.lazy(() => RuleWhereInputSchema)
            ])
            .optional()
            .nullable()
        })
        .strict()
    );

export const ExecutionOrderByWithAggregationInputSchema: z.ZodType<Prisma.ExecutionOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      actionId: z.lazy(() => SortOrderSchema).optional(),
      ruleId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      executedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      errorMessage: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      resultPayload: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      correlationId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema)
        ])
        .optional(),
      _count: z
        .lazy(() => ExecutionCountOrderByAggregateInputSchema)
        .optional(),
      _max: z.lazy(() => ExecutionMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => ExecutionMinOrderByAggregateInputSchema).optional()
    })
    .strict();

export const ExecutionScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.ExecutionScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ExecutionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ExecutionScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => ExecutionScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ExecutionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ExecutionScalarWhereWithAggregatesInputSchema).array()
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      userId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      actionId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      ruleId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      executedAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date()
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => EnumExecutionStatusWithAggregatesFilterSchema),
          z.lazy(() => ExecutionStatusSchema)
        ])
        .optional(),
      errorMessage: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable(),
      resultPayload: z
        .lazy(() => JsonNullableWithAggregatesFilterSchema)
        .optional(),
      correlationId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string()
        ])
        .optional()
        .nullable()
    })
    .strict();

export const TwoFactorConfirmationCreateInputSchema: z.ZodType<Prisma.TwoFactorConfirmationCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      user: z.lazy(
        () => UserCreateNestedOneWithoutTwoFactorConfirmationInputSchema
      )
    })
    .strict();

export const TwoFactorConfirmationUncheckedCreateInputSchema: z.ZodType<Prisma.TwoFactorConfirmationUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      userId: z.string()
    })
    .strict();

export const TwoFactorConfirmationUpdateInputSchema: z.ZodType<Prisma.TwoFactorConfirmationUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      user: z
        .lazy(
          () =>
            UserUpdateOneRequiredWithoutTwoFactorConfirmationNestedInputSchema
        )
        .optional()
    })
    .strict();

export const TwoFactorConfirmationUncheckedUpdateInputSchema: z.ZodType<Prisma.TwoFactorConfirmationUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const TwoFactorConfirmationCreateManyInputSchema: z.ZodType<Prisma.TwoFactorConfirmationCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      userId: z.string()
    })
    .strict();

export const TwoFactorConfirmationUpdateManyMutationInputSchema: z.ZodType<Prisma.TwoFactorConfirmationUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const TwoFactorConfirmationUncheckedUpdateManyInputSchema: z.ZodType<Prisma.TwoFactorConfirmationUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const AccountCreateInputSchema: z.ZodType<Prisma.AccountCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    providerId: z.string().optional().nullable(),
    providerAccountId: z.string(),
    password: z.string().optional().nullable(),
    refresh_token: z.string().optional().nullable(),
    access_token: z.string().optional().nullable(),
    expires_at: z.number().int().optional().nullable(),
    scope: z.string().optional().nullable(),
    id_token: z.string().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    user: z.lazy(() => UserCreateNestedOneWithoutAccountsInputSchema)
  })
  .strict();

export const AccountUncheckedCreateInputSchema: z.ZodType<Prisma.AccountUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      providerId: z.string().optional().nullable(),
      providerAccountId: z.string(),
      password: z.string().optional().nullable(),
      refresh_token: z.string().optional().nullable(),
      access_token: z.string().optional().nullable(),
      expires_at: z.number().int().optional().nullable(),
      scope: z.string().optional().nullable(),
      id_token: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string()
    })
    .strict();

export const AccountUpdateInputSchema: z.ZodType<Prisma.AccountUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().cuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    providerId: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    providerAccountId: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    password: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    refresh_token: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    access_token: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    expires_at: z
      .union([
        z.number().int(),
        z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    scope: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    id_token: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    user: z
      .lazy(() => UserUpdateOneRequiredWithoutAccountsNestedInputSchema)
      .optional()
  })
  .strict();

export const AccountUncheckedUpdateInputSchema: z.ZodType<Prisma.AccountUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      providerId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      providerAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      password: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      refresh_token: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      access_token: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      expires_at: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      scope: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      id_token: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const AccountCreateManyInputSchema: z.ZodType<Prisma.AccountCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      providerId: z.string().optional().nullable(),
      providerAccountId: z.string(),
      password: z.string().optional().nullable(),
      refresh_token: z.string().optional().nullable(),
      access_token: z.string().optional().nullable(),
      expires_at: z.number().int().optional().nullable(),
      scope: z.string().optional().nullable(),
      id_token: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string()
    })
    .strict();

export const AccountUpdateManyMutationInputSchema: z.ZodType<Prisma.AccountUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      providerId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      providerAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      password: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      refresh_token: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      access_token: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      expires_at: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      scope: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      id_token: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const AccountUncheckedUpdateManyInputSchema: z.ZodType<Prisma.AccountUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      providerId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      providerAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      password: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      refresh_token: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      access_token: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      expires_at: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      scope: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      id_token: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const SessionCreateInputSchema: z.ZodType<Prisma.SessionCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    sessionToken: z.string(),
    expires: z.coerce.date(),
    ipAddress: z.string().optional().nullable(),
    userAgent: z.string().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    user: z.lazy(() => UserCreateNestedOneWithoutSessionsInputSchema)
  })
  .strict();

export const SessionUncheckedCreateInputSchema: z.ZodType<Prisma.SessionUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      sessionToken: z.string(),
      expires: z.coerce.date(),
      ipAddress: z.string().optional().nullable(),
      userAgent: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string()
    })
    .strict();

export const SessionUpdateInputSchema: z.ZodType<Prisma.SessionUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().cuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    sessionToken: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    expires: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    ipAddress: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    userAgent: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    user: z
      .lazy(() => UserUpdateOneRequiredWithoutSessionsNestedInputSchema)
      .optional()
  })
  .strict();

export const SessionUncheckedUpdateInputSchema: z.ZodType<Prisma.SessionUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sessionToken: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      expires: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ipAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      userAgent: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const SessionCreateManyInputSchema: z.ZodType<Prisma.SessionCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      sessionToken: z.string(),
      expires: z.coerce.date(),
      ipAddress: z.string().optional().nullable(),
      userAgent: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string()
    })
    .strict();

export const SessionUpdateManyMutationInputSchema: z.ZodType<Prisma.SessionUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sessionToken: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      expires: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ipAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      userAgent: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const SessionUncheckedUpdateManyInputSchema: z.ZodType<Prisma.SessionUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sessionToken: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      expires: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ipAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      userAgent: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const VerificationCreateInputSchema: z.ZodType<Prisma.VerificationCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      identifier: z.string(),
      value: z.string(),
      expiresAt: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const VerificationUncheckedCreateInputSchema: z.ZodType<Prisma.VerificationUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      identifier: z.string(),
      value: z.string(),
      expiresAt: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const VerificationUpdateInputSchema: z.ZodType<Prisma.VerificationUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      identifier: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      value: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      expiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const VerificationUncheckedUpdateInputSchema: z.ZodType<Prisma.VerificationUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      identifier: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      value: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      expiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const VerificationCreateManyInputSchema: z.ZodType<Prisma.VerificationCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      identifier: z.string(),
      value: z.string(),
      expiresAt: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const VerificationUpdateManyMutationInputSchema: z.ZodType<Prisma.VerificationUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      identifier: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      value: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      expiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const VerificationUncheckedUpdateManyInputSchema: z.ZodType<Prisma.VerificationUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      identifier: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      value: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      expiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const AuthenticatorCreateInputSchema: z.ZodType<Prisma.AuthenticatorCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      credentialID: z.string(),
      providerAccountId: z.string(),
      credentialPublicKey: z.string(),
      counter: z.number().int(),
      credentialDeviceType: z.string(),
      credentialBackedUp: z.boolean(),
      transports: z.string().optional().nullable(),
      user: z.lazy(() => UserCreateNestedOneWithoutAuthenticatorInputSchema)
    })
    .strict();

export const AuthenticatorUncheckedCreateInputSchema: z.ZodType<Prisma.AuthenticatorUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      credentialID: z.string(),
      providerAccountId: z.string(),
      credentialPublicKey: z.string(),
      counter: z.number().int(),
      credentialDeviceType: z.string(),
      credentialBackedUp: z.boolean(),
      transports: z.string().optional().nullable(),
      userId: z.string()
    })
    .strict();

export const AuthenticatorUpdateInputSchema: z.ZodType<Prisma.AuthenticatorUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      providerAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialPublicKey: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      counter: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialDeviceType: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialBackedUp: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      transports: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutAuthenticatorNestedInputSchema)
        .optional()
    })
    .strict();

export const AuthenticatorUncheckedUpdateInputSchema: z.ZodType<Prisma.AuthenticatorUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      providerAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialPublicKey: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      counter: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialDeviceType: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialBackedUp: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      transports: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const AuthenticatorCreateManyInputSchema: z.ZodType<Prisma.AuthenticatorCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      credentialID: z.string(),
      providerAccountId: z.string(),
      credentialPublicKey: z.string(),
      counter: z.number().int(),
      credentialDeviceType: z.string(),
      credentialBackedUp: z.boolean(),
      transports: z.string().optional().nullable(),
      userId: z.string()
    })
    .strict();

export const AuthenticatorUpdateManyMutationInputSchema: z.ZodType<Prisma.AuthenticatorUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      providerAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialPublicKey: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      counter: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialDeviceType: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialBackedUp: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      transports: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const AuthenticatorUncheckedUpdateManyInputSchema: z.ZodType<Prisma.AuthenticatorUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      providerAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialPublicKey: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      counter: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialDeviceType: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialBackedUp: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      transports: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const PasswordResetTokenCreateInputSchema: z.ZodType<Prisma.PasswordResetTokenCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.string(),
      token: z.string(),
      expires: z.coerce.date()
    })
    .strict();

export const PasswordResetTokenUncheckedCreateInputSchema: z.ZodType<Prisma.PasswordResetTokenUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.string(),
      token: z.string(),
      expires: z.coerce.date()
    })
    .strict();

export const PasswordResetTokenUpdateInputSchema: z.ZodType<Prisma.PasswordResetTokenUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      token: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      expires: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const PasswordResetTokenUncheckedUpdateInputSchema: z.ZodType<Prisma.PasswordResetTokenUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      token: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      expires: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const PasswordResetTokenCreateManyInputSchema: z.ZodType<Prisma.PasswordResetTokenCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.string(),
      token: z.string(),
      expires: z.coerce.date()
    })
    .strict();

export const PasswordResetTokenUpdateManyMutationInputSchema: z.ZodType<Prisma.PasswordResetTokenUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      token: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      expires: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const PasswordResetTokenUncheckedUpdateManyInputSchema: z.ZodType<Prisma.PasswordResetTokenUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      token: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      expires: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const TwoFactorTokenCreateInputSchema: z.ZodType<Prisma.TwoFactorTokenCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.string(),
      token: z.string(),
      expires: z.coerce.date()
    })
    .strict();

export const TwoFactorTokenUncheckedCreateInputSchema: z.ZodType<Prisma.TwoFactorTokenUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.string(),
      token: z.string(),
      expires: z.coerce.date()
    })
    .strict();

export const TwoFactorTokenUpdateInputSchema: z.ZodType<Prisma.TwoFactorTokenUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      token: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      expires: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const TwoFactorTokenUncheckedUpdateInputSchema: z.ZodType<Prisma.TwoFactorTokenUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      token: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      expires: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const TwoFactorTokenCreateManyInputSchema: z.ZodType<Prisma.TwoFactorTokenCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.string(),
      token: z.string(),
      expires: z.coerce.date()
    })
    .strict();

export const TwoFactorTokenUpdateManyMutationInputSchema: z.ZodType<Prisma.TwoFactorTokenUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      token: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      expires: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const TwoFactorTokenUncheckedUpdateManyInputSchema: z.ZodType<Prisma.TwoFactorTokenUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      token: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      expires: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const CustomerCreateInputSchema: z.ZodType<Prisma.CustomerCreateInput> =
  z
    .object({
      stripe_customer_id: z.string(),
      user: z.lazy(() => UserCreateNestedOneWithoutCustomerInputSchema)
    })
    .strict();

export const CustomerUncheckedCreateInputSchema: z.ZodType<Prisma.CustomerUncheckedCreateInput> =
  z
    .object({
      stripe_customer_id: z.string(),
      id: z.string()
    })
    .strict();

export const CustomerUpdateInputSchema: z.ZodType<Prisma.CustomerUpdateInput> =
  z
    .object({
      stripe_customer_id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutCustomerNestedInputSchema)
        .optional()
    })
    .strict();

export const CustomerUncheckedUpdateInputSchema: z.ZodType<Prisma.CustomerUncheckedUpdateInput> =
  z
    .object({
      stripe_customer_id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const CustomerCreateManyInputSchema: z.ZodType<Prisma.CustomerCreateManyInput> =
  z
    .object({
      stripe_customer_id: z.string(),
      id: z.string()
    })
    .strict();

export const CustomerUpdateManyMutationInputSchema: z.ZodType<Prisma.CustomerUpdateManyMutationInput> =
  z
    .object({
      stripe_customer_id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const CustomerUncheckedUpdateManyInputSchema: z.ZodType<Prisma.CustomerUncheckedUpdateManyInput> =
  z
    .object({
      stripe_customer_id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const ProductCreateInputSchema: z.ZodType<Prisma.ProductCreateInput> = z
  .object({
    id: z.string(),
    active: z.boolean(),
    name: z.string(),
    description: z.string(),
    image: z.string(),
    metadata: z
      .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
      .optional(),
    prices: z
      .lazy(() => PriceCreateNestedManyWithoutProductInputSchema)
      .optional()
  })
  .strict();

export const ProductUncheckedCreateInputSchema: z.ZodType<Prisma.ProductUncheckedCreateInput> =
  z
    .object({
      id: z.string(),
      active: z.boolean(),
      name: z.string(),
      description: z.string(),
      image: z.string(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      prices: z
        .lazy(() => PriceUncheckedCreateNestedManyWithoutProductInputSchema)
        .optional()
    })
    .strict();

export const ProductUpdateInputSchema: z.ZodType<Prisma.ProductUpdateInput> = z
  .object({
    id: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    active: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    name: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    description: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    image: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    metadata: z
      .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
      .optional(),
    prices: z
      .lazy(() => PriceUpdateManyWithoutProductNestedInputSchema)
      .optional()
  })
  .strict();

export const ProductUncheckedUpdateInputSchema: z.ZodType<Prisma.ProductUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      prices: z
        .lazy(() => PriceUncheckedUpdateManyWithoutProductNestedInputSchema)
        .optional()
    })
    .strict();

export const ProductCreateManyInputSchema: z.ZodType<Prisma.ProductCreateManyInput> =
  z
    .object({
      id: z.string(),
      active: z.boolean(),
      name: z.string(),
      description: z.string(),
      image: z.string(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional()
    })
    .strict();

export const ProductUpdateManyMutationInputSchema: z.ZodType<Prisma.ProductUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional()
    })
    .strict();

export const ProductUncheckedUpdateManyInputSchema: z.ZodType<Prisma.ProductUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional()
    })
    .strict();

export const PriceCreateInputSchema: z.ZodType<Prisma.PriceCreateInput> = z
  .object({
    id: z.string(),
    active: z.boolean(),
    description: z.string(),
    unit_amount: z.number().int().optional().nullable(),
    currency: z.string(),
    type: z.lazy(() => PricingTypeSchema),
    interval: z
      .lazy(() => PricingPlanIntervalSchema)
      .optional()
      .nullable(),
    interval_count: z.number().int().optional().nullable(),
    trial_period_days: z.number().int().optional().nullable(),
    metadata: z
      .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
      .optional(),
    subscriptions: z
      .lazy(() => SubscriptionCreateNestedManyWithoutPriceInputSchema)
      .optional(),
    product: z.lazy(() => ProductCreateNestedOneWithoutPricesInputSchema)
  })
  .strict();

export const PriceUncheckedCreateInputSchema: z.ZodType<Prisma.PriceUncheckedCreateInput> =
  z
    .object({
      id: z.string(),
      active: z.boolean(),
      description: z.string(),
      unit_amount: z.number().int().optional().nullable(),
      currency: z.string(),
      type: z.lazy(() => PricingTypeSchema),
      interval: z
        .lazy(() => PricingPlanIntervalSchema)
        .optional()
        .nullable(),
      interval_count: z.number().int().optional().nullable(),
      trial_period_days: z.number().int().optional().nullable(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      productId: z.string(),
      subscriptions: z
        .lazy(
          () => SubscriptionUncheckedCreateNestedManyWithoutPriceInputSchema
        )
        .optional()
    })
    .strict();

export const PriceUpdateInputSchema: z.ZodType<Prisma.PriceUpdateInput> = z
  .object({
    id: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    active: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    description: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    unit_amount: z
      .union([
        z.number().int(),
        z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    currency: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    type: z
      .union([
        z.lazy(() => PricingTypeSchema),
        z.lazy(() => EnumPricingTypeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    interval: z
      .union([
        z.lazy(() => PricingPlanIntervalSchema),
        z.lazy(
          () => NullableEnumPricingPlanIntervalFieldUpdateOperationsInputSchema
        )
      ])
      .optional()
      .nullable(),
    interval_count: z
      .union([
        z.number().int(),
        z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    trial_period_days: z
      .union([
        z.number().int(),
        z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    metadata: z
      .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
      .optional(),
    subscriptions: z
      .lazy(() => SubscriptionUpdateManyWithoutPriceNestedInputSchema)
      .optional(),
    product: z
      .lazy(() => ProductUpdateOneRequiredWithoutPricesNestedInputSchema)
      .optional()
  })
  .strict();

export const PriceUncheckedUpdateInputSchema: z.ZodType<Prisma.PriceUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      unit_amount: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => PricingTypeSchema),
          z.lazy(() => EnumPricingTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      interval: z
        .union([
          z.lazy(() => PricingPlanIntervalSchema),
          z.lazy(
            () =>
              NullableEnumPricingPlanIntervalFieldUpdateOperationsInputSchema
          )
        ])
        .optional()
        .nullable(),
      interval_count: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_period_days: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      productId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      subscriptions: z
        .lazy(
          () => SubscriptionUncheckedUpdateManyWithoutPriceNestedInputSchema
        )
        .optional()
    })
    .strict();

export const PriceCreateManyInputSchema: z.ZodType<Prisma.PriceCreateManyInput> =
  z
    .object({
      id: z.string(),
      active: z.boolean(),
      description: z.string(),
      unit_amount: z.number().int().optional().nullable(),
      currency: z.string(),
      type: z.lazy(() => PricingTypeSchema),
      interval: z
        .lazy(() => PricingPlanIntervalSchema)
        .optional()
        .nullable(),
      interval_count: z.number().int().optional().nullable(),
      trial_period_days: z.number().int().optional().nullable(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      productId: z.string()
    })
    .strict();

export const PriceUpdateManyMutationInputSchema: z.ZodType<Prisma.PriceUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      unit_amount: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => PricingTypeSchema),
          z.lazy(() => EnumPricingTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      interval: z
        .union([
          z.lazy(() => PricingPlanIntervalSchema),
          z.lazy(
            () =>
              NullableEnumPricingPlanIntervalFieldUpdateOperationsInputSchema
          )
        ])
        .optional()
        .nullable(),
      interval_count: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_period_days: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional()
    })
    .strict();

export const PriceUncheckedUpdateManyInputSchema: z.ZodType<Prisma.PriceUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      unit_amount: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => PricingTypeSchema),
          z.lazy(() => EnumPricingTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      interval: z
        .union([
          z.lazy(() => PricingPlanIntervalSchema),
          z.lazy(
            () =>
              NullableEnumPricingPlanIntervalFieldUpdateOperationsInputSchema
          )
        ])
        .optional()
        .nullable(),
      interval_count: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_period_days: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      productId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const SubscriptionCreateInputSchema: z.ZodType<Prisma.SubscriptionCreateInput> =
  z
    .object({
      id: z.string(),
      status: z.lazy(() => SubscriptionStatusSchema),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      quantity: z.number().int(),
      cancel_at_period_end: z.boolean(),
      created: z.coerce.date().optional(),
      current_period_start: z.coerce.date().optional(),
      current_period_end: z.coerce.date().optional(),
      ended_at: z.coerce.date().optional().nullable(),
      cancel_at: z.coerce.date().optional().nullable(),
      canceled_at: z.coerce.date().optional().nullable(),
      trial_start: z.coerce.date().optional().nullable(),
      trial_end: z.coerce.date().optional().nullable(),
      price: z.lazy(() => PriceCreateNestedOneWithoutSubscriptionsInputSchema),
      user: z.lazy(() => UserCreateNestedOneWithoutSubscriptionsInputSchema)
    })
    .strict();

export const SubscriptionUncheckedCreateInputSchema: z.ZodType<Prisma.SubscriptionUncheckedCreateInput> =
  z
    .object({
      id: z.string(),
      status: z.lazy(() => SubscriptionStatusSchema),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      quantity: z.number().int(),
      cancel_at_period_end: z.boolean(),
      created: z.coerce.date().optional(),
      current_period_start: z.coerce.date().optional(),
      current_period_end: z.coerce.date().optional(),
      ended_at: z.coerce.date().optional().nullable(),
      cancel_at: z.coerce.date().optional().nullable(),
      canceled_at: z.coerce.date().optional().nullable(),
      trial_start: z.coerce.date().optional().nullable(),
      trial_end: z.coerce.date().optional().nullable(),
      priceId: z.string(),
      userId: z.string()
    })
    .strict();

export const SubscriptionUpdateInputSchema: z.ZodType<Prisma.SubscriptionUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      cancel_at_period_end: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      created: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      current_period_start: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      current_period_end: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ended_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      cancel_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      canceled_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_start: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_end: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      price: z
        .lazy(() => PriceUpdateOneRequiredWithoutSubscriptionsNestedInputSchema)
        .optional(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutSubscriptionsNestedInputSchema)
        .optional()
    })
    .strict();

export const SubscriptionUncheckedUpdateInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      cancel_at_period_end: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      created: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      current_period_start: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      current_period_end: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ended_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      cancel_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      canceled_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_start: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_end: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      priceId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const SubscriptionCreateManyInputSchema: z.ZodType<Prisma.SubscriptionCreateManyInput> =
  z
    .object({
      id: z.string(),
      status: z.lazy(() => SubscriptionStatusSchema),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      quantity: z.number().int(),
      cancel_at_period_end: z.boolean(),
      created: z.coerce.date().optional(),
      current_period_start: z.coerce.date().optional(),
      current_period_end: z.coerce.date().optional(),
      ended_at: z.coerce.date().optional().nullable(),
      cancel_at: z.coerce.date().optional().nullable(),
      canceled_at: z.coerce.date().optional().nullable(),
      trial_start: z.coerce.date().optional().nullable(),
      trial_end: z.coerce.date().optional().nullable(),
      priceId: z.string(),
      userId: z.string()
    })
    .strict();

export const SubscriptionUpdateManyMutationInputSchema: z.ZodType<Prisma.SubscriptionUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      cancel_at_period_end: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      created: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      current_period_start: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      current_period_end: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ended_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      cancel_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      canceled_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_start: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_end: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const SubscriptionUncheckedUpdateManyInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      cancel_at_period_end: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      created: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      current_period_start: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      current_period_end: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ended_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      cancel_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      canceled_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_start: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_end: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      priceId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const FeedCreateInputSchema: z.ZodType<Prisma.FeedCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    type: z.lazy(() => FeedTypeSchema).optional(),
    content: z
      .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
      .optional(),
    commentable: z.boolean().optional(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    site: z.lazy(() => SiteCreateNestedOneWithoutFeedInputSchema),
    user: z.lazy(() => UserCreateNestedOneWithoutFeedInputSchema),
    comments: z
      .lazy(() => CommentCreateNestedManyWithoutFeedInputSchema)
      .optional(),
    likes: z.lazy(() => LikeCreateNestedManyWithoutFeedInputSchema).optional()
  })
  .strict();

export const FeedUncheckedCreateInputSchema: z.ZodType<Prisma.FeedUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => FeedTypeSchema).optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      siteId: z.string(),
      userId: z.string(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutFeedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutFeedInputSchema)
        .optional()
    })
    .strict();

export const FeedUpdateInputSchema: z.ZodType<Prisma.FeedUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().cuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    type: z
      .union([
        z.lazy(() => FeedTypeSchema),
        z.lazy(() => EnumFeedTypeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    content: z
      .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
      .optional(),
    commentable: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    site: z
      .lazy(() => SiteUpdateOneRequiredWithoutFeedNestedInputSchema)
      .optional(),
    user: z
      .lazy(() => UserUpdateOneRequiredWithoutFeedNestedInputSchema)
      .optional(),
    comments: z
      .lazy(() => CommentUpdateManyWithoutFeedNestedInputSchema)
      .optional(),
    likes: z.lazy(() => LikeUpdateManyWithoutFeedNestedInputSchema).optional()
  })
  .strict();

export const FeedUncheckedUpdateInputSchema: z.ZodType<Prisma.FeedUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => FeedTypeSchema),
          z.lazy(() => EnumFeedTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutFeedNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutFeedNestedInputSchema)
        .optional()
    })
    .strict();

export const FeedCreateManyInputSchema: z.ZodType<Prisma.FeedCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => FeedTypeSchema).optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      siteId: z.string(),
      userId: z.string()
    })
    .strict();

export const FeedUpdateManyMutationInputSchema: z.ZodType<Prisma.FeedUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => FeedTypeSchema),
          z.lazy(() => EnumFeedTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const FeedUncheckedUpdateManyInputSchema: z.ZodType<Prisma.FeedUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => FeedTypeSchema),
          z.lazy(() => EnumFeedTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const CommentCreateInputSchema: z.ZodType<Prisma.CommentCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    content: z.string(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    feed: z
      .lazy(() => FeedCreateNestedOneWithoutCommentsInputSchema)
      .optional(),
    user: z.lazy(() => UserCreateNestedOneWithoutCommentsInputSchema)
  })
  .strict();

export const CommentUncheckedCreateInputSchema: z.ZodType<Prisma.CommentUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      content: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      feedId: z.string().optional().nullable(),
      userId: z.string()
    })
    .strict();

export const CommentUpdateInputSchema: z.ZodType<Prisma.CommentUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().cuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    content: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    feed: z
      .lazy(() => FeedUpdateOneWithoutCommentsNestedInputSchema)
      .optional(),
    user: z
      .lazy(() => UserUpdateOneRequiredWithoutCommentsNestedInputSchema)
      .optional()
  })
  .strict();

export const CommentUncheckedUpdateInputSchema: z.ZodType<Prisma.CommentUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      feedId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const CommentCreateManyInputSchema: z.ZodType<Prisma.CommentCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      content: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      feedId: z.string().optional().nullable(),
      userId: z.string()
    })
    .strict();

export const CommentUpdateManyMutationInputSchema: z.ZodType<Prisma.CommentUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const CommentUncheckedUpdateManyInputSchema: z.ZodType<Prisma.CommentUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      feedId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const CityCreateInputSchema: z.ZodType<Prisma.CityCreateInput> = z
  .object({
    departement: z.string().optional().nullable(),
    slug: z.string().optional().nullable(),
    nom: z.string().optional().nullable(),
    nomSimple: z.string().optional().nullable(),
    nomReel: z.string().optional().nullable(),
    nomSoundex: z.string().optional().nullable(),
    nomMetaphone: z.string().optional().nullable(),
    codePostal: z.string().optional().nullable(),
    commune: z.string().optional().nullable(),
    codeCommune: z.string(),
    arrondissement: z.number().int().optional().nullable(),
    canton: z.string().optional().nullable(),
    amdi: z.number().int().optional().nullable(),
    population2010: z.number().int().optional().nullable(),
    population1999: z.number().int().optional().nullable(),
    population2012: z.number().int().optional().nullable(),
    densite2010: z.number().int().optional().nullable(),
    surface: z.number().optional().nullable(),
    longitudeDeg: z.number().optional().nullable(),
    latitudeDeg: z.number().optional().nullable(),
    longitudeGrd: z.string().optional().nullable(),
    latitudeGrd: z.string().optional().nullable(),
    longitudeDms: z.string().optional().nullable(),
    latitudeDms: z.string().optional().nullable(),
    zmin: z.number().int().optional().nullable(),
    zmax: z.number().int().optional().nullable()
  })
  .strict();

export const CityUncheckedCreateInputSchema: z.ZodType<Prisma.CityUncheckedCreateInput> =
  z
    .object({
      id: z.number().int().optional(),
      departement: z.string().optional().nullable(),
      slug: z.string().optional().nullable(),
      nom: z.string().optional().nullable(),
      nomSimple: z.string().optional().nullable(),
      nomReel: z.string().optional().nullable(),
      nomSoundex: z.string().optional().nullable(),
      nomMetaphone: z.string().optional().nullable(),
      codePostal: z.string().optional().nullable(),
      commune: z.string().optional().nullable(),
      codeCommune: z.string(),
      arrondissement: z.number().int().optional().nullable(),
      canton: z.string().optional().nullable(),
      amdi: z.number().int().optional().nullable(),
      population2010: z.number().int().optional().nullable(),
      population1999: z.number().int().optional().nullable(),
      population2012: z.number().int().optional().nullable(),
      densite2010: z.number().int().optional().nullable(),
      surface: z.number().optional().nullable(),
      longitudeDeg: z.number().optional().nullable(),
      latitudeDeg: z.number().optional().nullable(),
      longitudeGrd: z.string().optional().nullable(),
      latitudeGrd: z.string().optional().nullable(),
      longitudeDms: z.string().optional().nullable(),
      latitudeDms: z.string().optional().nullable(),
      zmin: z.number().int().optional().nullable(),
      zmax: z.number().int().optional().nullable()
    })
    .strict();

export const CityUpdateInputSchema: z.ZodType<Prisma.CityUpdateInput> = z
  .object({
    departement: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    slug: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    nom: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    nomSimple: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    nomReel: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    nomSoundex: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    nomMetaphone: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    codePostal: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    commune: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    codeCommune: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    arrondissement: z
      .union([
        z.number().int(),
        z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    canton: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    amdi: z
      .union([
        z.number().int(),
        z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    population2010: z
      .union([
        z.number().int(),
        z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    population1999: z
      .union([
        z.number().int(),
        z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    population2012: z
      .union([
        z.number().int(),
        z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    densite2010: z
      .union([
        z.number().int(),
        z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    surface: z
      .union([
        z.number(),
        z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    longitudeDeg: z
      .union([
        z.number(),
        z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    latitudeDeg: z
      .union([
        z.number(),
        z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    longitudeGrd: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    latitudeGrd: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    longitudeDms: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    latitudeDms: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    zmin: z
      .union([
        z.number().int(),
        z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    zmax: z
      .union([
        z.number().int(),
        z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable()
  })
  .strict();

export const CityUncheckedUpdateInputSchema: z.ZodType<Prisma.CityUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      departement: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      nom: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      nomSimple: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      nomReel: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      nomSoundex: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      nomMetaphone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codePostal: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      commune: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeCommune: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      arrondissement: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      canton: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      amdi: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      population2010: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      population1999: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      population2012: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      densite2010: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      surface: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      longitudeDeg: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      latitudeDeg: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      longitudeGrd: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      latitudeGrd: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      longitudeDms: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      latitudeDms: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      zmin: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      zmax: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const CityCreateManyInputSchema: z.ZodType<Prisma.CityCreateManyInput> =
  z
    .object({
      id: z.number().int().optional(),
      departement: z.string().optional().nullable(),
      slug: z.string().optional().nullable(),
      nom: z.string().optional().nullable(),
      nomSimple: z.string().optional().nullable(),
      nomReel: z.string().optional().nullable(),
      nomSoundex: z.string().optional().nullable(),
      nomMetaphone: z.string().optional().nullable(),
      codePostal: z.string().optional().nullable(),
      commune: z.string().optional().nullable(),
      codeCommune: z.string(),
      arrondissement: z.number().int().optional().nullable(),
      canton: z.string().optional().nullable(),
      amdi: z.number().int().optional().nullable(),
      population2010: z.number().int().optional().nullable(),
      population1999: z.number().int().optional().nullable(),
      population2012: z.number().int().optional().nullable(),
      densite2010: z.number().int().optional().nullable(),
      surface: z.number().optional().nullable(),
      longitudeDeg: z.number().optional().nullable(),
      latitudeDeg: z.number().optional().nullable(),
      longitudeGrd: z.string().optional().nullable(),
      latitudeGrd: z.string().optional().nullable(),
      longitudeDms: z.string().optional().nullable(),
      latitudeDms: z.string().optional().nullable(),
      zmin: z.number().int().optional().nullable(),
      zmax: z.number().int().optional().nullable()
    })
    .strict();

export const CityUpdateManyMutationInputSchema: z.ZodType<Prisma.CityUpdateManyMutationInput> =
  z
    .object({
      departement: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      nom: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      nomSimple: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      nomReel: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      nomSoundex: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      nomMetaphone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codePostal: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      commune: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeCommune: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      arrondissement: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      canton: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      amdi: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      population2010: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      population1999: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      population2012: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      densite2010: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      surface: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      longitudeDeg: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      latitudeDeg: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      longitudeGrd: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      latitudeGrd: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      longitudeDms: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      latitudeDms: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      zmin: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      zmax: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const CityUncheckedUpdateManyInputSchema: z.ZodType<Prisma.CityUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      departement: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      nom: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      nomSimple: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      nomReel: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      nomSoundex: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      nomMetaphone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codePostal: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      commune: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeCommune: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      arrondissement: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      canton: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      amdi: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      population2010: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      population1999: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      population2012: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      densite2010: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      surface: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      longitudeDeg: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      latitudeDeg: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      longitudeGrd: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      latitudeGrd: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      longitudeDms: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      latitudeDms: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      zmin: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      zmax: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const NafSectionCreateInputSchema: z.ZodType<Prisma.NafSectionCreateInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      divisions: z
        .lazy(() => NafDivisionCreateNestedManyWithoutSectionInputSchema)
        .optional()
    })
    .strict();

export const NafSectionUncheckedCreateInputSchema: z.ZodType<Prisma.NafSectionUncheckedCreateInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      divisions: z
        .lazy(
          () => NafDivisionUncheckedCreateNestedManyWithoutSectionInputSchema
        )
        .optional()
    })
    .strict();

export const NafSectionUpdateInputSchema: z.ZodType<Prisma.NafSectionUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      divisions: z
        .lazy(() => NafDivisionUpdateManyWithoutSectionNestedInputSchema)
        .optional()
    })
    .strict();

export const NafSectionUncheckedUpdateInputSchema: z.ZodType<Prisma.NafSectionUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      divisions: z
        .lazy(
          () => NafDivisionUncheckedUpdateManyWithoutSectionNestedInputSchema
        )
        .optional()
    })
    .strict();

export const NafSectionCreateManyInputSchema: z.ZodType<Prisma.NafSectionCreateManyInput> =
  z
    .object({
      id: z.string(),
      title: z.string()
    })
    .strict();

export const NafSectionUpdateManyMutationInputSchema: z.ZodType<Prisma.NafSectionUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const NafSectionUncheckedUpdateManyInputSchema: z.ZodType<Prisma.NafSectionUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const NafDivisionCreateInputSchema: z.ZodType<Prisma.NafDivisionCreateInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      groups: z
        .lazy(() => NafGroupCreateNestedManyWithoutDivisionInputSchema)
        .optional(),
      section: z.lazy(
        () => NafSectionCreateNestedOneWithoutDivisionsInputSchema
      )
    })
    .strict();

export const NafDivisionUncheckedCreateInputSchema: z.ZodType<Prisma.NafDivisionUncheckedCreateInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      sectionId: z.string(),
      groups: z
        .lazy(() => NafGroupUncheckedCreateNestedManyWithoutDivisionInputSchema)
        .optional()
    })
    .strict();

export const NafDivisionUpdateInputSchema: z.ZodType<Prisma.NafDivisionUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      groups: z
        .lazy(() => NafGroupUpdateManyWithoutDivisionNestedInputSchema)
        .optional(),
      section: z
        .lazy(
          () => NafSectionUpdateOneRequiredWithoutDivisionsNestedInputSchema
        )
        .optional()
    })
    .strict();

export const NafDivisionUncheckedUpdateInputSchema: z.ZodType<Prisma.NafDivisionUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sectionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      groups: z
        .lazy(() => NafGroupUncheckedUpdateManyWithoutDivisionNestedInputSchema)
        .optional()
    })
    .strict();

export const NafDivisionCreateManyInputSchema: z.ZodType<Prisma.NafDivisionCreateManyInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      sectionId: z.string()
    })
    .strict();

export const NafDivisionUpdateManyMutationInputSchema: z.ZodType<Prisma.NafDivisionUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const NafDivisionUncheckedUpdateManyInputSchema: z.ZodType<Prisma.NafDivisionUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sectionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const NafGroupCreateInputSchema: z.ZodType<Prisma.NafGroupCreateInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      classes: z
        .lazy(() => NafClassCreateNestedManyWithoutGroupInputSchema)
        .optional(),
      division: z.lazy(() => NafDivisionCreateNestedOneWithoutGroupsInputSchema)
    })
    .strict();

export const NafGroupUncheckedCreateInputSchema: z.ZodType<Prisma.NafGroupUncheckedCreateInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      divisionId: z.string(),
      classes: z
        .lazy(() => NafClassUncheckedCreateNestedManyWithoutGroupInputSchema)
        .optional()
    })
    .strict();

export const NafGroupUpdateInputSchema: z.ZodType<Prisma.NafGroupUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      classes: z
        .lazy(() => NafClassUpdateManyWithoutGroupNestedInputSchema)
        .optional(),
      division: z
        .lazy(() => NafDivisionUpdateOneRequiredWithoutGroupsNestedInputSchema)
        .optional()
    })
    .strict();

export const NafGroupUncheckedUpdateInputSchema: z.ZodType<Prisma.NafGroupUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      divisionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      classes: z
        .lazy(() => NafClassUncheckedUpdateManyWithoutGroupNestedInputSchema)
        .optional()
    })
    .strict();

export const NafGroupCreateManyInputSchema: z.ZodType<Prisma.NafGroupCreateManyInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      divisionId: z.string()
    })
    .strict();

export const NafGroupUpdateManyMutationInputSchema: z.ZodType<Prisma.NafGroupUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const NafGroupUncheckedUpdateManyInputSchema: z.ZodType<Prisma.NafGroupUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      divisionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const NafClassCreateInputSchema: z.ZodType<Prisma.NafClassCreateInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      codes: z
        .lazy(() => NafCodeCreateNestedManyWithoutClassInputSchema)
        .optional(),
      group: z.lazy(() => NafGroupCreateNestedOneWithoutClassesInputSchema)
    })
    .strict();

export const NafClassUncheckedCreateInputSchema: z.ZodType<Prisma.NafClassUncheckedCreateInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      groupId: z.string(),
      codes: z
        .lazy(() => NafCodeUncheckedCreateNestedManyWithoutClassInputSchema)
        .optional()
    })
    .strict();

export const NafClassUpdateInputSchema: z.ZodType<Prisma.NafClassUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      codes: z
        .lazy(() => NafCodeUpdateManyWithoutClassNestedInputSchema)
        .optional(),
      group: z
        .lazy(() => NafGroupUpdateOneRequiredWithoutClassesNestedInputSchema)
        .optional()
    })
    .strict();

export const NafClassUncheckedUpdateInputSchema: z.ZodType<Prisma.NafClassUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      groupId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      codes: z
        .lazy(() => NafCodeUncheckedUpdateManyWithoutClassNestedInputSchema)
        .optional()
    })
    .strict();

export const NafClassCreateManyInputSchema: z.ZodType<Prisma.NafClassCreateManyInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      groupId: z.string()
    })
    .strict();

export const NafClassUpdateManyMutationInputSchema: z.ZodType<Prisma.NafClassUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const NafClassUncheckedUpdateManyInputSchema: z.ZodType<Prisma.NafClassUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      groupId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const NafCodeCreateInputSchema: z.ZodType<Prisma.NafCodeCreateInput> = z
  .object({
    id: z.string(),
    title: z.string(),
    class: z.lazy(() => NafClassCreateNestedOneWithoutCodesInputSchema),
    users: z.lazy(() => UserCreateNestedManyWithoutNafInputSchema).optional()
  })
  .strict();

export const NafCodeUncheckedCreateInputSchema: z.ZodType<Prisma.NafCodeUncheckedCreateInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      classId: z.string(),
      users: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutNafInputSchema)
        .optional()
    })
    .strict();

export const NafCodeUpdateInputSchema: z.ZodType<Prisma.NafCodeUpdateInput> = z
  .object({
    id: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    title: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    class: z
      .lazy(() => NafClassUpdateOneRequiredWithoutCodesNestedInputSchema)
      .optional(),
    users: z.lazy(() => UserUpdateManyWithoutNafNestedInputSchema).optional()
  })
  .strict();

export const NafCodeUncheckedUpdateInputSchema: z.ZodType<Prisma.NafCodeUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      classId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      users: z
        .lazy(() => UserUncheckedUpdateManyWithoutNafNestedInputSchema)
        .optional()
    })
    .strict();

export const NafCodeCreateManyInputSchema: z.ZodType<Prisma.NafCodeCreateManyInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      classId: z.string()
    })
    .strict();

export const NafCodeUpdateManyMutationInputSchema: z.ZodType<Prisma.NafCodeUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const NafCodeUncheckedUpdateManyInputSchema: z.ZodType<Prisma.NafCodeUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      classId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const OutboxCreateInputSchema: z.ZodType<Prisma.OutboxCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    subject: z.string(),
    body: z.string(),
    status: z.string().optional(),
    metadata: z
      .union([
        z.lazy(() => NullableJsonNullValueInputSchema),
        InputJsonValueSchema
      ])
      .optional(),
    createdAt: z.coerce.date().optional(),
    campaign: z
      .lazy(() => CampaignCreateNestedOneWithoutOutboxesInputSchema)
      .optional(),
    user: z.lazy(() => UserCreateNestedOneWithoutOutboxInputSchema).optional()
  })
  .strict();

export const OutboxUncheckedCreateInputSchema: z.ZodType<Prisma.OutboxUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.string(),
      subject: z.string(),
      body: z.string(),
      status: z.string().optional(),
      metadata: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      campaignId: z.string().optional().nullable()
    })
    .strict();

export const OutboxUpdateInputSchema: z.ZodType<Prisma.OutboxUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().cuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    subject: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    body: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    status: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    metadata: z
      .union([
        z.lazy(() => NullableJsonNullValueInputSchema),
        InputJsonValueSchema
      ])
      .optional(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    campaign: z
      .lazy(() => CampaignUpdateOneWithoutOutboxesNestedInputSchema)
      .optional(),
    user: z.lazy(() => UserUpdateOneWithoutOutboxNestedInputSchema).optional()
  })
  .strict();

export const OutboxUncheckedUpdateInputSchema: z.ZodType<Prisma.OutboxUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      subject: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      body: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      campaignId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const OutboxCreateManyInputSchema: z.ZodType<Prisma.OutboxCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.string(),
      subject: z.string(),
      body: z.string(),
      status: z.string().optional(),
      metadata: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      campaignId: z.string().optional().nullable()
    })
    .strict();

export const OutboxUpdateManyMutationInputSchema: z.ZodType<Prisma.OutboxUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      subject: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      body: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const OutboxUncheckedUpdateManyInputSchema: z.ZodType<Prisma.OutboxUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      subject: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      body: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      campaignId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ListCreateInputSchema: z.ZodType<Prisma.ListCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    title: z.string(),
    description: z.string().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    owners: z
      .lazy(() => UserCreateNestedManyWithoutListsManageInputSchema)
      .optional(),
    contacts: z
      .lazy(() => UserCreateNestedManyWithoutListsInputSchema)
      .optional(),
    campaigns: z
      .lazy(() => CampaignCreateNestedManyWithoutListInputSchema)
      .optional()
  })
  .strict();

export const ListUncheckedCreateInputSchema: z.ZodType<Prisma.ListUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      owners: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutListsManageInputSchema)
        .optional(),
      contacts: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutListsInputSchema)
        .optional(),
      campaigns: z
        .lazy(() => CampaignUncheckedCreateNestedManyWithoutListInputSchema)
        .optional()
    })
    .strict();

export const ListUpdateInputSchema: z.ZodType<Prisma.ListUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().cuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    title: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    description: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    owners: z
      .lazy(() => UserUpdateManyWithoutListsManageNestedInputSchema)
      .optional(),
    contacts: z
      .lazy(() => UserUpdateManyWithoutListsNestedInputSchema)
      .optional(),
    campaigns: z
      .lazy(() => CampaignUpdateManyWithoutListNestedInputSchema)
      .optional()
  })
  .strict();

export const ListUncheckedUpdateInputSchema: z.ZodType<Prisma.ListUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      owners: z
        .lazy(() => UserUncheckedUpdateManyWithoutListsManageNestedInputSchema)
        .optional(),
      contacts: z
        .lazy(() => UserUncheckedUpdateManyWithoutListsNestedInputSchema)
        .optional(),
      campaigns: z
        .lazy(() => CampaignUncheckedUpdateManyWithoutListNestedInputSchema)
        .optional()
    })
    .strict();

export const ListCreateManyInputSchema: z.ZodType<Prisma.ListCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const ListUpdateManyMutationInputSchema: z.ZodType<Prisma.ListUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const ListUncheckedUpdateManyInputSchema: z.ZodType<Prisma.ListUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const CampaignCreateInputSchema: z.ZodType<Prisma.CampaignCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => CampaignTypeSchema).optional(),
      smart: z.boolean().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      active: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      list: z
        .lazy(() => ListCreateNestedOneWithoutCampaignsInputSchema)
        .optional(),
      email: z.lazy(() => EmailCreateNestedOneWithoutCampaignsInputSchema),
      outboxes: z
        .lazy(() => OutboxCreateNestedManyWithoutCampaignInputSchema)
        .optional()
    })
    .strict();

export const CampaignUncheckedCreateInputSchema: z.ZodType<Prisma.CampaignUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => CampaignTypeSchema).optional(),
      smart: z.boolean().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      active: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      listId: z.string().optional().nullable(),
      emailId: z.string(),
      outboxes: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutCampaignInputSchema)
        .optional()
    })
    .strict();

export const CampaignUpdateInputSchema: z.ZodType<Prisma.CampaignUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => CampaignTypeSchema),
          z.lazy(() => EnumCampaignTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      smart: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      list: z
        .lazy(() => ListUpdateOneWithoutCampaignsNestedInputSchema)
        .optional(),
      email: z
        .lazy(() => EmailUpdateOneRequiredWithoutCampaignsNestedInputSchema)
        .optional(),
      outboxes: z
        .lazy(() => OutboxUpdateManyWithoutCampaignNestedInputSchema)
        .optional()
    })
    .strict();

export const CampaignUncheckedUpdateInputSchema: z.ZodType<Prisma.CampaignUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => CampaignTypeSchema),
          z.lazy(() => EnumCampaignTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      smart: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      listId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      emailId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      outboxes: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutCampaignNestedInputSchema)
        .optional()
    })
    .strict();

export const CampaignCreateManyInputSchema: z.ZodType<Prisma.CampaignCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => CampaignTypeSchema).optional(),
      smart: z.boolean().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      active: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      listId: z.string().optional().nullable(),
      emailId: z.string()
    })
    .strict();

export const CampaignUpdateManyMutationInputSchema: z.ZodType<Prisma.CampaignUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => CampaignTypeSchema),
          z.lazy(() => EnumCampaignTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      smart: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const CampaignUncheckedUpdateManyInputSchema: z.ZodType<Prisma.CampaignUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => CampaignTypeSchema),
          z.lazy(() => EnumCampaignTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      smart: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      listId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      emailId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const EmailCreateInputSchema: z.ZodType<Prisma.EmailCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    title: z.string(),
    description: z.string().optional().nullable(),
    subject: z.string(),
    content: z.string(),
    design: z
      .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
      .optional(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    user: z.lazy(() => UserCreateNestedOneWithoutEmailsInputSchema),
    campaigns: z
      .lazy(() => CampaignCreateNestedManyWithoutEmailInputSchema)
      .optional()
  })
  .strict();

export const EmailUncheckedCreateInputSchema: z.ZodType<Prisma.EmailUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      subject: z.string(),
      content: z.string(),
      design: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string(),
      campaigns: z
        .lazy(() => CampaignUncheckedCreateNestedManyWithoutEmailInputSchema)
        .optional()
    })
    .strict();

export const EmailUpdateInputSchema: z.ZodType<Prisma.EmailUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().cuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    title: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    description: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    subject: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    content: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    design: z
      .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
      .optional(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    user: z
      .lazy(() => UserUpdateOneRequiredWithoutEmailsNestedInputSchema)
      .optional(),
    campaigns: z
      .lazy(() => CampaignUpdateManyWithoutEmailNestedInputSchema)
      .optional()
  })
  .strict();

export const EmailUncheckedUpdateInputSchema: z.ZodType<Prisma.EmailUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subject: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      design: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      campaigns: z
        .lazy(() => CampaignUncheckedUpdateManyWithoutEmailNestedInputSchema)
        .optional()
    })
    .strict();

export const EmailCreateManyInputSchema: z.ZodType<Prisma.EmailCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      subject: z.string(),
      content: z.string(),
      design: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string()
    })
    .strict();

export const EmailUpdateManyMutationInputSchema: z.ZodType<Prisma.EmailUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subject: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      design: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const EmailUncheckedUpdateManyInputSchema: z.ZodType<Prisma.EmailUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subject: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      design: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const MediaCreateInputSchema: z.ZodType<Prisma.MediaCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    entityId: z.string(),
    entityType: z.lazy(() => EntityTypeSchema),
    url: z.string(),
    alt: z.string().optional().nullable(),
    type: z.lazy(() => MediaTypeSchema).optional(),
    position: z.number().int().optional(),
    isMain: z.boolean().optional(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional()
  })
  .strict();

export const MediaUncheckedCreateInputSchema: z.ZodType<Prisma.MediaUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      entityId: z.string(),
      entityType: z.lazy(() => EntityTypeSchema),
      url: z.string(),
      alt: z.string().optional().nullable(),
      type: z.lazy(() => MediaTypeSchema).optional(),
      position: z.number().int().optional(),
      isMain: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const MediaUpdateInputSchema: z.ZodType<Prisma.MediaUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().cuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    entityId: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    entityType: z
      .union([
        z.lazy(() => EntityTypeSchema),
        z.lazy(() => EnumEntityTypeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    url: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    alt: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    type: z
      .union([
        z.lazy(() => MediaTypeSchema),
        z.lazy(() => EnumMediaTypeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    position: z
      .union([
        z.number().int(),
        z.lazy(() => IntFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    isMain: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional()
  })
  .strict();

export const MediaUncheckedUpdateInputSchema: z.ZodType<Prisma.MediaUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      entityId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      entityType: z
        .union([
          z.lazy(() => EntityTypeSchema),
          z.lazy(() => EnumEntityTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      url: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      alt: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => MediaTypeSchema),
          z.lazy(() => EnumMediaTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isMain: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const MediaCreateManyInputSchema: z.ZodType<Prisma.MediaCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      entityId: z.string(),
      entityType: z.lazy(() => EntityTypeSchema),
      url: z.string(),
      alt: z.string().optional().nullable(),
      type: z.lazy(() => MediaTypeSchema).optional(),
      position: z.number().int().optional(),
      isMain: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const MediaUpdateManyMutationInputSchema: z.ZodType<Prisma.MediaUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      entityId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      entityType: z
        .union([
          z.lazy(() => EntityTypeSchema),
          z.lazy(() => EnumEntityTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      url: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      alt: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => MediaTypeSchema),
          z.lazy(() => EnumMediaTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isMain: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const MediaUncheckedUpdateManyInputSchema: z.ZodType<Prisma.MediaUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      entityId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      entityType: z
        .union([
          z.lazy(() => EntityTypeSchema),
          z.lazy(() => EnumEntityTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      url: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      alt: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => MediaTypeSchema),
          z.lazy(() => EnumMediaTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isMain: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const ClickCreateInputSchema: z.ZodType<Prisma.ClickCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    part: z.string().optional().nullable(),
    path: z.string().optional().nullable(),
    request: z
      .union([
        z.lazy(() => NullableJsonNullValueInputSchema),
        InputJsonValueSchema
      ])
      .optional(),
    createdAt: z.coerce.date().optional(),
    block: z
      .lazy(() => BlockCreateNestedOneWithoutClicksInputSchema)
      .optional(),
    site: z.lazy(() => SiteCreateNestedOneWithoutClicksInputSchema).optional(),
    link: z.lazy(() => LinkCreateNestedOneWithoutClicksInputSchema).optional(),
    user: z.lazy(() => UserCreateNestedOneWithoutClicksInputSchema).optional(),
    referer: z
      .lazy(() => UserCreateNestedOneWithoutReferralsInputSchema)
      .optional()
  })
  .strict();

export const ClickUncheckedCreateInputSchema: z.ZodType<Prisma.ClickUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      part: z.string().optional().nullable(),
      path: z.string().optional().nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      blockId: z.string().optional().nullable(),
      siteId: z.string().optional().nullable(),
      linkId: z.string().optional().nullable(),
      userId: z.string().optional().nullable(),
      refererId: z.string().optional().nullable()
    })
    .strict();

export const ClickUpdateInputSchema: z.ZodType<Prisma.ClickUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().cuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    part: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    path: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    request: z
      .union([
        z.lazy(() => NullableJsonNullValueInputSchema),
        InputJsonValueSchema
      ])
      .optional(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    block: z
      .lazy(() => BlockUpdateOneWithoutClicksNestedInputSchema)
      .optional(),
    site: z.lazy(() => SiteUpdateOneWithoutClicksNestedInputSchema).optional(),
    link: z.lazy(() => LinkUpdateOneWithoutClicksNestedInputSchema).optional(),
    user: z.lazy(() => UserUpdateOneWithoutClicksNestedInputSchema).optional(),
    referer: z
      .lazy(() => UserUpdateOneWithoutReferralsNestedInputSchema)
      .optional()
  })
  .strict();

export const ClickUncheckedUpdateInputSchema: z.ZodType<Prisma.ClickUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      part: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      path: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      linkId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ClickCreateManyInputSchema: z.ZodType<Prisma.ClickCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      part: z.string().optional().nullable(),
      path: z.string().optional().nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      blockId: z.string().optional().nullable(),
      siteId: z.string().optional().nullable(),
      linkId: z.string().optional().nullable(),
      userId: z.string().optional().nullable(),
      refererId: z.string().optional().nullable()
    })
    .strict();

export const ClickUpdateManyMutationInputSchema: z.ZodType<Prisma.ClickUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      part: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      path: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const ClickUncheckedUpdateManyInputSchema: z.ZodType<Prisma.ClickUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      part: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      path: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      linkId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const LinkCreateInputSchema: z.ZodType<Prisma.LinkCreateInput> = z
  .object({
    id: z.string(),
    url: z.string(),
    name: z.string().optional().nullable(),
    description: z.string().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    clicks: z
      .lazy(() => ClickCreateNestedManyWithoutLinkInputSchema)
      .optional(),
    user: z.lazy(() => UserCreateNestedOneWithoutLinksInputSchema).optional()
  })
  .strict();

export const LinkUncheckedCreateInputSchema: z.ZodType<Prisma.LinkUncheckedCreateInput> =
  z
    .object({
      id: z.string(),
      url: z.string(),
      name: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string().optional().nullable(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutLinkInputSchema)
        .optional()
    })
    .strict();

export const LinkUpdateInputSchema: z.ZodType<Prisma.LinkUpdateInput> = z
  .object({
    id: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    url: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    name: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    description: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    clicks: z
      .lazy(() => ClickUpdateManyWithoutLinkNestedInputSchema)
      .optional(),
    user: z.lazy(() => UserUpdateOneWithoutLinksNestedInputSchema).optional()
  })
  .strict();

export const LinkUncheckedUpdateInputSchema: z.ZodType<Prisma.LinkUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      url: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutLinkNestedInputSchema)
        .optional()
    })
    .strict();

export const LinkCreateManyInputSchema: z.ZodType<Prisma.LinkCreateManyInput> =
  z
    .object({
      id: z.string(),
      url: z.string(),
      name: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string().optional().nullable()
    })
    .strict();

export const LinkUpdateManyMutationInputSchema: z.ZodType<Prisma.LinkUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      url: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const LinkUncheckedUpdateManyInputSchema: z.ZodType<Prisma.LinkUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      url: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const BlockCreateInputSchema: z.ZodType<Prisma.BlockCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    type: z.string(),
    position: z.number().int().optional(),
    label: z.string().optional().nullable(),
    href: z.string().optional().nullable(),
    logo: z.string().optional().nullable(),
    style: z
      .union([
        z.lazy(() => NullableJsonNullValueInputSchema),
        InputJsonValueSchema
      ])
      .optional(),
    widget: z
      .union([
        z.lazy(() => NullableJsonNullValueInputSchema),
        InputJsonValueSchema
      ])
      .optional(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    clicks: z
      .lazy(() => ClickCreateNestedManyWithoutBlockInputSchema)
      .optional(),
    reservations: z
      .lazy(() => ReservationCreateNestedManyWithoutBlockInputSchema)
      .optional(),
    site: z.lazy(() => SiteCreateNestedOneWithoutBlocksInputSchema),
    categories: z
      .lazy(() => CategoryCreateNestedManyWithoutBlockInputSchema)
      .optional(),
    inventories: z
      .lazy(() => InventoryCreateNestedManyWithoutBlockInputSchema)
      .optional()
  })
  .strict();

export const BlockUncheckedCreateInputSchema: z.ZodType<Prisma.BlockUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string(),
      position: z.number().int().optional(),
      label: z.string().optional().nullable(),
      href: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      siteId: z.string(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUncheckedCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      categories: z
        .lazy(() => CategoryUncheckedCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      inventories: z
        .lazy(() => InventoryUncheckedCreateNestedManyWithoutBlockInputSchema)
        .optional()
    })
    .strict();

export const BlockUpdateInputSchema: z.ZodType<Prisma.BlockUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().cuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    type: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    position: z
      .union([
        z.number().int(),
        z.lazy(() => IntFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    label: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    href: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    logo: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    style: z
      .union([
        z.lazy(() => NullableJsonNullValueInputSchema),
        InputJsonValueSchema
      ])
      .optional(),
    widget: z
      .union([
        z.lazy(() => NullableJsonNullValueInputSchema),
        InputJsonValueSchema
      ])
      .optional(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    clicks: z
      .lazy(() => ClickUpdateManyWithoutBlockNestedInputSchema)
      .optional(),
    reservations: z
      .lazy(() => ReservationUpdateManyWithoutBlockNestedInputSchema)
      .optional(),
    site: z
      .lazy(() => SiteUpdateOneRequiredWithoutBlocksNestedInputSchema)
      .optional(),
    categories: z
      .lazy(() => CategoryUpdateManyWithoutBlockNestedInputSchema)
      .optional(),
    inventories: z
      .lazy(() => InventoryUpdateManyWithoutBlockNestedInputSchema)
      .optional()
  })
  .strict();

export const BlockUncheckedUpdateInputSchema: z.ZodType<Prisma.BlockUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      label: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      href: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUncheckedUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      categories: z
        .lazy(() => CategoryUncheckedUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      inventories: z
        .lazy(() => InventoryUncheckedUpdateManyWithoutBlockNestedInputSchema)
        .optional()
    })
    .strict();

export const BlockCreateManyInputSchema: z.ZodType<Prisma.BlockCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string(),
      position: z.number().int().optional(),
      label: z.string().optional().nullable(),
      href: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      siteId: z.string()
    })
    .strict();

export const BlockUpdateManyMutationInputSchema: z.ZodType<Prisma.BlockUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      label: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      href: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const BlockUncheckedUpdateManyInputSchema: z.ZodType<Prisma.BlockUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      label: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      href: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const LikeCreateInputSchema: z.ZodType<Prisma.LikeCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    ip: z.string(),
    createdAt: z.coerce.date().optional(),
    site: z.lazy(() => SiteCreateNestedOneWithoutLikesInputSchema),
    user: z.lazy(() => UserCreateNestedOneWithoutLikesInputSchema).optional(),
    feed: z.lazy(() => FeedCreateNestedOneWithoutLikesInputSchema).optional()
  })
  .strict();

export const LikeUncheckedCreateInputSchema: z.ZodType<Prisma.LikeUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      ip: z.string(),
      createdAt: z.coerce.date().optional(),
      siteId: z.string(),
      userId: z.string().optional().nullable(),
      feedId: z.string().optional().nullable()
    })
    .strict();

export const LikeUpdateInputSchema: z.ZodType<Prisma.LikeUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().cuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    ip: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    site: z
      .lazy(() => SiteUpdateOneRequiredWithoutLikesNestedInputSchema)
      .optional(),
    user: z.lazy(() => UserUpdateOneWithoutLikesNestedInputSchema).optional(),
    feed: z.lazy(() => FeedUpdateOneWithoutLikesNestedInputSchema).optional()
  })
  .strict();

export const LikeUncheckedUpdateInputSchema: z.ZodType<Prisma.LikeUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ip: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      feedId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const LikeCreateManyInputSchema: z.ZodType<Prisma.LikeCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      ip: z.string(),
      createdAt: z.coerce.date().optional(),
      siteId: z.string(),
      userId: z.string().optional().nullable(),
      feedId: z.string().optional().nullable()
    })
    .strict();

export const LikeUpdateManyMutationInputSchema: z.ZodType<Prisma.LikeUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ip: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const LikeUncheckedUpdateManyInputSchema: z.ZodType<Prisma.LikeUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ip: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      feedId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const SiteCreateInputSchema: z.ZodType<Prisma.SiteCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    name: z.string().optional().nullable(),
    display_name: z.string().optional().nullable(),
    description: z.string().optional().nullable(),
    logo: z.string().optional().nullable(),
    font: z.string().optional(),
    image: z.string().optional().nullable(),
    imageBlurhash: z.string().optional().nullable(),
    subdomain: z.string().optional().nullable(),
    customDomain: z.string().optional().nullable(),
    message404: z.string().optional().nullable(),
    background: z.string().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    user: z.lazy(() => UserCreateNestedOneWithoutSitesInputSchema),
    blocks: z
      .lazy(() => BlockCreateNestedManyWithoutSiteInputSchema)
      .optional(),
    clicks: z
      .lazy(() => ClickCreateNestedManyWithoutSiteInputSchema)
      .optional(),
    subscribers: z
      .lazy(() => SubscriberCreateNestedManyWithoutSiteInputSchema)
      .optional(),
    likes: z.lazy(() => LikeCreateNestedManyWithoutSiteInputSchema).optional(),
    feed: z.lazy(() => FeedCreateNestedManyWithoutSiteInputSchema).optional()
  })
  .strict();

export const SiteUncheckedCreateInputSchema: z.ZodType<Prisma.SiteUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      display_name: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      font: z.string().optional(),
      image: z.string().optional().nullable(),
      imageBlurhash: z.string().optional().nullable(),
      subdomain: z.string().optional().nullable(),
      customDomain: z.string().optional().nullable(),
      message404: z.string().optional().nullable(),
      background: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string(),
      blocks: z
        .lazy(() => BlockUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      subscribers: z
        .lazy(() => SubscriberUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional()
    })
    .strict();

export const SiteUpdateInputSchema: z.ZodType<Prisma.SiteUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().cuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    name: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    display_name: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    description: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    logo: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    font: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    image: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    imageBlurhash: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    subdomain: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    customDomain: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    message404: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    background: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    user: z
      .lazy(() => UserUpdateOneRequiredWithoutSitesNestedInputSchema)
      .optional(),
    blocks: z
      .lazy(() => BlockUpdateManyWithoutSiteNestedInputSchema)
      .optional(),
    clicks: z
      .lazy(() => ClickUpdateManyWithoutSiteNestedInputSchema)
      .optional(),
    subscribers: z
      .lazy(() => SubscriberUpdateManyWithoutSiteNestedInputSchema)
      .optional(),
    likes: z.lazy(() => LikeUpdateManyWithoutSiteNestedInputSchema).optional(),
    feed: z.lazy(() => FeedUpdateManyWithoutSiteNestedInputSchema).optional()
  })
  .strict();

export const SiteUncheckedUpdateInputSchema: z.ZodType<Prisma.SiteUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      display_name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      font: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      imageBlurhash: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subdomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      customDomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      message404: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      background: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blocks: z
        .lazy(() => BlockUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      subscribers: z
        .lazy(() => SubscriberUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional()
    })
    .strict();

export const SiteCreateManyInputSchema: z.ZodType<Prisma.SiteCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      display_name: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      font: z.string().optional(),
      image: z.string().optional().nullable(),
      imageBlurhash: z.string().optional().nullable(),
      subdomain: z.string().optional().nullable(),
      customDomain: z.string().optional().nullable(),
      message404: z.string().optional().nullable(),
      background: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string()
    })
    .strict();

export const SiteUpdateManyMutationInputSchema: z.ZodType<Prisma.SiteUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      display_name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      font: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      imageBlurhash: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subdomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      customDomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      message404: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      background: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const SiteUncheckedUpdateManyInputSchema: z.ZodType<Prisma.SiteUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      display_name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      font: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      imageBlurhash: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subdomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      customDomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      message404: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      background: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const SubscriberCreateInputSchema: z.ZodType<Prisma.SubscriberCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      site: z.lazy(() => SiteCreateNestedOneWithoutSubscribersInputSchema)
    })
    .strict();

export const SubscriberUncheckedCreateInputSchema: z.ZodType<Prisma.SubscriberUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      siteId: z.string()
    })
    .strict();

export const SubscriberUpdateInputSchema: z.ZodType<Prisma.SubscriberUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      site: z
        .lazy(() => SiteUpdateOneRequiredWithoutSubscribersNestedInputSchema)
        .optional()
    })
    .strict();

export const SubscriberUncheckedUpdateInputSchema: z.ZodType<Prisma.SubscriberUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const SubscriberCreateManyInputSchema: z.ZodType<Prisma.SubscriberCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      siteId: z.string()
    })
    .strict();

export const SubscriberUpdateManyMutationInputSchema: z.ZodType<Prisma.SubscriberUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const SubscriberUncheckedUpdateManyInputSchema: z.ZodType<Prisma.SubscriberUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const ReservationCreateInputSchema: z.ZodType<Prisma.ReservationCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string().optional().nullable(),
      name: z.string().optional().nullable(),
      email: z.string(),
      dateStart: z.coerce.date(),
      dateEnd: z.coerce.date().optional().nullable(),
      comment: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      block: z
        .lazy(() => BlockCreateNestedOneWithoutReservationsInputSchema)
        .optional(),
      affiliate: z
        .lazy(() => UserCreateNestedOneWithoutReservationsInputSchema)
        .optional()
    })
    .strict();

export const ReservationUncheckedCreateInputSchema: z.ZodType<Prisma.ReservationUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string().optional().nullable(),
      name: z.string().optional().nullable(),
      email: z.string(),
      dateStart: z.coerce.date(),
      dateEnd: z.coerce.date().optional().nullable(),
      comment: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      blockId: z.string().optional().nullable(),
      affiliateId: z.string().optional().nullable()
    })
    .strict();

export const ReservationUpdateInputSchema: z.ZodType<Prisma.ReservationUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      dateStart: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      dateEnd: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      comment: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      block: z
        .lazy(() => BlockUpdateOneWithoutReservationsNestedInputSchema)
        .optional(),
      affiliate: z
        .lazy(() => UserUpdateOneWithoutReservationsNestedInputSchema)
        .optional()
    })
    .strict();

export const ReservationUncheckedUpdateInputSchema: z.ZodType<Prisma.ReservationUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      dateStart: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      dateEnd: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      comment: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      affiliateId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ReservationCreateManyInputSchema: z.ZodType<Prisma.ReservationCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string().optional().nullable(),
      name: z.string().optional().nullable(),
      email: z.string(),
      dateStart: z.coerce.date(),
      dateEnd: z.coerce.date().optional().nullable(),
      comment: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      blockId: z.string().optional().nullable(),
      affiliateId: z.string().optional().nullable()
    })
    .strict();

export const ReservationUpdateManyMutationInputSchema: z.ZodType<Prisma.ReservationUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      dateStart: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      dateEnd: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      comment: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const ReservationUncheckedUpdateManyInputSchema: z.ZodType<Prisma.ReservationUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      dateStart: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      dateEnd: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      comment: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      affiliateId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const CategoryCreateInputSchema: z.ZodType<Prisma.CategoryCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      active: z.boolean().optional(),
      position: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      inventories: z
        .lazy(() => InventoryCreateNestedManyWithoutCategoryInputSchema)
        .optional(),
      categories: z
        .lazy(() => CategoryCreateNestedManyWithoutCategoryInputSchema)
        .optional(),
      category: z
        .lazy(() => CategoryCreateNestedOneWithoutCategoriesInputSchema)
        .optional(),
      block: z.lazy(() => BlockCreateNestedOneWithoutCategoriesInputSchema)
    })
    .strict();

export const CategoryUncheckedCreateInputSchema: z.ZodType<Prisma.CategoryUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      active: z.boolean().optional(),
      position: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      categoryId: z.string().optional().nullable(),
      blockId: z.string(),
      inventories: z
        .lazy(
          () => InventoryUncheckedCreateNestedManyWithoutCategoryInputSchema
        )
        .optional(),
      categories: z
        .lazy(() => CategoryUncheckedCreateNestedManyWithoutCategoryInputSchema)
        .optional()
    })
    .strict();

export const CategoryUpdateInputSchema: z.ZodType<Prisma.CategoryUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      inventories: z
        .lazy(() => InventoryUpdateManyWithoutCategoryNestedInputSchema)
        .optional(),
      categories: z
        .lazy(() => CategoryUpdateManyWithoutCategoryNestedInputSchema)
        .optional(),
      category: z
        .lazy(() => CategoryUpdateOneWithoutCategoriesNestedInputSchema)
        .optional(),
      block: z
        .lazy(() => BlockUpdateOneRequiredWithoutCategoriesNestedInputSchema)
        .optional()
    })
    .strict();

export const CategoryUncheckedUpdateInputSchema: z.ZodType<Prisma.CategoryUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      categoryId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      inventories: z
        .lazy(
          () => InventoryUncheckedUpdateManyWithoutCategoryNestedInputSchema
        )
        .optional(),
      categories: z
        .lazy(() => CategoryUncheckedUpdateManyWithoutCategoryNestedInputSchema)
        .optional()
    })
    .strict();

export const CategoryCreateManyInputSchema: z.ZodType<Prisma.CategoryCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      active: z.boolean().optional(),
      position: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      categoryId: z.string().optional().nullable(),
      blockId: z.string()
    })
    .strict();

export const CategoryUpdateManyMutationInputSchema: z.ZodType<Prisma.CategoryUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const CategoryUncheckedUpdateManyInputSchema: z.ZodType<Prisma.CategoryUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      categoryId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const InventoryCreateInputSchema: z.ZodType<Prisma.InventoryCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      sku: z.string().optional().nullable(),
      basePrice: z.number(),
      active: z.boolean().optional(),
      isFeatured: z.boolean().optional(),
      metaTitle: z.string().optional().nullable(),
      metaDescription: z.string().optional().nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryCreatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      category: z
        .lazy(() => CategoryCreateNestedOneWithoutInventoriesInputSchema)
        .optional(),
      variants: z
        .lazy(() => InventoryVariantCreateNestedManyWithoutInventoryInputSchema)
        .optional(),
      block: z.lazy(() => BlockCreateNestedOneWithoutInventoriesInputSchema)
    })
    .strict();

export const InventoryUncheckedCreateInputSchema: z.ZodType<Prisma.InventoryUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      sku: z.string().optional().nullable(),
      basePrice: z.number(),
      active: z.boolean().optional(),
      isFeatured: z.boolean().optional(),
      metaTitle: z.string().optional().nullable(),
      metaDescription: z.string().optional().nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryCreatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      categoryId: z.string().optional().nullable(),
      blockId: z.string(),
      variants: z
        .lazy(
          () =>
            InventoryVariantUncheckedCreateNestedManyWithoutInventoryInputSchema
        )
        .optional()
    })
    .strict();

export const InventoryUpdateInputSchema: z.ZodType<Prisma.InventoryUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      basePrice: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isFeatured: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metaTitle: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      metaDescription: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryUpdatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      category: z
        .lazy(() => CategoryUpdateOneWithoutInventoriesNestedInputSchema)
        .optional(),
      variants: z
        .lazy(() => InventoryVariantUpdateManyWithoutInventoryNestedInputSchema)
        .optional(),
      block: z
        .lazy(() => BlockUpdateOneRequiredWithoutInventoriesNestedInputSchema)
        .optional()
    })
    .strict();

export const InventoryUncheckedUpdateInputSchema: z.ZodType<Prisma.InventoryUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      basePrice: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isFeatured: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metaTitle: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      metaDescription: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryUpdatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      categoryId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      variants: z
        .lazy(
          () =>
            InventoryVariantUncheckedUpdateManyWithoutInventoryNestedInputSchema
        )
        .optional()
    })
    .strict();

export const InventoryCreateManyInputSchema: z.ZodType<Prisma.InventoryCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      sku: z.string().optional().nullable(),
      basePrice: z.number(),
      active: z.boolean().optional(),
      isFeatured: z.boolean().optional(),
      metaTitle: z.string().optional().nullable(),
      metaDescription: z.string().optional().nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryCreatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      categoryId: z.string().optional().nullable(),
      blockId: z.string()
    })
    .strict();

export const InventoryUpdateManyMutationInputSchema: z.ZodType<Prisma.InventoryUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      basePrice: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isFeatured: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metaTitle: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      metaDescription: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryUpdatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const InventoryUncheckedUpdateManyInputSchema: z.ZodType<Prisma.InventoryUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      basePrice: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isFeatured: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metaTitle: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      metaDescription: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryUpdatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      categoryId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const InventoryVariantCreateInputSchema: z.ZodType<Prisma.InventoryVariantCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      value: z.string(),
      type: z.lazy(() => VariantTypeSchema),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional()
        .nullable(),
      stock: z.number().int().optional(),
      active: z.boolean().optional(),
      position: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      inventory: z.lazy(
        () => InventoryCreateNestedOneWithoutVariantsInputSchema
      )
    })
    .strict();

export const InventoryVariantUncheckedCreateInputSchema: z.ZodType<Prisma.InventoryVariantUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      inventoryId: z.string(),
      name: z.string(),
      value: z.string(),
      type: z.lazy(() => VariantTypeSchema),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional()
        .nullable(),
      stock: z.number().int().optional(),
      active: z.boolean().optional(),
      position: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const InventoryVariantUpdateInputSchema: z.ZodType<Prisma.InventoryVariantUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      value: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => VariantTypeSchema),
          z.lazy(() => EnumVariantTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema
            ])
            .refine(v => isValidDecimalInput(v), {
              message: 'Must be a Decimal'
            }),
          z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      stock: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      inventory: z
        .lazy(() => InventoryUpdateOneRequiredWithoutVariantsNestedInputSchema)
        .optional()
    })
    .strict();

export const InventoryVariantUncheckedUpdateInputSchema: z.ZodType<Prisma.InventoryVariantUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      inventoryId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      value: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => VariantTypeSchema),
          z.lazy(() => EnumVariantTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema
            ])
            .refine(v => isValidDecimalInput(v), {
              message: 'Must be a Decimal'
            }),
          z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      stock: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const InventoryVariantCreateManyInputSchema: z.ZodType<Prisma.InventoryVariantCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      inventoryId: z.string(),
      name: z.string(),
      value: z.string(),
      type: z.lazy(() => VariantTypeSchema),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional()
        .nullable(),
      stock: z.number().int().optional(),
      active: z.boolean().optional(),
      position: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const InventoryVariantUpdateManyMutationInputSchema: z.ZodType<Prisma.InventoryVariantUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      value: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => VariantTypeSchema),
          z.lazy(() => EnumVariantTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema
            ])
            .refine(v => isValidDecimalInput(v), {
              message: 'Must be a Decimal'
            }),
          z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      stock: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const InventoryVariantUncheckedUpdateManyInputSchema: z.ZodType<Prisma.InventoryVariantUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      inventoryId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      value: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => VariantTypeSchema),
          z.lazy(() => EnumVariantTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema
            ])
            .refine(v => isValidDecimalInput(v), {
              message: 'Must be a Decimal'
            }),
          z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      stock: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const CronCreateInputSchema: z.ZodType<Prisma.CronCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    name: z.string(),
    cronExpr: z.string(),
    timezone: z.string().optional(),
    modulePath: z.string(),
    functionName: z.string(),
    enabled: z.boolean().optional(),
    lastRunAt: z.coerce.date().optional().nullable(),
    lastStatus: z.string().optional().nullable(),
    lastDurationMs: z.number().int().optional().nullable(),
    lockedAt: z.coerce.date().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    history: z
      .lazy(() => HistoryCreateNestedManyWithoutCronInputSchema)
      .optional()
  })
  .strict();

export const CronUncheckedCreateInputSchema: z.ZodType<Prisma.CronUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      cronExpr: z.string(),
      timezone: z.string().optional(),
      modulePath: z.string(),
      functionName: z.string(),
      enabled: z.boolean().optional(),
      lastRunAt: z.coerce.date().optional().nullable(),
      lastStatus: z.string().optional().nullable(),
      lastDurationMs: z.number().int().optional().nullable(),
      lockedAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      history: z
        .lazy(() => HistoryUncheckedCreateNestedManyWithoutCronInputSchema)
        .optional()
    })
    .strict();

export const CronUpdateInputSchema: z.ZodType<Prisma.CronUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().cuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    name: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    cronExpr: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    timezone: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    modulePath: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    functionName: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    enabled: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    lastRunAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    lastStatus: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    lastDurationMs: z
      .union([
        z.number().int(),
        z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    lockedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    history: z
      .lazy(() => HistoryUpdateManyWithoutCronNestedInputSchema)
      .optional()
  })
  .strict();

export const CronUncheckedUpdateInputSchema: z.ZodType<Prisma.CronUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      cronExpr: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      timezone: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      modulePath: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      functionName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      enabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      lastRunAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      lastStatus: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      lastDurationMs: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      lockedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      history: z
        .lazy(() => HistoryUncheckedUpdateManyWithoutCronNestedInputSchema)
        .optional()
    })
    .strict();

export const CronCreateManyInputSchema: z.ZodType<Prisma.CronCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      cronExpr: z.string(),
      timezone: z.string().optional(),
      modulePath: z.string(),
      functionName: z.string(),
      enabled: z.boolean().optional(),
      lastRunAt: z.coerce.date().optional().nullable(),
      lastStatus: z.string().optional().nullable(),
      lastDurationMs: z.number().int().optional().nullable(),
      lockedAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const CronUpdateManyMutationInputSchema: z.ZodType<Prisma.CronUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      cronExpr: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      timezone: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      modulePath: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      functionName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      enabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      lastRunAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      lastStatus: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      lastDurationMs: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      lockedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const CronUncheckedUpdateManyInputSchema: z.ZodType<Prisma.CronUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      cronExpr: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      timezone: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      modulePath: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      functionName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      enabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      lastRunAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      lastStatus: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      lastDurationMs: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      lockedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const HistoryCreateInputSchema: z.ZodType<Prisma.HistoryCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    status: z.string(),
    startedAt: z.coerce.date(),
    endedAt: z.coerce.date(),
    durationMs: z.number().int(),
    message: z
      .union([
        z.lazy(() => NullableJsonNullValueInputSchema),
        InputJsonValueSchema
      ])
      .optional(),
    createdAt: z.coerce.date().optional(),
    cron: z.lazy(() => CronCreateNestedOneWithoutHistoryInputSchema)
  })
  .strict();

export const HistoryUncheckedCreateInputSchema: z.ZodType<Prisma.HistoryUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.string(),
      startedAt: z.coerce.date(),
      endedAt: z.coerce.date(),
      durationMs: z.number().int(),
      message: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      cronId: z.string(),
      createdAt: z.coerce.date().optional()
    })
    .strict();

export const HistoryUpdateInputSchema: z.ZodType<Prisma.HistoryUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().cuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    status: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    startedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    endedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    durationMs: z
      .union([
        z.number().int(),
        z.lazy(() => IntFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    message: z
      .union([
        z.lazy(() => NullableJsonNullValueInputSchema),
        InputJsonValueSchema
      ])
      .optional(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    cron: z
      .lazy(() => CronUpdateOneRequiredWithoutHistoryNestedInputSchema)
      .optional()
  })
  .strict();

export const HistoryUncheckedUpdateInputSchema: z.ZodType<Prisma.HistoryUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      startedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      endedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      durationMs: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      message: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      cronId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const HistoryCreateManyInputSchema: z.ZodType<Prisma.HistoryCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.string(),
      startedAt: z.coerce.date(),
      endedAt: z.coerce.date(),
      durationMs: z.number().int(),
      message: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      cronId: z.string(),
      createdAt: z.coerce.date().optional()
    })
    .strict();

export const HistoryUpdateManyMutationInputSchema: z.ZodType<Prisma.HistoryUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      startedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      endedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      durationMs: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      message: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const HistoryUncheckedUpdateManyInputSchema: z.ZodType<Prisma.HistoryUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      startedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      endedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      durationMs: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      message: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      cronId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserCreateInputSchema: z.ZodType<Prisma.UserCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    name: z.string().optional().nullable(),
    email: z.string(),
    emailVerified: z.boolean().optional(),
    image: z.string().optional().nullable(),
    isTwoFactorEnabled: z.boolean().optional(),
    billing_address: z
      .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
      .optional(),
    payment_method: z
      .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
      .optional(),
    company: z.string().optional().nullable(),
    address: z.string().optional().nullable(),
    location: z
      .union([
        z.lazy(() => NullableJsonNullValueInputSchema),
        InputJsonValueSchema
      ])
      .optional(),
    postcode: z.string().optional().nullable(),
    city: z.string().optional().nullable(),
    phone: z.string().optional().nullable(),
    activity: z.string().optional().nullable(),
    bounced: z.number().int().optional(),
    affiliateRate: z.number().optional().nullable(),
    isAnonymous: z.boolean().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    role: z.lazy(() => UserRoleSchema).optional(),
    accounts: z
      .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
      .optional(),
    sessions: z
      .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
      .optional(),
    sites: z.lazy(() => SiteCreateNestedManyWithoutUserInputSchema).optional(),
    subscriptions: z
      .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
      .optional(),
    authenticator: z
      .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
      .optional(),
    links: z.lazy(() => LinkCreateNestedManyWithoutUserInputSchema).optional(),
    customer: z
      .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
      .optional(),
    twoFactorConfirmation: z
      .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
      .optional(),
    referer: z
      .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
      .optional(),
    naf: z.lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema).optional(),
    feedback: z
      .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
      .optional(),
    likes: z.lazy(() => LikeCreateNestedManyWithoutUserInputSchema).optional(),
    affiliates: z
      .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
      .optional(),
    events: z
      .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
      .optional(),
    workflowStates: z
      .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
      .optional(),
    executions: z
      .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
      .optional(),
    jobs: z.lazy(() => QueueCreateNestedManyWithoutUserInputSchema).optional(),
    outbox: z
      .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
      .optional(),
    feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
    comments: z
      .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
      .optional(),
    sent: z
      .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
      .optional(),
    received: z
      .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
      .optional(),
    reservations: z
      .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
      .optional(),
    lists: z
      .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
      .optional(),
    listsManage: z
      .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
      .optional(),
    emails: z
      .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
      .optional(),
    clicks: z
      .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
      .optional(),
    referrals: z
      .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
      .optional()
  })
  .strict();

export const UserUncheckedCreateInputSchema: z.ZodType<Prisma.UserUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUpdateInputSchema: z.ZodType<Prisma.UserUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().cuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    name: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    email: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    emailVerified: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    image: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    isTwoFactorEnabled: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    billing_address: z
      .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
      .optional(),
    payment_method: z
      .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
      .optional(),
    company: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    address: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    location: z
      .union([
        z.lazy(() => NullableJsonNullValueInputSchema),
        InputJsonValueSchema
      ])
      .optional(),
    postcode: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    city: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    phone: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    activity: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    bounced: z
      .union([
        z.number().int(),
        z.lazy(() => IntFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    affiliateRate: z
      .union([
        z.number(),
        z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    isAnonymous: z
      .union([
        z.boolean(),
        z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    role: z
      .union([
        z.lazy(() => UserRoleSchema),
        z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    accounts: z
      .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    sessions: z
      .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    sites: z.lazy(() => SiteUpdateManyWithoutUserNestedInputSchema).optional(),
    subscriptions: z
      .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    authenticator: z
      .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    links: z.lazy(() => LinkUpdateManyWithoutUserNestedInputSchema).optional(),
    customer: z
      .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
      .optional(),
    twoFactorConfirmation: z
      .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
      .optional(),
    referer: z
      .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
      .optional(),
    naf: z.lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema).optional(),
    feedback: z
      .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    likes: z.lazy(() => LikeUpdateManyWithoutUserNestedInputSchema).optional(),
    affiliates: z
      .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
      .optional(),
    events: z
      .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    workflowStates: z
      .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    executions: z
      .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    jobs: z.lazy(() => QueueUpdateManyWithoutUserNestedInputSchema).optional(),
    outbox: z
      .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
    comments: z
      .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    sent: z
      .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
      .optional(),
    received: z
      .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
      .optional(),
    reservations: z
      .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
      .optional(),
    lists: z
      .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
      .optional(),
    listsManage: z
      .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
      .optional(),
    emails: z
      .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    clicks: z
      .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    referrals: z
      .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
      .optional()
  })
  .strict();

export const UserUncheckedUpdateInputSchema: z.ZodType<Prisma.UserUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserCreateManyInputSchema: z.ZodType<Prisma.UserCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable()
    })
    .strict();

export const UserUpdateManyMutationInputSchema: z.ZodType<Prisma.UserUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserUncheckedUpdateManyInputSchema: z.ZodType<Prisma.UserUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const MessageCreateInputSchema: z.ZodType<Prisma.MessageCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    content: z.string(),
    createdAt: z.coerce.date().optional(),
    sender: z.lazy(() => UserCreateNestedOneWithoutSentInputSchema),
    receiver: z.lazy(() => UserCreateNestedOneWithoutReceivedInputSchema)
  })
  .strict();

export const MessageUncheckedCreateInputSchema: z.ZodType<Prisma.MessageUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      content: z.string(),
      createdAt: z.coerce.date().optional(),
      senderEmail: z.string(),
      receiveEmail: z.string()
    })
    .strict();

export const MessageUpdateInputSchema: z.ZodType<Prisma.MessageUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().cuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    content: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    sender: z
      .lazy(() => UserUpdateOneRequiredWithoutSentNestedInputSchema)
      .optional(),
    receiver: z
      .lazy(() => UserUpdateOneRequiredWithoutReceivedNestedInputSchema)
      .optional()
  })
  .strict();

export const MessageUncheckedUpdateInputSchema: z.ZodType<Prisma.MessageUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      senderEmail: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      receiveEmail: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const MessageCreateManyInputSchema: z.ZodType<Prisma.MessageCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      content: z.string(),
      createdAt: z.coerce.date().optional(),
      senderEmail: z.string(),
      receiveEmail: z.string()
    })
    .strict();

export const MessageUpdateManyMutationInputSchema: z.ZodType<Prisma.MessageUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const MessageUncheckedUpdateManyInputSchema: z.ZodType<Prisma.MessageUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      senderEmail: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      receiveEmail: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const FeedbackCreateInputSchema: z.ZodType<Prisma.FeedbackCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      message: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      user: z
        .lazy(() => UserCreateNestedOneWithoutFeedbackInputSchema)
        .optional()
    })
    .strict();

export const FeedbackUncheckedCreateInputSchema: z.ZodType<Prisma.FeedbackUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      message: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string().optional().nullable()
    })
    .strict();

export const FeedbackUpdateInputSchema: z.ZodType<Prisma.FeedbackUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      message: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      user: z
        .lazy(() => UserUpdateOneWithoutFeedbackNestedInputSchema)
        .optional()
    })
    .strict();

export const FeedbackUncheckedUpdateInputSchema: z.ZodType<Prisma.FeedbackUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      message: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const FeedbackCreateManyInputSchema: z.ZodType<Prisma.FeedbackCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      message: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string().optional().nullable()
    })
    .strict();

export const FeedbackUpdateManyMutationInputSchema: z.ZodType<Prisma.FeedbackUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      message: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const FeedbackUncheckedUpdateManyInputSchema: z.ZodType<Prisma.FeedbackUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      message: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const QueueCreateInputSchema: z.ZodType<Prisma.QueueCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    job: z.string().optional(),
    payload: z
      .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
      .optional(),
    status: z.string().optional(),
    attempts: z.number().int().optional(),
    lastError: z.string().optional().nullable(),
    runAt: z.coerce.date().optional(),
    priority: z.number().int().optional(),
    processingStartedAt: z.coerce.date().optional().nullable(),
    correlationId: z.string().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    user: z.lazy(() => UserCreateNestedOneWithoutJobsInputSchema).optional()
  })
  .strict();

export const QueueUncheckedCreateInputSchema: z.ZodType<Prisma.QueueUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      job: z.string().optional(),
      payload: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      status: z.string().optional(),
      attempts: z.number().int().optional(),
      lastError: z.string().optional().nullable(),
      runAt: z.coerce.date().optional(),
      priority: z.number().int().optional(),
      processingStartedAt: z.coerce.date().optional().nullable(),
      correlationId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string().optional().nullable()
    })
    .strict();

export const QueueUpdateInputSchema: z.ZodType<Prisma.QueueUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().cuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    job: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    payload: z
      .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
      .optional(),
    status: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    attempts: z
      .union([
        z.number().int(),
        z.lazy(() => IntFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    lastError: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    runAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    priority: z
      .union([
        z.number().int(),
        z.lazy(() => IntFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    processingStartedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    correlationId: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    user: z.lazy(() => UserUpdateOneWithoutJobsNestedInputSchema).optional()
  })
  .strict();

export const QueueUncheckedUpdateInputSchema: z.ZodType<Prisma.QueueUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      job: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      payload: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      attempts: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      lastError: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      runAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      priority: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      processingStartedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const QueueCreateManyInputSchema: z.ZodType<Prisma.QueueCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      job: z.string().optional(),
      payload: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      status: z.string().optional(),
      attempts: z.number().int().optional(),
      lastError: z.string().optional().nullable(),
      runAt: z.coerce.date().optional(),
      priority: z.number().int().optional(),
      processingStartedAt: z.coerce.date().optional().nullable(),
      correlationId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string().optional().nullable()
    })
    .strict();

export const QueueUpdateManyMutationInputSchema: z.ZodType<Prisma.QueueUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      job: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      payload: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      attempts: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      lastError: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      runAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      priority: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      processingStartedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const QueueUncheckedUpdateManyInputSchema: z.ZodType<Prisma.QueueUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      job: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      payload: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      attempts: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      lastError: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      runAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      priority: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      processingStartedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ActionCreateInputSchema: z.ZodType<Prisma.ActionCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    code: z.string(),
    description: z.string().optional().nullable(),
    type: z.string(),
    config: z.union([
      z.lazy(() => JsonNullValueInputSchema),
      InputJsonValueSchema
    ]),
    isPublished: z.boolean().optional(),
    version: z.number().int().optional(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    rules: z
      .lazy(() => RuleCreateNestedManyWithoutActionInputSchema)
      .optional(),
    executions: z
      .lazy(() => ExecutionCreateNestedManyWithoutActionInputSchema)
      .optional()
  })
  .strict();

export const ActionUncheckedCreateInputSchema: z.ZodType<Prisma.ActionUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      code: z.string(),
      description: z.string().optional().nullable(),
      type: z.string(),
      config: z.union([
        z.lazy(() => JsonNullValueInputSchema),
        InputJsonValueSchema
      ]),
      isPublished: z.boolean().optional(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      rules: z
        .lazy(() => RuleUncheckedCreateNestedManyWithoutActionInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutActionInputSchema)
        .optional()
    })
    .strict();

export const ActionUpdateInputSchema: z.ZodType<Prisma.ActionUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().cuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    code: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    description: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    type: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    config: z
      .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
      .optional(),
    isPublished: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    version: z
      .union([
        z.number().int(),
        z.lazy(() => IntFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    rules: z
      .lazy(() => RuleUpdateManyWithoutActionNestedInputSchema)
      .optional(),
    executions: z
      .lazy(() => ExecutionUpdateManyWithoutActionNestedInputSchema)
      .optional()
  })
  .strict();

export const ActionUncheckedUpdateInputSchema: z.ZodType<Prisma.ActionUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      code: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      config: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      isPublished: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      rules: z
        .lazy(() => RuleUncheckedUpdateManyWithoutActionNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutActionNestedInputSchema)
        .optional()
    })
    .strict();

export const ActionCreateManyInputSchema: z.ZodType<Prisma.ActionCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      code: z.string(),
      description: z.string().optional().nullable(),
      type: z.string(),
      config: z.union([
        z.lazy(() => JsonNullValueInputSchema),
        InputJsonValueSchema
      ]),
      isPublished: z.boolean().optional(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const ActionUpdateManyMutationInputSchema: z.ZodType<Prisma.ActionUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      code: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      config: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      isPublished: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const ActionUncheckedUpdateManyInputSchema: z.ZodType<Prisma.ActionUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      code: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      config: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      isPublished: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const WorkflowCreateInputSchema: z.ZodType<Prisma.WorkflowCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      isDefault: z.boolean().optional(),
      isActive: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      rules: z
        .lazy(() => RuleCreateNestedManyWithoutWorkflowInputSchema)
        .optional(),
      states: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutWorkflowInputSchema)
        .optional()
    })
    .strict();

export const WorkflowUncheckedCreateInputSchema: z.ZodType<Prisma.WorkflowUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      isDefault: z.boolean().optional(),
      isActive: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      rules: z
        .lazy(() => RuleUncheckedCreateNestedManyWithoutWorkflowInputSchema)
        .optional(),
      states: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutWorkflowInputSchema
        )
        .optional()
    })
    .strict();

export const WorkflowUpdateInputSchema: z.ZodType<Prisma.WorkflowUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isDefault: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      rules: z
        .lazy(() => RuleUpdateManyWithoutWorkflowNestedInputSchema)
        .optional(),
      states: z
        .lazy(() => WorkflowStateUpdateManyWithoutWorkflowNestedInputSchema)
        .optional()
    })
    .strict();

export const WorkflowUncheckedUpdateInputSchema: z.ZodType<Prisma.WorkflowUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isDefault: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      rules: z
        .lazy(() => RuleUncheckedUpdateManyWithoutWorkflowNestedInputSchema)
        .optional(),
      states: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutWorkflowNestedInputSchema
        )
        .optional()
    })
    .strict();

export const WorkflowCreateManyInputSchema: z.ZodType<Prisma.WorkflowCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      isDefault: z.boolean().optional(),
      isActive: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const WorkflowUpdateManyMutationInputSchema: z.ZodType<Prisma.WorkflowUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isDefault: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const WorkflowUncheckedUpdateManyInputSchema: z.ZodType<Prisma.WorkflowUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isDefault: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const TriggerCreateInputSchema: z.ZodType<Prisma.TriggerCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    code: z.string(),
    description: z.string().optional().nullable(),
    rules: z
      .lazy(() => RuleCreateNestedManyWithoutTriggerInputSchema)
      .optional()
  })
  .strict();

export const TriggerUncheckedCreateInputSchema: z.ZodType<Prisma.TriggerUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      code: z.string(),
      description: z.string().optional().nullable(),
      rules: z
        .lazy(() => RuleUncheckedCreateNestedManyWithoutTriggerInputSchema)
        .optional()
    })
    .strict();

export const TriggerUpdateInputSchema: z.ZodType<Prisma.TriggerUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().cuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    code: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    description: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    rules: z
      .lazy(() => RuleUpdateManyWithoutTriggerNestedInputSchema)
      .optional()
  })
  .strict();

export const TriggerUncheckedUpdateInputSchema: z.ZodType<Prisma.TriggerUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      code: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      rules: z
        .lazy(() => RuleUncheckedUpdateManyWithoutTriggerNestedInputSchema)
        .optional()
    })
    .strict();

export const TriggerCreateManyInputSchema: z.ZodType<Prisma.TriggerCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      code: z.string(),
      description: z.string().optional().nullable()
    })
    .strict();

export const TriggerUpdateManyMutationInputSchema: z.ZodType<Prisma.TriggerUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      code: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const TriggerUncheckedUpdateManyInputSchema: z.ZodType<Prisma.TriggerUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      code: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const RuleCreateInputSchema: z.ZodType<Prisma.RuleCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    delayMinutes: z.number().int().optional(),
    order: z.number().int().optional(),
    isActive: z.boolean().optional(),
    version: z.number().int().optional(),
    ruleConditions: z
      .lazy(() => RuleConditionCreateNestedManyWithoutRuleInputSchema)
      .optional(),
    workflow: z.lazy(() => WorkflowCreateNestedOneWithoutRulesInputSchema),
    action: z.lazy(() => ActionCreateNestedOneWithoutRulesInputSchema),
    trigger: z.lazy(() => TriggerCreateNestedOneWithoutRulesInputSchema),
    executions: z
      .lazy(() => ExecutionCreateNestedManyWithoutRuleInputSchema)
      .optional()
  })
  .strict();

export const RuleUncheckedCreateInputSchema: z.ZodType<Prisma.RuleUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      workflowId: z.string(),
      actionId: z.string(),
      triggerId: z.string(),
      delayMinutes: z.number().int().optional(),
      order: z.number().int().optional(),
      isActive: z.boolean().optional(),
      version: z.number().int().optional(),
      ruleConditions: z
        .lazy(
          () => RuleConditionUncheckedCreateNestedManyWithoutRuleInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutRuleInputSchema)
        .optional()
    })
    .strict();

export const RuleUpdateInputSchema: z.ZodType<Prisma.RuleUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().cuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    delayMinutes: z
      .union([
        z.number().int(),
        z.lazy(() => IntFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    order: z
      .union([
        z.number().int(),
        z.lazy(() => IntFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    isActive: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    version: z
      .union([
        z.number().int(),
        z.lazy(() => IntFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    ruleConditions: z
      .lazy(() => RuleConditionUpdateManyWithoutRuleNestedInputSchema)
      .optional(),
    workflow: z
      .lazy(() => WorkflowUpdateOneRequiredWithoutRulesNestedInputSchema)
      .optional(),
    action: z
      .lazy(() => ActionUpdateOneRequiredWithoutRulesNestedInputSchema)
      .optional(),
    trigger: z
      .lazy(() => TriggerUpdateOneRequiredWithoutRulesNestedInputSchema)
      .optional(),
    executions: z
      .lazy(() => ExecutionUpdateManyWithoutRuleNestedInputSchema)
      .optional()
  })
  .strict();

export const RuleUncheckedUpdateInputSchema: z.ZodType<Prisma.RuleUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      workflowId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      actionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      triggerId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      delayMinutes: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      order: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ruleConditions: z
        .lazy(
          () => RuleConditionUncheckedUpdateManyWithoutRuleNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutRuleNestedInputSchema)
        .optional()
    })
    .strict();

export const RuleCreateManyInputSchema: z.ZodType<Prisma.RuleCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      workflowId: z.string(),
      actionId: z.string(),
      triggerId: z.string(),
      delayMinutes: z.number().int().optional(),
      order: z.number().int().optional(),
      isActive: z.boolean().optional(),
      version: z.number().int().optional()
    })
    .strict();

export const RuleUpdateManyMutationInputSchema: z.ZodType<Prisma.RuleUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      delayMinutes: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      order: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const RuleUncheckedUpdateManyInputSchema: z.ZodType<Prisma.RuleUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      workflowId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      actionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      triggerId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      delayMinutes: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      order: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const ConditionCreateInputSchema: z.ZodType<Prisma.ConditionCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      type: z.lazy(() => ConditionTypeSchema),
      parameters: z.union([
        z.lazy(() => JsonNullValueInputSchema),
        InputJsonValueSchema
      ]),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      rules: z
        .lazy(() => RuleConditionCreateNestedManyWithoutConditionInputSchema)
        .optional()
    })
    .strict();

export const ConditionUncheckedCreateInputSchema: z.ZodType<Prisma.ConditionUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      type: z.lazy(() => ConditionTypeSchema),
      parameters: z.union([
        z.lazy(() => JsonNullValueInputSchema),
        InputJsonValueSchema
      ]),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      rules: z
        .lazy(
          () =>
            RuleConditionUncheckedCreateNestedManyWithoutConditionInputSchema
        )
        .optional()
    })
    .strict();

export const ConditionUpdateInputSchema: z.ZodType<Prisma.ConditionUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => ConditionTypeSchema),
          z.lazy(() => EnumConditionTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      parameters: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      rules: z
        .lazy(() => RuleConditionUpdateManyWithoutConditionNestedInputSchema)
        .optional()
    })
    .strict();

export const ConditionUncheckedUpdateInputSchema: z.ZodType<Prisma.ConditionUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => ConditionTypeSchema),
          z.lazy(() => EnumConditionTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      parameters: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      rules: z
        .lazy(
          () =>
            RuleConditionUncheckedUpdateManyWithoutConditionNestedInputSchema
        )
        .optional()
    })
    .strict();

export const ConditionCreateManyInputSchema: z.ZodType<Prisma.ConditionCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      type: z.lazy(() => ConditionTypeSchema),
      parameters: z.union([
        z.lazy(() => JsonNullValueInputSchema),
        InputJsonValueSchema
      ]),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const ConditionUpdateManyMutationInputSchema: z.ZodType<Prisma.ConditionUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => ConditionTypeSchema),
          z.lazy(() => EnumConditionTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      parameters: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const ConditionUncheckedUpdateManyInputSchema: z.ZodType<Prisma.ConditionUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => ConditionTypeSchema),
          z.lazy(() => EnumConditionTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      parameters: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const RuleConditionCreateInputSchema: z.ZodType<Prisma.RuleConditionCreateInput> =
  z
    .object({
      group: z.number().int().optional(),
      logic: z.lazy(() => OperatorSchema).optional(),
      rule: z.lazy(() => RuleCreateNestedOneWithoutRuleConditionsInputSchema),
      condition: z.lazy(() => ConditionCreateNestedOneWithoutRulesInputSchema)
    })
    .strict();

export const RuleConditionUncheckedCreateInputSchema: z.ZodType<Prisma.RuleConditionUncheckedCreateInput> =
  z
    .object({
      ruleId: z.string(),
      conditionId: z.string(),
      group: z.number().int().optional(),
      logic: z.lazy(() => OperatorSchema).optional()
    })
    .strict();

export const RuleConditionUpdateInputSchema: z.ZodType<Prisma.RuleConditionUpdateInput> =
  z
    .object({
      group: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      logic: z
        .union([
          z.lazy(() => OperatorSchema),
          z.lazy(() => EnumOperatorFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      rule: z
        .lazy(() => RuleUpdateOneRequiredWithoutRuleConditionsNestedInputSchema)
        .optional(),
      condition: z
        .lazy(() => ConditionUpdateOneRequiredWithoutRulesNestedInputSchema)
        .optional()
    })
    .strict();

export const RuleConditionUncheckedUpdateInputSchema: z.ZodType<Prisma.RuleConditionUncheckedUpdateInput> =
  z
    .object({
      ruleId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      conditionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      group: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      logic: z
        .union([
          z.lazy(() => OperatorSchema),
          z.lazy(() => EnumOperatorFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const RuleConditionCreateManyInputSchema: z.ZodType<Prisma.RuleConditionCreateManyInput> =
  z
    .object({
      ruleId: z.string(),
      conditionId: z.string(),
      group: z.number().int().optional(),
      logic: z.lazy(() => OperatorSchema).optional()
    })
    .strict();

export const RuleConditionUpdateManyMutationInputSchema: z.ZodType<Prisma.RuleConditionUpdateManyMutationInput> =
  z
    .object({
      group: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      logic: z
        .union([
          z.lazy(() => OperatorSchema),
          z.lazy(() => EnumOperatorFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const RuleConditionUncheckedUpdateManyInputSchema: z.ZodType<Prisma.RuleConditionUncheckedUpdateManyInput> =
  z
    .object({
      ruleId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      conditionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      group: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      logic: z
        .union([
          z.lazy(() => OperatorSchema),
          z.lazy(() => EnumOperatorFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const EventCreateInputSchema: z.ZodType<Prisma.EventCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    eventType: z.string(),
    payload: z
      .union([
        z.lazy(() => NullableJsonNullValueInputSchema),
        InputJsonValueSchema
      ])
      .optional(),
    correlationId: z.string().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    status: z.string().optional(),
    attempts: z.number().int().optional(),
    lastError: z.string().optional().nullable(),
    user: z.lazy(() => UserCreateNestedOneWithoutEventsInputSchema)
  })
  .strict();

export const EventUncheckedCreateInputSchema: z.ZodType<Prisma.EventUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      userId: z.string(),
      eventType: z.string(),
      payload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      status: z.string().optional(),
      attempts: z.number().int().optional(),
      lastError: z.string().optional().nullable()
    })
    .strict();

export const EventUpdateInputSchema: z.ZodType<Prisma.EventUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().cuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    eventType: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    payload: z
      .union([
        z.lazy(() => NullableJsonNullValueInputSchema),
        InputJsonValueSchema
      ])
      .optional(),
    correlationId: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    status: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    attempts: z
      .union([
        z.number().int(),
        z.lazy(() => IntFieldUpdateOperationsInputSchema)
      ])
      .optional(),
    lastError: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
      ])
      .optional()
      .nullable(),
    user: z
      .lazy(() => UserUpdateOneRequiredWithoutEventsNestedInputSchema)
      .optional()
  })
  .strict();

export const EventUncheckedUpdateInputSchema: z.ZodType<Prisma.EventUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      eventType: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      payload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      attempts: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      lastError: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const EventCreateManyInputSchema: z.ZodType<Prisma.EventCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      userId: z.string(),
      eventType: z.string(),
      payload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      status: z.string().optional(),
      attempts: z.number().int().optional(),
      lastError: z.string().optional().nullable()
    })
    .strict();

export const EventUpdateManyMutationInputSchema: z.ZodType<Prisma.EventUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      eventType: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      payload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      attempts: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      lastError: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const EventUncheckedUpdateManyInputSchema: z.ZodType<Prisma.EventUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      eventType: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      payload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      attempts: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      lastError: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const WorkflowStateCreateInputSchema: z.ZodType<Prisma.WorkflowStateCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.lazy(() => WorkflowStateStatusSchema).optional(),
      startedAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutWorkflowStatesInputSchema),
      workflow: z.lazy(() => WorkflowCreateNestedOneWithoutStatesInputSchema)
    })
    .strict();

export const WorkflowStateUncheckedCreateInputSchema: z.ZodType<Prisma.WorkflowStateUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      userId: z.string(),
      workflowId: z.string(),
      status: z.lazy(() => WorkflowStateStatusSchema).optional(),
      startedAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const WorkflowStateUpdateInputSchema: z.ZodType<Prisma.WorkflowStateUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => WorkflowStateStatusSchema),
          z.lazy(() => EnumWorkflowStateStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      startedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutWorkflowStatesNestedInputSchema)
        .optional(),
      workflow: z
        .lazy(() => WorkflowUpdateOneRequiredWithoutStatesNestedInputSchema)
        .optional()
    })
    .strict();

export const WorkflowStateUncheckedUpdateInputSchema: z.ZodType<Prisma.WorkflowStateUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      workflowId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => WorkflowStateStatusSchema),
          z.lazy(() => EnumWorkflowStateStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      startedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const WorkflowStateCreateManyInputSchema: z.ZodType<Prisma.WorkflowStateCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      userId: z.string(),
      workflowId: z.string(),
      status: z.lazy(() => WorkflowStateStatusSchema).optional(),
      startedAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const WorkflowStateUpdateManyMutationInputSchema: z.ZodType<Prisma.WorkflowStateUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => WorkflowStateStatusSchema),
          z.lazy(() => EnumWorkflowStateStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      startedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const WorkflowStateUncheckedUpdateManyInputSchema: z.ZodType<Prisma.WorkflowStateUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      workflowId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => WorkflowStateStatusSchema),
          z.lazy(() => EnumWorkflowStateStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      startedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const ExecutionCreateInputSchema: z.ZodType<Prisma.ExecutionCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      executedAt: z.coerce.date().optional().nullable(),
      status: z.lazy(() => ExecutionStatusSchema).optional(),
      errorMessage: z.string().optional().nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z.string().optional().nullable(),
      user: z.lazy(() => UserCreateNestedOneWithoutExecutionsInputSchema),
      action: z.lazy(() => ActionCreateNestedOneWithoutExecutionsInputSchema),
      rule: z
        .lazy(() => RuleCreateNestedOneWithoutExecutionsInputSchema)
        .optional()
    })
    .strict();

export const ExecutionUncheckedCreateInputSchema: z.ZodType<Prisma.ExecutionUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      userId: z.string(),
      actionId: z.string(),
      ruleId: z.string().optional().nullable(),
      executedAt: z.coerce.date().optional().nullable(),
      status: z.lazy(() => ExecutionStatusSchema).optional(),
      errorMessage: z.string().optional().nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z.string().optional().nullable()
    })
    .strict();

export const ExecutionUpdateInputSchema: z.ZodType<Prisma.ExecutionUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      executedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ExecutionStatusSchema),
          z.lazy(() => EnumExecutionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      errorMessage: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutExecutionsNestedInputSchema)
        .optional(),
      action: z
        .lazy(() => ActionUpdateOneRequiredWithoutExecutionsNestedInputSchema)
        .optional(),
      rule: z
        .lazy(() => RuleUpdateOneWithoutExecutionsNestedInputSchema)
        .optional()
    })
    .strict();

export const ExecutionUncheckedUpdateInputSchema: z.ZodType<Prisma.ExecutionUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      actionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ruleId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      executedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ExecutionStatusSchema),
          z.lazy(() => EnumExecutionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      errorMessage: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ExecutionCreateManyInputSchema: z.ZodType<Prisma.ExecutionCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      userId: z.string(),
      actionId: z.string(),
      ruleId: z.string().optional().nullable(),
      executedAt: z.coerce.date().optional().nullable(),
      status: z.lazy(() => ExecutionStatusSchema).optional(),
      errorMessage: z.string().optional().nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z.string().optional().nullable()
    })
    .strict();

export const ExecutionUpdateManyMutationInputSchema: z.ZodType<Prisma.ExecutionUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      executedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ExecutionStatusSchema),
          z.lazy(() => EnumExecutionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      errorMessage: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ExecutionUncheckedUpdateManyInputSchema: z.ZodType<Prisma.ExecutionUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      actionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ruleId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      executedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ExecutionStatusSchema),
          z.lazy(() => EnumExecutionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      errorMessage: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const StringFilterSchema: z.ZodType<Prisma.StringFilter> = z
  .object({
    equals: z.string().optional(),
    in: z.string().array().optional(),
    notIn: z.string().array().optional(),
    lt: z.string().optional(),
    lte: z.string().optional(),
    gt: z.string().optional(),
    gte: z.string().optional(),
    contains: z.string().optional(),
    startsWith: z.string().optional(),
    endsWith: z.string().optional(),
    mode: z.lazy(() => QueryModeSchema).optional(),
    not: z
      .union([z.string(), z.lazy(() => NestedStringFilterSchema)])
      .optional()
  })
  .strict();

export const UserScalarRelationFilterSchema: z.ZodType<Prisma.UserScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => UserWhereInputSchema).optional(),
      isNot: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const TwoFactorConfirmationCountOrderByAggregateInputSchema: z.ZodType<Prisma.TwoFactorConfirmationCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const TwoFactorConfirmationMaxOrderByAggregateInputSchema: z.ZodType<Prisma.TwoFactorConfirmationMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const TwoFactorConfirmationMinOrderByAggregateInputSchema: z.ZodType<Prisma.TwoFactorConfirmationMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const StringWithAggregatesFilterSchema: z.ZodType<Prisma.StringWithAggregatesFilter> =
  z
    .object({
      equals: z.string().optional(),
      in: z.string().array().optional(),
      notIn: z.string().array().optional(),
      lt: z.string().optional(),
      lte: z.string().optional(),
      gt: z.string().optional(),
      gte: z.string().optional(),
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      mode: z.lazy(() => QueryModeSchema).optional(),
      not: z
        .union([
          z.string(),
          z.lazy(() => NestedStringWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedStringFilterSchema).optional(),
      _max: z.lazy(() => NestedStringFilterSchema).optional()
    })
    .strict();

export const StringNullableFilterSchema: z.ZodType<Prisma.StringNullableFilter> =
  z
    .object({
      equals: z.string().optional().nullable(),
      in: z.string().array().optional().nullable(),
      notIn: z.string().array().optional().nullable(),
      lt: z.string().optional(),
      lte: z.string().optional(),
      gt: z.string().optional(),
      gte: z.string().optional(),
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      mode: z.lazy(() => QueryModeSchema).optional(),
      not: z
        .union([z.string(), z.lazy(() => NestedStringNullableFilterSchema)])
        .optional()
        .nullable()
    })
    .strict();

export const IntNullableFilterSchema: z.ZodType<Prisma.IntNullableFilter> = z
  .object({
    equals: z.number().optional().nullable(),
    in: z.number().array().optional().nullable(),
    notIn: z.number().array().optional().nullable(),
    lt: z.number().optional(),
    lte: z.number().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    not: z
      .union([z.number(), z.lazy(() => NestedIntNullableFilterSchema)])
      .optional()
      .nullable()
  })
  .strict();

export const DateTimeFilterSchema: z.ZodType<Prisma.DateTimeFilter> = z
  .object({
    equals: z.coerce.date().optional(),
    in: z.coerce.date().array().optional(),
    notIn: z.coerce.date().array().optional(),
    lt: z.coerce.date().optional(),
    lte: z.coerce.date().optional(),
    gt: z.coerce.date().optional(),
    gte: z.coerce.date().optional(),
    not: z
      .union([z.coerce.date(), z.lazy(() => NestedDateTimeFilterSchema)])
      .optional()
  })
  .strict();

export const SortOrderInputSchema: z.ZodType<Prisma.SortOrderInput> = z
  .object({
    sort: z.lazy(() => SortOrderSchema),
    nulls: z.lazy(() => NullsOrderSchema).optional()
  })
  .strict();

export const AccountProviderIdProviderAccountIdCompoundUniqueInputSchema: z.ZodType<Prisma.AccountProviderIdProviderAccountIdCompoundUniqueInput> =
  z
    .object({
      providerId: z.string(),
      providerAccountId: z.string()
    })
    .strict();

export const AccountCountOrderByAggregateInputSchema: z.ZodType<Prisma.AccountCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      providerId: z.lazy(() => SortOrderSchema).optional(),
      providerAccountId: z.lazy(() => SortOrderSchema).optional(),
      password: z.lazy(() => SortOrderSchema).optional(),
      refresh_token: z.lazy(() => SortOrderSchema).optional(),
      access_token: z.lazy(() => SortOrderSchema).optional(),
      expires_at: z.lazy(() => SortOrderSchema).optional(),
      scope: z.lazy(() => SortOrderSchema).optional(),
      id_token: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const AccountAvgOrderByAggregateInputSchema: z.ZodType<Prisma.AccountAvgOrderByAggregateInput> =
  z
    .object({
      expires_at: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const AccountMaxOrderByAggregateInputSchema: z.ZodType<Prisma.AccountMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      providerId: z.lazy(() => SortOrderSchema).optional(),
      providerAccountId: z.lazy(() => SortOrderSchema).optional(),
      password: z.lazy(() => SortOrderSchema).optional(),
      refresh_token: z.lazy(() => SortOrderSchema).optional(),
      access_token: z.lazy(() => SortOrderSchema).optional(),
      expires_at: z.lazy(() => SortOrderSchema).optional(),
      scope: z.lazy(() => SortOrderSchema).optional(),
      id_token: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const AccountMinOrderByAggregateInputSchema: z.ZodType<Prisma.AccountMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      providerId: z.lazy(() => SortOrderSchema).optional(),
      providerAccountId: z.lazy(() => SortOrderSchema).optional(),
      password: z.lazy(() => SortOrderSchema).optional(),
      refresh_token: z.lazy(() => SortOrderSchema).optional(),
      access_token: z.lazy(() => SortOrderSchema).optional(),
      expires_at: z.lazy(() => SortOrderSchema).optional(),
      scope: z.lazy(() => SortOrderSchema).optional(),
      id_token: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const AccountSumOrderByAggregateInputSchema: z.ZodType<Prisma.AccountSumOrderByAggregateInput> =
  z
    .object({
      expires_at: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const StringNullableWithAggregatesFilterSchema: z.ZodType<Prisma.StringNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.string().optional().nullable(),
      in: z.string().array().optional().nullable(),
      notIn: z.string().array().optional().nullable(),
      lt: z.string().optional(),
      lte: z.string().optional(),
      gt: z.string().optional(),
      gte: z.string().optional(),
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      mode: z.lazy(() => QueryModeSchema).optional(),
      not: z
        .union([
          z.string(),
          z.lazy(() => NestedStringNullableWithAggregatesFilterSchema)
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedStringNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedStringNullableFilterSchema).optional()
    })
    .strict();

export const IntNullableWithAggregatesFilterSchema: z.ZodType<Prisma.IntNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional().nullable(),
      in: z.number().array().optional().nullable(),
      notIn: z.number().array().optional().nullable(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([
          z.number(),
          z.lazy(() => NestedIntNullableWithAggregatesFilterSchema)
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
      _sum: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedIntNullableFilterSchema).optional()
    })
    .strict();

export const DateTimeWithAggregatesFilterSchema: z.ZodType<Prisma.DateTimeWithAggregatesFilter> =
  z
    .object({
      equals: z.coerce.date().optional(),
      in: z.coerce.date().array().optional(),
      notIn: z.coerce.date().array().optional(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([
          z.coerce.date(),
          z.lazy(() => NestedDateTimeWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedDateTimeFilterSchema).optional(),
      _max: z.lazy(() => NestedDateTimeFilterSchema).optional()
    })
    .strict();

export const SessionCountOrderByAggregateInputSchema: z.ZodType<Prisma.SessionCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      sessionToken: z.lazy(() => SortOrderSchema).optional(),
      expires: z.lazy(() => SortOrderSchema).optional(),
      ipAddress: z.lazy(() => SortOrderSchema).optional(),
      userAgent: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const SessionMaxOrderByAggregateInputSchema: z.ZodType<Prisma.SessionMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      sessionToken: z.lazy(() => SortOrderSchema).optional(),
      expires: z.lazy(() => SortOrderSchema).optional(),
      ipAddress: z.lazy(() => SortOrderSchema).optional(),
      userAgent: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const SessionMinOrderByAggregateInputSchema: z.ZodType<Prisma.SessionMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      sessionToken: z.lazy(() => SortOrderSchema).optional(),
      expires: z.lazy(() => SortOrderSchema).optional(),
      ipAddress: z.lazy(() => SortOrderSchema).optional(),
      userAgent: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const VerificationCountOrderByAggregateInputSchema: z.ZodType<Prisma.VerificationCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      identifier: z.lazy(() => SortOrderSchema).optional(),
      value: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const VerificationMaxOrderByAggregateInputSchema: z.ZodType<Prisma.VerificationMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      identifier: z.lazy(() => SortOrderSchema).optional(),
      value: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const VerificationMinOrderByAggregateInputSchema: z.ZodType<Prisma.VerificationMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      identifier: z.lazy(() => SortOrderSchema).optional(),
      value: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const IntFilterSchema: z.ZodType<Prisma.IntFilter> = z
  .object({
    equals: z.number().optional(),
    in: z.number().array().optional(),
    notIn: z.number().array().optional(),
    lt: z.number().optional(),
    lte: z.number().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    not: z.union([z.number(), z.lazy(() => NestedIntFilterSchema)]).optional()
  })
  .strict();

export const BoolFilterSchema: z.ZodType<Prisma.BoolFilter> = z
  .object({
    equals: z.boolean().optional(),
    not: z.union([z.boolean(), z.lazy(() => NestedBoolFilterSchema)]).optional()
  })
  .strict();

export const AuthenticatorUserIdCredentialIDCompoundUniqueInputSchema: z.ZodType<Prisma.AuthenticatorUserIdCredentialIDCompoundUniqueInput> =
  z
    .object({
      userId: z.string(),
      credentialID: z.string()
    })
    .strict();

export const AuthenticatorCountOrderByAggregateInputSchema: z.ZodType<Prisma.AuthenticatorCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      credentialID: z.lazy(() => SortOrderSchema).optional(),
      providerAccountId: z.lazy(() => SortOrderSchema).optional(),
      credentialPublicKey: z.lazy(() => SortOrderSchema).optional(),
      counter: z.lazy(() => SortOrderSchema).optional(),
      credentialDeviceType: z.lazy(() => SortOrderSchema).optional(),
      credentialBackedUp: z.lazy(() => SortOrderSchema).optional(),
      transports: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const AuthenticatorAvgOrderByAggregateInputSchema: z.ZodType<Prisma.AuthenticatorAvgOrderByAggregateInput> =
  z
    .object({
      counter: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const AuthenticatorMaxOrderByAggregateInputSchema: z.ZodType<Prisma.AuthenticatorMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      credentialID: z.lazy(() => SortOrderSchema).optional(),
      providerAccountId: z.lazy(() => SortOrderSchema).optional(),
      credentialPublicKey: z.lazy(() => SortOrderSchema).optional(),
      counter: z.lazy(() => SortOrderSchema).optional(),
      credentialDeviceType: z.lazy(() => SortOrderSchema).optional(),
      credentialBackedUp: z.lazy(() => SortOrderSchema).optional(),
      transports: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const AuthenticatorMinOrderByAggregateInputSchema: z.ZodType<Prisma.AuthenticatorMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      credentialID: z.lazy(() => SortOrderSchema).optional(),
      providerAccountId: z.lazy(() => SortOrderSchema).optional(),
      credentialPublicKey: z.lazy(() => SortOrderSchema).optional(),
      counter: z.lazy(() => SortOrderSchema).optional(),
      credentialDeviceType: z.lazy(() => SortOrderSchema).optional(),
      credentialBackedUp: z.lazy(() => SortOrderSchema).optional(),
      transports: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const AuthenticatorSumOrderByAggregateInputSchema: z.ZodType<Prisma.AuthenticatorSumOrderByAggregateInput> =
  z
    .object({
      counter: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const IntWithAggregatesFilterSchema: z.ZodType<Prisma.IntWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional(),
      in: z.number().array().optional(),
      notIn: z.number().array().optional(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([z.number(), z.lazy(() => NestedIntWithAggregatesFilterSchema)])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatFilterSchema).optional(),
      _sum: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedIntFilterSchema).optional(),
      _max: z.lazy(() => NestedIntFilterSchema).optional()
    })
    .strict();

export const BoolWithAggregatesFilterSchema: z.ZodType<Prisma.BoolWithAggregatesFilter> =
  z
    .object({
      equals: z.boolean().optional(),
      not: z
        .union([
          z.boolean(),
          z.lazy(() => NestedBoolWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedBoolFilterSchema).optional(),
      _max: z.lazy(() => NestedBoolFilterSchema).optional()
    })
    .strict();

export const PasswordResetTokenEmailTokenCompoundUniqueInputSchema: z.ZodType<Prisma.PasswordResetTokenEmailTokenCompoundUniqueInput> =
  z
    .object({
      email: z.string(),
      token: z.string()
    })
    .strict();

export const PasswordResetTokenCountOrderByAggregateInputSchema: z.ZodType<Prisma.PasswordResetTokenCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      token: z.lazy(() => SortOrderSchema).optional(),
      expires: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const PasswordResetTokenMaxOrderByAggregateInputSchema: z.ZodType<Prisma.PasswordResetTokenMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      token: z.lazy(() => SortOrderSchema).optional(),
      expires: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const PasswordResetTokenMinOrderByAggregateInputSchema: z.ZodType<Prisma.PasswordResetTokenMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      token: z.lazy(() => SortOrderSchema).optional(),
      expires: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const TwoFactorTokenEmailTokenCompoundUniqueInputSchema: z.ZodType<Prisma.TwoFactorTokenEmailTokenCompoundUniqueInput> =
  z
    .object({
      email: z.string(),
      token: z.string()
    })
    .strict();

export const TwoFactorTokenCountOrderByAggregateInputSchema: z.ZodType<Prisma.TwoFactorTokenCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      token: z.lazy(() => SortOrderSchema).optional(),
      expires: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const TwoFactorTokenMaxOrderByAggregateInputSchema: z.ZodType<Prisma.TwoFactorTokenMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      token: z.lazy(() => SortOrderSchema).optional(),
      expires: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const TwoFactorTokenMinOrderByAggregateInputSchema: z.ZodType<Prisma.TwoFactorTokenMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      token: z.lazy(() => SortOrderSchema).optional(),
      expires: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CustomerCountOrderByAggregateInputSchema: z.ZodType<Prisma.CustomerCountOrderByAggregateInput> =
  z
    .object({
      stripe_customer_id: z.lazy(() => SortOrderSchema).optional(),
      id: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CustomerMaxOrderByAggregateInputSchema: z.ZodType<Prisma.CustomerMaxOrderByAggregateInput> =
  z
    .object({
      stripe_customer_id: z.lazy(() => SortOrderSchema).optional(),
      id: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CustomerMinOrderByAggregateInputSchema: z.ZodType<Prisma.CustomerMinOrderByAggregateInput> =
  z
    .object({
      stripe_customer_id: z.lazy(() => SortOrderSchema).optional(),
      id: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const JsonFilterSchema: z.ZodType<Prisma.JsonFilter> = z
  .object({
    equals: InputJsonValueSchema.optional(),
    path: z.string().array().optional(),
    mode: z.lazy(() => QueryModeSchema).optional(),
    string_contains: z.string().optional(),
    string_starts_with: z.string().optional(),
    string_ends_with: z.string().optional(),
    array_starts_with: InputJsonValueSchema.optional().nullable(),
    array_ends_with: InputJsonValueSchema.optional().nullable(),
    array_contains: InputJsonValueSchema.optional().nullable(),
    lt: InputJsonValueSchema.optional(),
    lte: InputJsonValueSchema.optional(),
    gt: InputJsonValueSchema.optional(),
    gte: InputJsonValueSchema.optional(),
    not: InputJsonValueSchema.optional()
  })
  .strict();

export const PriceListRelationFilterSchema: z.ZodType<Prisma.PriceListRelationFilter> =
  z
    .object({
      every: z.lazy(() => PriceWhereInputSchema).optional(),
      some: z.lazy(() => PriceWhereInputSchema).optional(),
      none: z.lazy(() => PriceWhereInputSchema).optional()
    })
    .strict();

export const PriceOrderByRelationAggregateInputSchema: z.ZodType<Prisma.PriceOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ProductCountOrderByAggregateInputSchema: z.ZodType<Prisma.ProductCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      image: z.lazy(() => SortOrderSchema).optional(),
      metadata: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ProductMaxOrderByAggregateInputSchema: z.ZodType<Prisma.ProductMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      image: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ProductMinOrderByAggregateInputSchema: z.ZodType<Prisma.ProductMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      image: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const JsonWithAggregatesFilterSchema: z.ZodType<Prisma.JsonWithAggregatesFilter> =
  z
    .object({
      equals: InputJsonValueSchema.optional(),
      path: z.string().array().optional(),
      mode: z.lazy(() => QueryModeSchema).optional(),
      string_contains: z.string().optional(),
      string_starts_with: z.string().optional(),
      string_ends_with: z.string().optional(),
      array_starts_with: InputJsonValueSchema.optional().nullable(),
      array_ends_with: InputJsonValueSchema.optional().nullable(),
      array_contains: InputJsonValueSchema.optional().nullable(),
      lt: InputJsonValueSchema.optional(),
      lte: InputJsonValueSchema.optional(),
      gt: InputJsonValueSchema.optional(),
      gte: InputJsonValueSchema.optional(),
      not: InputJsonValueSchema.optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedJsonFilterSchema).optional(),
      _max: z.lazy(() => NestedJsonFilterSchema).optional()
    })
    .strict();

export const EnumPricingTypeFilterSchema: z.ZodType<Prisma.EnumPricingTypeFilter> =
  z
    .object({
      equals: z.lazy(() => PricingTypeSchema).optional(),
      in: z
        .lazy(() => PricingTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PricingTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PricingTypeSchema),
          z.lazy(() => NestedEnumPricingTypeFilterSchema)
        ])
        .optional()
    })
    .strict();

export const EnumPricingPlanIntervalNullableFilterSchema: z.ZodType<Prisma.EnumPricingPlanIntervalNullableFilter> =
  z
    .object({
      equals: z
        .lazy(() => PricingPlanIntervalSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => PricingPlanIntervalSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => PricingPlanIntervalSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => PricingPlanIntervalSchema),
          z.lazy(() => NestedEnumPricingPlanIntervalNullableFilterSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const SubscriptionListRelationFilterSchema: z.ZodType<Prisma.SubscriptionListRelationFilter> =
  z
    .object({
      every: z.lazy(() => SubscriptionWhereInputSchema).optional(),
      some: z.lazy(() => SubscriptionWhereInputSchema).optional(),
      none: z.lazy(() => SubscriptionWhereInputSchema).optional()
    })
    .strict();

export const ProductScalarRelationFilterSchema: z.ZodType<Prisma.ProductScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => ProductWhereInputSchema).optional(),
      isNot: z.lazy(() => ProductWhereInputSchema).optional()
    })
    .strict();

export const SubscriptionOrderByRelationAggregateInputSchema: z.ZodType<Prisma.SubscriptionOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const PriceCountOrderByAggregateInputSchema: z.ZodType<Prisma.PriceCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      unit_amount: z.lazy(() => SortOrderSchema).optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      interval: z.lazy(() => SortOrderSchema).optional(),
      interval_count: z.lazy(() => SortOrderSchema).optional(),
      trial_period_days: z.lazy(() => SortOrderSchema).optional(),
      metadata: z.lazy(() => SortOrderSchema).optional(),
      productId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const PriceAvgOrderByAggregateInputSchema: z.ZodType<Prisma.PriceAvgOrderByAggregateInput> =
  z
    .object({
      unit_amount: z.lazy(() => SortOrderSchema).optional(),
      interval_count: z.lazy(() => SortOrderSchema).optional(),
      trial_period_days: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const PriceMaxOrderByAggregateInputSchema: z.ZodType<Prisma.PriceMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      unit_amount: z.lazy(() => SortOrderSchema).optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      interval: z.lazy(() => SortOrderSchema).optional(),
      interval_count: z.lazy(() => SortOrderSchema).optional(),
      trial_period_days: z.lazy(() => SortOrderSchema).optional(),
      productId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const PriceMinOrderByAggregateInputSchema: z.ZodType<Prisma.PriceMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      unit_amount: z.lazy(() => SortOrderSchema).optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      interval: z.lazy(() => SortOrderSchema).optional(),
      interval_count: z.lazy(() => SortOrderSchema).optional(),
      trial_period_days: z.lazy(() => SortOrderSchema).optional(),
      productId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const PriceSumOrderByAggregateInputSchema: z.ZodType<Prisma.PriceSumOrderByAggregateInput> =
  z
    .object({
      unit_amount: z.lazy(() => SortOrderSchema).optional(),
      interval_count: z.lazy(() => SortOrderSchema).optional(),
      trial_period_days: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const EnumPricingTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumPricingTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => PricingTypeSchema).optional(),
      in: z
        .lazy(() => PricingTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PricingTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PricingTypeSchema),
          z.lazy(() => NestedEnumPricingTypeWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumPricingTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumPricingTypeFilterSchema).optional()
    })
    .strict();

export const EnumPricingPlanIntervalNullableWithAggregatesFilterSchema: z.ZodType<Prisma.EnumPricingPlanIntervalNullableWithAggregatesFilter> =
  z
    .object({
      equals: z
        .lazy(() => PricingPlanIntervalSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => PricingPlanIntervalSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => PricingPlanIntervalSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => PricingPlanIntervalSchema),
          z.lazy(
            () =>
              NestedEnumPricingPlanIntervalNullableWithAggregatesFilterSchema
          )
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z
        .lazy(() => NestedEnumPricingPlanIntervalNullableFilterSchema)
        .optional(),
      _max: z
        .lazy(() => NestedEnumPricingPlanIntervalNullableFilterSchema)
        .optional()
    })
    .strict();

export const EnumSubscriptionStatusFilterSchema: z.ZodType<Prisma.EnumSubscriptionStatusFilter> =
  z
    .object({
      equals: z.lazy(() => SubscriptionStatusSchema).optional(),
      in: z
        .lazy(() => SubscriptionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => SubscriptionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => NestedEnumSubscriptionStatusFilterSchema)
        ])
        .optional()
    })
    .strict();

export const DateTimeNullableFilterSchema: z.ZodType<Prisma.DateTimeNullableFilter> =
  z
    .object({
      equals: z.coerce.date().optional().nullable(),
      in: z.coerce.date().array().optional().nullable(),
      notIn: z.coerce.date().array().optional().nullable(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([
          z.coerce.date(),
          z.lazy(() => NestedDateTimeNullableFilterSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const PriceScalarRelationFilterSchema: z.ZodType<Prisma.PriceScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => PriceWhereInputSchema).optional(),
      isNot: z.lazy(() => PriceWhereInputSchema).optional()
    })
    .strict();

export const SubscriptionCountOrderByAggregateInputSchema: z.ZodType<Prisma.SubscriptionCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      metadata: z.lazy(() => SortOrderSchema).optional(),
      quantity: z.lazy(() => SortOrderSchema).optional(),
      cancel_at_period_end: z.lazy(() => SortOrderSchema).optional(),
      created: z.lazy(() => SortOrderSchema).optional(),
      current_period_start: z.lazy(() => SortOrderSchema).optional(),
      current_period_end: z.lazy(() => SortOrderSchema).optional(),
      ended_at: z.lazy(() => SortOrderSchema).optional(),
      cancel_at: z.lazy(() => SortOrderSchema).optional(),
      canceled_at: z.lazy(() => SortOrderSchema).optional(),
      trial_start: z.lazy(() => SortOrderSchema).optional(),
      trial_end: z.lazy(() => SortOrderSchema).optional(),
      priceId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const SubscriptionAvgOrderByAggregateInputSchema: z.ZodType<Prisma.SubscriptionAvgOrderByAggregateInput> =
  z
    .object({
      quantity: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const SubscriptionMaxOrderByAggregateInputSchema: z.ZodType<Prisma.SubscriptionMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      quantity: z.lazy(() => SortOrderSchema).optional(),
      cancel_at_period_end: z.lazy(() => SortOrderSchema).optional(),
      created: z.lazy(() => SortOrderSchema).optional(),
      current_period_start: z.lazy(() => SortOrderSchema).optional(),
      current_period_end: z.lazy(() => SortOrderSchema).optional(),
      ended_at: z.lazy(() => SortOrderSchema).optional(),
      cancel_at: z.lazy(() => SortOrderSchema).optional(),
      canceled_at: z.lazy(() => SortOrderSchema).optional(),
      trial_start: z.lazy(() => SortOrderSchema).optional(),
      trial_end: z.lazy(() => SortOrderSchema).optional(),
      priceId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const SubscriptionMinOrderByAggregateInputSchema: z.ZodType<Prisma.SubscriptionMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      quantity: z.lazy(() => SortOrderSchema).optional(),
      cancel_at_period_end: z.lazy(() => SortOrderSchema).optional(),
      created: z.lazy(() => SortOrderSchema).optional(),
      current_period_start: z.lazy(() => SortOrderSchema).optional(),
      current_period_end: z.lazy(() => SortOrderSchema).optional(),
      ended_at: z.lazy(() => SortOrderSchema).optional(),
      cancel_at: z.lazy(() => SortOrderSchema).optional(),
      canceled_at: z.lazy(() => SortOrderSchema).optional(),
      trial_start: z.lazy(() => SortOrderSchema).optional(),
      trial_end: z.lazy(() => SortOrderSchema).optional(),
      priceId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const SubscriptionSumOrderByAggregateInputSchema: z.ZodType<Prisma.SubscriptionSumOrderByAggregateInput> =
  z
    .object({
      quantity: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const EnumSubscriptionStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumSubscriptionStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => SubscriptionStatusSchema).optional(),
      in: z
        .lazy(() => SubscriptionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => SubscriptionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => NestedEnumSubscriptionStatusWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumSubscriptionStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumSubscriptionStatusFilterSchema).optional()
    })
    .strict();

export const DateTimeNullableWithAggregatesFilterSchema: z.ZodType<Prisma.DateTimeNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.coerce.date().optional().nullable(),
      in: z.coerce.date().array().optional().nullable(),
      notIn: z.coerce.date().array().optional().nullable(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([
          z.coerce.date(),
          z.lazy(() => NestedDateTimeNullableWithAggregatesFilterSchema)
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedDateTimeNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedDateTimeNullableFilterSchema).optional()
    })
    .strict();

export const EnumFeedTypeFilterSchema: z.ZodType<Prisma.EnumFeedTypeFilter> = z
  .object({
    equals: z.lazy(() => FeedTypeSchema).optional(),
    in: z
      .lazy(() => FeedTypeSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => FeedTypeSchema)
      .array()
      .optional(),
    not: z
      .union([
        z.lazy(() => FeedTypeSchema),
        z.lazy(() => NestedEnumFeedTypeFilterSchema)
      ])
      .optional()
  })
  .strict();

export const SiteScalarRelationFilterSchema: z.ZodType<Prisma.SiteScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => SiteWhereInputSchema).optional(),
      isNot: z.lazy(() => SiteWhereInputSchema).optional()
    })
    .strict();

export const CommentListRelationFilterSchema: z.ZodType<Prisma.CommentListRelationFilter> =
  z
    .object({
      every: z.lazy(() => CommentWhereInputSchema).optional(),
      some: z.lazy(() => CommentWhereInputSchema).optional(),
      none: z.lazy(() => CommentWhereInputSchema).optional()
    })
    .strict();

export const LikeListRelationFilterSchema: z.ZodType<Prisma.LikeListRelationFilter> =
  z
    .object({
      every: z.lazy(() => LikeWhereInputSchema).optional(),
      some: z.lazy(() => LikeWhereInputSchema).optional(),
      none: z.lazy(() => LikeWhereInputSchema).optional()
    })
    .strict();

export const CommentOrderByRelationAggregateInputSchema: z.ZodType<Prisma.CommentOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const LikeOrderByRelationAggregateInputSchema: z.ZodType<Prisma.LikeOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const FeedCountOrderByAggregateInputSchema: z.ZodType<Prisma.FeedCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      commentable: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const FeedMaxOrderByAggregateInputSchema: z.ZodType<Prisma.FeedMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      commentable: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const FeedMinOrderByAggregateInputSchema: z.ZodType<Prisma.FeedMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      commentable: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const EnumFeedTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumFeedTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => FeedTypeSchema).optional(),
      in: z
        .lazy(() => FeedTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => FeedTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => FeedTypeSchema),
          z.lazy(() => NestedEnumFeedTypeWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumFeedTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumFeedTypeFilterSchema).optional()
    })
    .strict();

export const FeedNullableScalarRelationFilterSchema: z.ZodType<Prisma.FeedNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => FeedWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => FeedWhereInputSchema)
        .optional()
        .nullable()
    })
    .strict();

export const CommentCountOrderByAggregateInputSchema: z.ZodType<Prisma.CommentCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      feedId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CommentMaxOrderByAggregateInputSchema: z.ZodType<Prisma.CommentMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      feedId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CommentMinOrderByAggregateInputSchema: z.ZodType<Prisma.CommentMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      feedId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const FloatNullableFilterSchema: z.ZodType<Prisma.FloatNullableFilter> =
  z
    .object({
      equals: z.number().optional().nullable(),
      in: z.number().array().optional().nullable(),
      notIn: z.number().array().optional().nullable(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([z.number(), z.lazy(() => NestedFloatNullableFilterSchema)])
        .optional()
        .nullable()
    })
    .strict();

export const CityCountOrderByAggregateInputSchema: z.ZodType<Prisma.CityCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      departement: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      nom: z.lazy(() => SortOrderSchema).optional(),
      nomSimple: z.lazy(() => SortOrderSchema).optional(),
      nomReel: z.lazy(() => SortOrderSchema).optional(),
      nomSoundex: z.lazy(() => SortOrderSchema).optional(),
      nomMetaphone: z.lazy(() => SortOrderSchema).optional(),
      codePostal: z.lazy(() => SortOrderSchema).optional(),
      commune: z.lazy(() => SortOrderSchema).optional(),
      codeCommune: z.lazy(() => SortOrderSchema).optional(),
      arrondissement: z.lazy(() => SortOrderSchema).optional(),
      canton: z.lazy(() => SortOrderSchema).optional(),
      amdi: z.lazy(() => SortOrderSchema).optional(),
      population2010: z.lazy(() => SortOrderSchema).optional(),
      population1999: z.lazy(() => SortOrderSchema).optional(),
      population2012: z.lazy(() => SortOrderSchema).optional(),
      densite2010: z.lazy(() => SortOrderSchema).optional(),
      surface: z.lazy(() => SortOrderSchema).optional(),
      longitudeDeg: z.lazy(() => SortOrderSchema).optional(),
      latitudeDeg: z.lazy(() => SortOrderSchema).optional(),
      longitudeGrd: z.lazy(() => SortOrderSchema).optional(),
      latitudeGrd: z.lazy(() => SortOrderSchema).optional(),
      longitudeDms: z.lazy(() => SortOrderSchema).optional(),
      latitudeDms: z.lazy(() => SortOrderSchema).optional(),
      zmin: z.lazy(() => SortOrderSchema).optional(),
      zmax: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CityAvgOrderByAggregateInputSchema: z.ZodType<Prisma.CityAvgOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      arrondissement: z.lazy(() => SortOrderSchema).optional(),
      amdi: z.lazy(() => SortOrderSchema).optional(),
      population2010: z.lazy(() => SortOrderSchema).optional(),
      population1999: z.lazy(() => SortOrderSchema).optional(),
      population2012: z.lazy(() => SortOrderSchema).optional(),
      densite2010: z.lazy(() => SortOrderSchema).optional(),
      surface: z.lazy(() => SortOrderSchema).optional(),
      longitudeDeg: z.lazy(() => SortOrderSchema).optional(),
      latitudeDeg: z.lazy(() => SortOrderSchema).optional(),
      zmin: z.lazy(() => SortOrderSchema).optional(),
      zmax: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CityMaxOrderByAggregateInputSchema: z.ZodType<Prisma.CityMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      departement: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      nom: z.lazy(() => SortOrderSchema).optional(),
      nomSimple: z.lazy(() => SortOrderSchema).optional(),
      nomReel: z.lazy(() => SortOrderSchema).optional(),
      nomSoundex: z.lazy(() => SortOrderSchema).optional(),
      nomMetaphone: z.lazy(() => SortOrderSchema).optional(),
      codePostal: z.lazy(() => SortOrderSchema).optional(),
      commune: z.lazy(() => SortOrderSchema).optional(),
      codeCommune: z.lazy(() => SortOrderSchema).optional(),
      arrondissement: z.lazy(() => SortOrderSchema).optional(),
      canton: z.lazy(() => SortOrderSchema).optional(),
      amdi: z.lazy(() => SortOrderSchema).optional(),
      population2010: z.lazy(() => SortOrderSchema).optional(),
      population1999: z.lazy(() => SortOrderSchema).optional(),
      population2012: z.lazy(() => SortOrderSchema).optional(),
      densite2010: z.lazy(() => SortOrderSchema).optional(),
      surface: z.lazy(() => SortOrderSchema).optional(),
      longitudeDeg: z.lazy(() => SortOrderSchema).optional(),
      latitudeDeg: z.lazy(() => SortOrderSchema).optional(),
      longitudeGrd: z.lazy(() => SortOrderSchema).optional(),
      latitudeGrd: z.lazy(() => SortOrderSchema).optional(),
      longitudeDms: z.lazy(() => SortOrderSchema).optional(),
      latitudeDms: z.lazy(() => SortOrderSchema).optional(),
      zmin: z.lazy(() => SortOrderSchema).optional(),
      zmax: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CityMinOrderByAggregateInputSchema: z.ZodType<Prisma.CityMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      departement: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      nom: z.lazy(() => SortOrderSchema).optional(),
      nomSimple: z.lazy(() => SortOrderSchema).optional(),
      nomReel: z.lazy(() => SortOrderSchema).optional(),
      nomSoundex: z.lazy(() => SortOrderSchema).optional(),
      nomMetaphone: z.lazy(() => SortOrderSchema).optional(),
      codePostal: z.lazy(() => SortOrderSchema).optional(),
      commune: z.lazy(() => SortOrderSchema).optional(),
      codeCommune: z.lazy(() => SortOrderSchema).optional(),
      arrondissement: z.lazy(() => SortOrderSchema).optional(),
      canton: z.lazy(() => SortOrderSchema).optional(),
      amdi: z.lazy(() => SortOrderSchema).optional(),
      population2010: z.lazy(() => SortOrderSchema).optional(),
      population1999: z.lazy(() => SortOrderSchema).optional(),
      population2012: z.lazy(() => SortOrderSchema).optional(),
      densite2010: z.lazy(() => SortOrderSchema).optional(),
      surface: z.lazy(() => SortOrderSchema).optional(),
      longitudeDeg: z.lazy(() => SortOrderSchema).optional(),
      latitudeDeg: z.lazy(() => SortOrderSchema).optional(),
      longitudeGrd: z.lazy(() => SortOrderSchema).optional(),
      latitudeGrd: z.lazy(() => SortOrderSchema).optional(),
      longitudeDms: z.lazy(() => SortOrderSchema).optional(),
      latitudeDms: z.lazy(() => SortOrderSchema).optional(),
      zmin: z.lazy(() => SortOrderSchema).optional(),
      zmax: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CitySumOrderByAggregateInputSchema: z.ZodType<Prisma.CitySumOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      arrondissement: z.lazy(() => SortOrderSchema).optional(),
      amdi: z.lazy(() => SortOrderSchema).optional(),
      population2010: z.lazy(() => SortOrderSchema).optional(),
      population1999: z.lazy(() => SortOrderSchema).optional(),
      population2012: z.lazy(() => SortOrderSchema).optional(),
      densite2010: z.lazy(() => SortOrderSchema).optional(),
      surface: z.lazy(() => SortOrderSchema).optional(),
      longitudeDeg: z.lazy(() => SortOrderSchema).optional(),
      latitudeDeg: z.lazy(() => SortOrderSchema).optional(),
      zmin: z.lazy(() => SortOrderSchema).optional(),
      zmax: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const FloatNullableWithAggregatesFilterSchema: z.ZodType<Prisma.FloatNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional().nullable(),
      in: z.number().array().optional().nullable(),
      notIn: z.number().array().optional().nullable(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([
          z.number(),
          z.lazy(() => NestedFloatNullableWithAggregatesFilterSchema)
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
      _sum: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedFloatNullableFilterSchema).optional()
    })
    .strict();

export const NafDivisionListRelationFilterSchema: z.ZodType<Prisma.NafDivisionListRelationFilter> =
  z
    .object({
      every: z.lazy(() => NafDivisionWhereInputSchema).optional(),
      some: z.lazy(() => NafDivisionWhereInputSchema).optional(),
      none: z.lazy(() => NafDivisionWhereInputSchema).optional()
    })
    .strict();

export const NafDivisionOrderByRelationAggregateInputSchema: z.ZodType<Prisma.NafDivisionOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const NafSectionCountOrderByAggregateInputSchema: z.ZodType<Prisma.NafSectionCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const NafSectionMaxOrderByAggregateInputSchema: z.ZodType<Prisma.NafSectionMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const NafSectionMinOrderByAggregateInputSchema: z.ZodType<Prisma.NafSectionMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const NafGroupListRelationFilterSchema: z.ZodType<Prisma.NafGroupListRelationFilter> =
  z
    .object({
      every: z.lazy(() => NafGroupWhereInputSchema).optional(),
      some: z.lazy(() => NafGroupWhereInputSchema).optional(),
      none: z.lazy(() => NafGroupWhereInputSchema).optional()
    })
    .strict();

export const NafSectionScalarRelationFilterSchema: z.ZodType<Prisma.NafSectionScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => NafSectionWhereInputSchema).optional(),
      isNot: z.lazy(() => NafSectionWhereInputSchema).optional()
    })
    .strict();

export const NafGroupOrderByRelationAggregateInputSchema: z.ZodType<Prisma.NafGroupOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const NafDivisionCountOrderByAggregateInputSchema: z.ZodType<Prisma.NafDivisionCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      sectionId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const NafDivisionMaxOrderByAggregateInputSchema: z.ZodType<Prisma.NafDivisionMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      sectionId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const NafDivisionMinOrderByAggregateInputSchema: z.ZodType<Prisma.NafDivisionMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      sectionId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const NafClassListRelationFilterSchema: z.ZodType<Prisma.NafClassListRelationFilter> =
  z
    .object({
      every: z.lazy(() => NafClassWhereInputSchema).optional(),
      some: z.lazy(() => NafClassWhereInputSchema).optional(),
      none: z.lazy(() => NafClassWhereInputSchema).optional()
    })
    .strict();

export const NafDivisionScalarRelationFilterSchema: z.ZodType<Prisma.NafDivisionScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => NafDivisionWhereInputSchema).optional(),
      isNot: z.lazy(() => NafDivisionWhereInputSchema).optional()
    })
    .strict();

export const NafClassOrderByRelationAggregateInputSchema: z.ZodType<Prisma.NafClassOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const NafGroupCountOrderByAggregateInputSchema: z.ZodType<Prisma.NafGroupCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      divisionId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const NafGroupMaxOrderByAggregateInputSchema: z.ZodType<Prisma.NafGroupMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      divisionId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const NafGroupMinOrderByAggregateInputSchema: z.ZodType<Prisma.NafGroupMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      divisionId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const NafCodeListRelationFilterSchema: z.ZodType<Prisma.NafCodeListRelationFilter> =
  z
    .object({
      every: z.lazy(() => NafCodeWhereInputSchema).optional(),
      some: z.lazy(() => NafCodeWhereInputSchema).optional(),
      none: z.lazy(() => NafCodeWhereInputSchema).optional()
    })
    .strict();

export const NafGroupScalarRelationFilterSchema: z.ZodType<Prisma.NafGroupScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => NafGroupWhereInputSchema).optional(),
      isNot: z.lazy(() => NafGroupWhereInputSchema).optional()
    })
    .strict();

export const NafCodeOrderByRelationAggregateInputSchema: z.ZodType<Prisma.NafCodeOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const NafClassCountOrderByAggregateInputSchema: z.ZodType<Prisma.NafClassCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      groupId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const NafClassMaxOrderByAggregateInputSchema: z.ZodType<Prisma.NafClassMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      groupId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const NafClassMinOrderByAggregateInputSchema: z.ZodType<Prisma.NafClassMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      groupId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const NafClassScalarRelationFilterSchema: z.ZodType<Prisma.NafClassScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => NafClassWhereInputSchema).optional(),
      isNot: z.lazy(() => NafClassWhereInputSchema).optional()
    })
    .strict();

export const UserListRelationFilterSchema: z.ZodType<Prisma.UserListRelationFilter> =
  z
    .object({
      every: z.lazy(() => UserWhereInputSchema).optional(),
      some: z.lazy(() => UserWhereInputSchema).optional(),
      none: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserOrderByRelationAggregateInputSchema: z.ZodType<Prisma.UserOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const NafCodeCountOrderByAggregateInputSchema: z.ZodType<Prisma.NafCodeCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      classId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const NafCodeMaxOrderByAggregateInputSchema: z.ZodType<Prisma.NafCodeMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      classId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const NafCodeMinOrderByAggregateInputSchema: z.ZodType<Prisma.NafCodeMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      classId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const JsonNullableFilterSchema: z.ZodType<Prisma.JsonNullableFilter> = z
  .object({
    equals: InputJsonValueSchema.optional(),
    path: z.string().array().optional(),
    mode: z.lazy(() => QueryModeSchema).optional(),
    string_contains: z.string().optional(),
    string_starts_with: z.string().optional(),
    string_ends_with: z.string().optional(),
    array_starts_with: InputJsonValueSchema.optional().nullable(),
    array_ends_with: InputJsonValueSchema.optional().nullable(),
    array_contains: InputJsonValueSchema.optional().nullable(),
    lt: InputJsonValueSchema.optional(),
    lte: InputJsonValueSchema.optional(),
    gt: InputJsonValueSchema.optional(),
    gte: InputJsonValueSchema.optional(),
    not: InputJsonValueSchema.optional()
  })
  .strict();

export const CampaignNullableScalarRelationFilterSchema: z.ZodType<Prisma.CampaignNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => CampaignWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => CampaignWhereInputSchema)
        .optional()
        .nullable()
    })
    .strict();

export const UserNullableScalarRelationFilterSchema: z.ZodType<Prisma.UserNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => UserWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => UserWhereInputSchema)
        .optional()
        .nullable()
    })
    .strict();

export const OutboxCountOrderByAggregateInputSchema: z.ZodType<Prisma.OutboxCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      subject: z.lazy(() => SortOrderSchema).optional(),
      body: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      metadata: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      campaignId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const OutboxMaxOrderByAggregateInputSchema: z.ZodType<Prisma.OutboxMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      subject: z.lazy(() => SortOrderSchema).optional(),
      body: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      campaignId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const OutboxMinOrderByAggregateInputSchema: z.ZodType<Prisma.OutboxMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      subject: z.lazy(() => SortOrderSchema).optional(),
      body: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      campaignId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const JsonNullableWithAggregatesFilterSchema: z.ZodType<Prisma.JsonNullableWithAggregatesFilter> =
  z
    .object({
      equals: InputJsonValueSchema.optional(),
      path: z.string().array().optional(),
      mode: z.lazy(() => QueryModeSchema).optional(),
      string_contains: z.string().optional(),
      string_starts_with: z.string().optional(),
      string_ends_with: z.string().optional(),
      array_starts_with: InputJsonValueSchema.optional().nullable(),
      array_ends_with: InputJsonValueSchema.optional().nullable(),
      array_contains: InputJsonValueSchema.optional().nullable(),
      lt: InputJsonValueSchema.optional(),
      lte: InputJsonValueSchema.optional(),
      gt: InputJsonValueSchema.optional(),
      gte: InputJsonValueSchema.optional(),
      not: InputJsonValueSchema.optional(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedJsonNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedJsonNullableFilterSchema).optional()
    })
    .strict();

export const CampaignListRelationFilterSchema: z.ZodType<Prisma.CampaignListRelationFilter> =
  z
    .object({
      every: z.lazy(() => CampaignWhereInputSchema).optional(),
      some: z.lazy(() => CampaignWhereInputSchema).optional(),
      none: z.lazy(() => CampaignWhereInputSchema).optional()
    })
    .strict();

export const CampaignOrderByRelationAggregateInputSchema: z.ZodType<Prisma.CampaignOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ListCountOrderByAggregateInputSchema: z.ZodType<Prisma.ListCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ListMaxOrderByAggregateInputSchema: z.ZodType<Prisma.ListMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ListMinOrderByAggregateInputSchema: z.ZodType<Prisma.ListMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const EnumCampaignTypeFilterSchema: z.ZodType<Prisma.EnumCampaignTypeFilter> =
  z
    .object({
      equals: z.lazy(() => CampaignTypeSchema).optional(),
      in: z
        .lazy(() => CampaignTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CampaignTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CampaignTypeSchema),
          z.lazy(() => NestedEnumCampaignTypeFilterSchema)
        ])
        .optional()
    })
    .strict();

export const ListNullableScalarRelationFilterSchema: z.ZodType<Prisma.ListNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => ListWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => ListWhereInputSchema)
        .optional()
        .nullable()
    })
    .strict();

export const EmailScalarRelationFilterSchema: z.ZodType<Prisma.EmailScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => EmailWhereInputSchema).optional(),
      isNot: z.lazy(() => EmailWhereInputSchema).optional()
    })
    .strict();

export const OutboxListRelationFilterSchema: z.ZodType<Prisma.OutboxListRelationFilter> =
  z
    .object({
      every: z.lazy(() => OutboxWhereInputSchema).optional(),
      some: z.lazy(() => OutboxWhereInputSchema).optional(),
      none: z.lazy(() => OutboxWhereInputSchema).optional()
    })
    .strict();

export const OutboxOrderByRelationAggregateInputSchema: z.ZodType<Prisma.OutboxOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CampaignCountOrderByAggregateInputSchema: z.ZodType<Prisma.CampaignCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      smart: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      listId: z.lazy(() => SortOrderSchema).optional(),
      emailId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CampaignMaxOrderByAggregateInputSchema: z.ZodType<Prisma.CampaignMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      smart: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      listId: z.lazy(() => SortOrderSchema).optional(),
      emailId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CampaignMinOrderByAggregateInputSchema: z.ZodType<Prisma.CampaignMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      smart: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      listId: z.lazy(() => SortOrderSchema).optional(),
      emailId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const EnumCampaignTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumCampaignTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => CampaignTypeSchema).optional(),
      in: z
        .lazy(() => CampaignTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CampaignTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CampaignTypeSchema),
          z.lazy(() => NestedEnumCampaignTypeWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumCampaignTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumCampaignTypeFilterSchema).optional()
    })
    .strict();

export const EmailCountOrderByAggregateInputSchema: z.ZodType<Prisma.EmailCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      subject: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      design: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const EmailMaxOrderByAggregateInputSchema: z.ZodType<Prisma.EmailMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      subject: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const EmailMinOrderByAggregateInputSchema: z.ZodType<Prisma.EmailMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      subject: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const EnumEntityTypeFilterSchema: z.ZodType<Prisma.EnumEntityTypeFilter> =
  z
    .object({
      equals: z.lazy(() => EntityTypeSchema).optional(),
      in: z
        .lazy(() => EntityTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => EntityTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => EntityTypeSchema),
          z.lazy(() => NestedEnumEntityTypeFilterSchema)
        ])
        .optional()
    })
    .strict();

export const EnumMediaTypeFilterSchema: z.ZodType<Prisma.EnumMediaTypeFilter> =
  z
    .object({
      equals: z.lazy(() => MediaTypeSchema).optional(),
      in: z
        .lazy(() => MediaTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => MediaTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => MediaTypeSchema),
          z.lazy(() => NestedEnumMediaTypeFilterSchema)
        ])
        .optional()
    })
    .strict();

export const MediaCountOrderByAggregateInputSchema: z.ZodType<Prisma.MediaCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      entityId: z.lazy(() => SortOrderSchema).optional(),
      entityType: z.lazy(() => SortOrderSchema).optional(),
      url: z.lazy(() => SortOrderSchema).optional(),
      alt: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      position: z.lazy(() => SortOrderSchema).optional(),
      isMain: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const MediaAvgOrderByAggregateInputSchema: z.ZodType<Prisma.MediaAvgOrderByAggregateInput> =
  z
    .object({
      position: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const MediaMaxOrderByAggregateInputSchema: z.ZodType<Prisma.MediaMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      entityId: z.lazy(() => SortOrderSchema).optional(),
      entityType: z.lazy(() => SortOrderSchema).optional(),
      url: z.lazy(() => SortOrderSchema).optional(),
      alt: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      position: z.lazy(() => SortOrderSchema).optional(),
      isMain: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const MediaMinOrderByAggregateInputSchema: z.ZodType<Prisma.MediaMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      entityId: z.lazy(() => SortOrderSchema).optional(),
      entityType: z.lazy(() => SortOrderSchema).optional(),
      url: z.lazy(() => SortOrderSchema).optional(),
      alt: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      position: z.lazy(() => SortOrderSchema).optional(),
      isMain: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const MediaSumOrderByAggregateInputSchema: z.ZodType<Prisma.MediaSumOrderByAggregateInput> =
  z
    .object({
      position: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const EnumEntityTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumEntityTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => EntityTypeSchema).optional(),
      in: z
        .lazy(() => EntityTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => EntityTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => EntityTypeSchema),
          z.lazy(() => NestedEnumEntityTypeWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumEntityTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumEntityTypeFilterSchema).optional()
    })
    .strict();

export const EnumMediaTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumMediaTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => MediaTypeSchema).optional(),
      in: z
        .lazy(() => MediaTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => MediaTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => MediaTypeSchema),
          z.lazy(() => NestedEnumMediaTypeWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumMediaTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumMediaTypeFilterSchema).optional()
    })
    .strict();

export const BlockNullableScalarRelationFilterSchema: z.ZodType<Prisma.BlockNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => BlockWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => BlockWhereInputSchema)
        .optional()
        .nullable()
    })
    .strict();

export const SiteNullableScalarRelationFilterSchema: z.ZodType<Prisma.SiteNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => SiteWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => SiteWhereInputSchema)
        .optional()
        .nullable()
    })
    .strict();

export const LinkNullableScalarRelationFilterSchema: z.ZodType<Prisma.LinkNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => LinkWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => LinkWhereInputSchema)
        .optional()
        .nullable()
    })
    .strict();

export const ClickCountOrderByAggregateInputSchema: z.ZodType<Prisma.ClickCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      part: z.lazy(() => SortOrderSchema).optional(),
      path: z.lazy(() => SortOrderSchema).optional(),
      request: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      blockId: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional(),
      linkId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      refererId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ClickMaxOrderByAggregateInputSchema: z.ZodType<Prisma.ClickMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      part: z.lazy(() => SortOrderSchema).optional(),
      path: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      blockId: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional(),
      linkId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      refererId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ClickMinOrderByAggregateInputSchema: z.ZodType<Prisma.ClickMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      part: z.lazy(() => SortOrderSchema).optional(),
      path: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      blockId: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional(),
      linkId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      refererId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ClickListRelationFilterSchema: z.ZodType<Prisma.ClickListRelationFilter> =
  z
    .object({
      every: z.lazy(() => ClickWhereInputSchema).optional(),
      some: z.lazy(() => ClickWhereInputSchema).optional(),
      none: z.lazy(() => ClickWhereInputSchema).optional()
    })
    .strict();

export const ClickOrderByRelationAggregateInputSchema: z.ZodType<Prisma.ClickOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const LinkCountOrderByAggregateInputSchema: z.ZodType<Prisma.LinkCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      url: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const LinkMaxOrderByAggregateInputSchema: z.ZodType<Prisma.LinkMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      url: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const LinkMinOrderByAggregateInputSchema: z.ZodType<Prisma.LinkMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      url: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ReservationListRelationFilterSchema: z.ZodType<Prisma.ReservationListRelationFilter> =
  z
    .object({
      every: z.lazy(() => ReservationWhereInputSchema).optional(),
      some: z.lazy(() => ReservationWhereInputSchema).optional(),
      none: z.lazy(() => ReservationWhereInputSchema).optional()
    })
    .strict();

export const CategoryListRelationFilterSchema: z.ZodType<Prisma.CategoryListRelationFilter> =
  z
    .object({
      every: z.lazy(() => CategoryWhereInputSchema).optional(),
      some: z.lazy(() => CategoryWhereInputSchema).optional(),
      none: z.lazy(() => CategoryWhereInputSchema).optional()
    })
    .strict();

export const InventoryListRelationFilterSchema: z.ZodType<Prisma.InventoryListRelationFilter> =
  z
    .object({
      every: z.lazy(() => InventoryWhereInputSchema).optional(),
      some: z.lazy(() => InventoryWhereInputSchema).optional(),
      none: z.lazy(() => InventoryWhereInputSchema).optional()
    })
    .strict();

export const ReservationOrderByRelationAggregateInputSchema: z.ZodType<Prisma.ReservationOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CategoryOrderByRelationAggregateInputSchema: z.ZodType<Prisma.CategoryOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const InventoryOrderByRelationAggregateInputSchema: z.ZodType<Prisma.InventoryOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const BlockCountOrderByAggregateInputSchema: z.ZodType<Prisma.BlockCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      position: z.lazy(() => SortOrderSchema).optional(),
      label: z.lazy(() => SortOrderSchema).optional(),
      href: z.lazy(() => SortOrderSchema).optional(),
      logo: z.lazy(() => SortOrderSchema).optional(),
      style: z.lazy(() => SortOrderSchema).optional(),
      widget: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const BlockAvgOrderByAggregateInputSchema: z.ZodType<Prisma.BlockAvgOrderByAggregateInput> =
  z
    .object({
      position: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const BlockMaxOrderByAggregateInputSchema: z.ZodType<Prisma.BlockMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      position: z.lazy(() => SortOrderSchema).optional(),
      label: z.lazy(() => SortOrderSchema).optional(),
      href: z.lazy(() => SortOrderSchema).optional(),
      logo: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const BlockMinOrderByAggregateInputSchema: z.ZodType<Prisma.BlockMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      position: z.lazy(() => SortOrderSchema).optional(),
      label: z.lazy(() => SortOrderSchema).optional(),
      href: z.lazy(() => SortOrderSchema).optional(),
      logo: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const BlockSumOrderByAggregateInputSchema: z.ZodType<Prisma.BlockSumOrderByAggregateInput> =
  z
    .object({
      position: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const LikeCountOrderByAggregateInputSchema: z.ZodType<Prisma.LikeCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      ip: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      feedId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const LikeMaxOrderByAggregateInputSchema: z.ZodType<Prisma.LikeMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      ip: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      feedId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const LikeMinOrderByAggregateInputSchema: z.ZodType<Prisma.LikeMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      ip: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      feedId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const BlockListRelationFilterSchema: z.ZodType<Prisma.BlockListRelationFilter> =
  z
    .object({
      every: z.lazy(() => BlockWhereInputSchema).optional(),
      some: z.lazy(() => BlockWhereInputSchema).optional(),
      none: z.lazy(() => BlockWhereInputSchema).optional()
    })
    .strict();

export const SubscriberListRelationFilterSchema: z.ZodType<Prisma.SubscriberListRelationFilter> =
  z
    .object({
      every: z.lazy(() => SubscriberWhereInputSchema).optional(),
      some: z.lazy(() => SubscriberWhereInputSchema).optional(),
      none: z.lazy(() => SubscriberWhereInputSchema).optional()
    })
    .strict();

export const FeedListRelationFilterSchema: z.ZodType<Prisma.FeedListRelationFilter> =
  z
    .object({
      every: z.lazy(() => FeedWhereInputSchema).optional(),
      some: z.lazy(() => FeedWhereInputSchema).optional(),
      none: z.lazy(() => FeedWhereInputSchema).optional()
    })
    .strict();

export const BlockOrderByRelationAggregateInputSchema: z.ZodType<Prisma.BlockOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const SubscriberOrderByRelationAggregateInputSchema: z.ZodType<Prisma.SubscriberOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const FeedOrderByRelationAggregateInputSchema: z.ZodType<Prisma.FeedOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const SiteCountOrderByAggregateInputSchema: z.ZodType<Prisma.SiteCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      display_name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      logo: z.lazy(() => SortOrderSchema).optional(),
      font: z.lazy(() => SortOrderSchema).optional(),
      image: z.lazy(() => SortOrderSchema).optional(),
      imageBlurhash: z.lazy(() => SortOrderSchema).optional(),
      subdomain: z.lazy(() => SortOrderSchema).optional(),
      customDomain: z.lazy(() => SortOrderSchema).optional(),
      message404: z.lazy(() => SortOrderSchema).optional(),
      background: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const SiteMaxOrderByAggregateInputSchema: z.ZodType<Prisma.SiteMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      display_name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      logo: z.lazy(() => SortOrderSchema).optional(),
      font: z.lazy(() => SortOrderSchema).optional(),
      image: z.lazy(() => SortOrderSchema).optional(),
      imageBlurhash: z.lazy(() => SortOrderSchema).optional(),
      subdomain: z.lazy(() => SortOrderSchema).optional(),
      customDomain: z.lazy(() => SortOrderSchema).optional(),
      message404: z.lazy(() => SortOrderSchema).optional(),
      background: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const SiteMinOrderByAggregateInputSchema: z.ZodType<Prisma.SiteMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      display_name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      logo: z.lazy(() => SortOrderSchema).optional(),
      font: z.lazy(() => SortOrderSchema).optional(),
      image: z.lazy(() => SortOrderSchema).optional(),
      imageBlurhash: z.lazy(() => SortOrderSchema).optional(),
      subdomain: z.lazy(() => SortOrderSchema).optional(),
      customDomain: z.lazy(() => SortOrderSchema).optional(),
      message404: z.lazy(() => SortOrderSchema).optional(),
      background: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const SubscriberCountOrderByAggregateInputSchema: z.ZodType<Prisma.SubscriberCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const SubscriberMaxOrderByAggregateInputSchema: z.ZodType<Prisma.SubscriberMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const SubscriberMinOrderByAggregateInputSchema: z.ZodType<Prisma.SubscriberMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      siteId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ReservationCountOrderByAggregateInputSchema: z.ZodType<Prisma.ReservationCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      dateStart: z.lazy(() => SortOrderSchema).optional(),
      dateEnd: z.lazy(() => SortOrderSchema).optional(),
      comment: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      blockId: z.lazy(() => SortOrderSchema).optional(),
      affiliateId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ReservationMaxOrderByAggregateInputSchema: z.ZodType<Prisma.ReservationMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      dateStart: z.lazy(() => SortOrderSchema).optional(),
      dateEnd: z.lazy(() => SortOrderSchema).optional(),
      comment: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      blockId: z.lazy(() => SortOrderSchema).optional(),
      affiliateId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ReservationMinOrderByAggregateInputSchema: z.ZodType<Prisma.ReservationMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      dateStart: z.lazy(() => SortOrderSchema).optional(),
      dateEnd: z.lazy(() => SortOrderSchema).optional(),
      comment: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      blockId: z.lazy(() => SortOrderSchema).optional(),
      affiliateId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CategoryNullableScalarRelationFilterSchema: z.ZodType<Prisma.CategoryNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => CategoryWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => CategoryWhereInputSchema)
        .optional()
        .nullable()
    })
    .strict();

export const BlockScalarRelationFilterSchema: z.ZodType<Prisma.BlockScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => BlockWhereInputSchema).optional(),
      isNot: z.lazy(() => BlockWhereInputSchema).optional()
    })
    .strict();

export const CategoryCountOrderByAggregateInputSchema: z.ZodType<Prisma.CategoryCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      position: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      categoryId: z.lazy(() => SortOrderSchema).optional(),
      blockId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CategoryAvgOrderByAggregateInputSchema: z.ZodType<Prisma.CategoryAvgOrderByAggregateInput> =
  z
    .object({
      position: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CategoryMaxOrderByAggregateInputSchema: z.ZodType<Prisma.CategoryMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      position: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      categoryId: z.lazy(() => SortOrderSchema).optional(),
      blockId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CategoryMinOrderByAggregateInputSchema: z.ZodType<Prisma.CategoryMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      position: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      categoryId: z.lazy(() => SortOrderSchema).optional(),
      blockId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CategorySumOrderByAggregateInputSchema: z.ZodType<Prisma.CategorySumOrderByAggregateInput> =
  z
    .object({
      position: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const FloatFilterSchema: z.ZodType<Prisma.FloatFilter> = z
  .object({
    equals: z.number().optional(),
    in: z.number().array().optional(),
    notIn: z.number().array().optional(),
    lt: z.number().optional(),
    lte: z.number().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    not: z.union([z.number(), z.lazy(() => NestedFloatFilterSchema)]).optional()
  })
  .strict();

export const StringNullableListFilterSchema: z.ZodType<Prisma.StringNullableListFilter> =
  z
    .object({
      equals: z.string().array().optional().nullable(),
      has: z.string().optional().nullable(),
      hasEvery: z.string().array().optional(),
      hasSome: z.string().array().optional(),
      isEmpty: z.boolean().optional()
    })
    .strict();

export const InventoryVariantListRelationFilterSchema: z.ZodType<Prisma.InventoryVariantListRelationFilter> =
  z
    .object({
      every: z.lazy(() => InventoryVariantWhereInputSchema).optional(),
      some: z.lazy(() => InventoryVariantWhereInputSchema).optional(),
      none: z.lazy(() => InventoryVariantWhereInputSchema).optional()
    })
    .strict();

export const InventoryVariantOrderByRelationAggregateInputSchema: z.ZodType<Prisma.InventoryVariantOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const InventoryCountOrderByAggregateInputSchema: z.ZodType<Prisma.InventoryCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      sku: z.lazy(() => SortOrderSchema).optional(),
      basePrice: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      isFeatured: z.lazy(() => SortOrderSchema).optional(),
      metaTitle: z.lazy(() => SortOrderSchema).optional(),
      metaDescription: z.lazy(() => SortOrderSchema).optional(),
      tags: z.lazy(() => SortOrderSchema).optional(),
      stock: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      categoryId: z.lazy(() => SortOrderSchema).optional(),
      blockId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const InventoryAvgOrderByAggregateInputSchema: z.ZodType<Prisma.InventoryAvgOrderByAggregateInput> =
  z
    .object({
      basePrice: z.lazy(() => SortOrderSchema).optional(),
      stock: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const InventoryMaxOrderByAggregateInputSchema: z.ZodType<Prisma.InventoryMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      sku: z.lazy(() => SortOrderSchema).optional(),
      basePrice: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      isFeatured: z.lazy(() => SortOrderSchema).optional(),
      metaTitle: z.lazy(() => SortOrderSchema).optional(),
      metaDescription: z.lazy(() => SortOrderSchema).optional(),
      stock: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      categoryId: z.lazy(() => SortOrderSchema).optional(),
      blockId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const InventoryMinOrderByAggregateInputSchema: z.ZodType<Prisma.InventoryMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      slug: z.lazy(() => SortOrderSchema).optional(),
      sku: z.lazy(() => SortOrderSchema).optional(),
      basePrice: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      isFeatured: z.lazy(() => SortOrderSchema).optional(),
      metaTitle: z.lazy(() => SortOrderSchema).optional(),
      metaDescription: z.lazy(() => SortOrderSchema).optional(),
      stock: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      categoryId: z.lazy(() => SortOrderSchema).optional(),
      blockId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const InventorySumOrderByAggregateInputSchema: z.ZodType<Prisma.InventorySumOrderByAggregateInput> =
  z
    .object({
      basePrice: z.lazy(() => SortOrderSchema).optional(),
      stock: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const FloatWithAggregatesFilterSchema: z.ZodType<Prisma.FloatWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional(),
      in: z.number().array().optional(),
      notIn: z.number().array().optional(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([
          z.number(),
          z.lazy(() => NestedFloatWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatFilterSchema).optional(),
      _sum: z.lazy(() => NestedFloatFilterSchema).optional(),
      _min: z.lazy(() => NestedFloatFilterSchema).optional(),
      _max: z.lazy(() => NestedFloatFilterSchema).optional()
    })
    .strict();

export const EnumVariantTypeFilterSchema: z.ZodType<Prisma.EnumVariantTypeFilter> =
  z
    .object({
      equals: z.lazy(() => VariantTypeSchema).optional(),
      in: z
        .lazy(() => VariantTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => VariantTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => VariantTypeSchema),
          z.lazy(() => NestedEnumVariantTypeFilterSchema)
        ])
        .optional()
    })
    .strict();

export const DecimalNullableFilterSchema: z.ZodType<Prisma.DecimalNullableFilter> =
  z
    .object({
      equals: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional()
        .nullable(),
      in: z
        .union([
          z.number().array(),
          z.string().array(),
          z.instanceof(Decimal).array(),
          z.instanceof(Prisma.Decimal).array(),
          DecimalJsLikeSchema.array()
        ])
        .refine(
          v =>
            Array.isArray(v) && (v as any[]).every(v => isValidDecimalInput(v)),
          { message: 'Must be a Decimal' }
        )
        .optional()
        .nullable(),
      notIn: z
        .union([
          z.number().array(),
          z.string().array(),
          z.instanceof(Decimal).array(),
          z.instanceof(Prisma.Decimal).array(),
          DecimalJsLikeSchema.array()
        ])
        .refine(
          v =>
            Array.isArray(v) && (v as any[]).every(v => isValidDecimalInput(v)),
          { message: 'Must be a Decimal' }
        )
        .optional()
        .nullable(),
      lt: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      lte: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      gt: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      gte: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      not: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema
            ])
            .refine(v => isValidDecimalInput(v), {
              message: 'Must be a Decimal'
            }),
          z.lazy(() => NestedDecimalNullableFilterSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const InventoryScalarRelationFilterSchema: z.ZodType<Prisma.InventoryScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => InventoryWhereInputSchema).optional(),
      isNot: z.lazy(() => InventoryWhereInputSchema).optional()
    })
    .strict();

export const InventoryVariantInventoryIdTypeValueCompoundUniqueInputSchema: z.ZodType<Prisma.InventoryVariantInventoryIdTypeValueCompoundUniqueInput> =
  z
    .object({
      inventoryId: z.string(),
      type: z.lazy(() => VariantTypeSchema),
      value: z.string()
    })
    .strict();

export const InventoryVariantCountOrderByAggregateInputSchema: z.ZodType<Prisma.InventoryVariantCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      inventoryId: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      value: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      stock: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      position: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const InventoryVariantAvgOrderByAggregateInputSchema: z.ZodType<Prisma.InventoryVariantAvgOrderByAggregateInput> =
  z
    .object({
      price: z.lazy(() => SortOrderSchema).optional(),
      stock: z.lazy(() => SortOrderSchema).optional(),
      position: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const InventoryVariantMaxOrderByAggregateInputSchema: z.ZodType<Prisma.InventoryVariantMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      inventoryId: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      value: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      stock: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      position: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const InventoryVariantMinOrderByAggregateInputSchema: z.ZodType<Prisma.InventoryVariantMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      inventoryId: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      value: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      stock: z.lazy(() => SortOrderSchema).optional(),
      active: z.lazy(() => SortOrderSchema).optional(),
      position: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const InventoryVariantSumOrderByAggregateInputSchema: z.ZodType<Prisma.InventoryVariantSumOrderByAggregateInput> =
  z
    .object({
      price: z.lazy(() => SortOrderSchema).optional(),
      stock: z.lazy(() => SortOrderSchema).optional(),
      position: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const EnumVariantTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumVariantTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => VariantTypeSchema).optional(),
      in: z
        .lazy(() => VariantTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => VariantTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => VariantTypeSchema),
          z.lazy(() => NestedEnumVariantTypeWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumVariantTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumVariantTypeFilterSchema).optional()
    })
    .strict();

export const DecimalNullableWithAggregatesFilterSchema: z.ZodType<Prisma.DecimalNullableWithAggregatesFilter> =
  z
    .object({
      equals: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional()
        .nullable(),
      in: z
        .union([
          z.number().array(),
          z.string().array(),
          z.instanceof(Decimal).array(),
          z.instanceof(Prisma.Decimal).array(),
          DecimalJsLikeSchema.array()
        ])
        .refine(
          v =>
            Array.isArray(v) && (v as any[]).every(v => isValidDecimalInput(v)),
          { message: 'Must be a Decimal' }
        )
        .optional()
        .nullable(),
      notIn: z
        .union([
          z.number().array(),
          z.string().array(),
          z.instanceof(Decimal).array(),
          z.instanceof(Prisma.Decimal).array(),
          DecimalJsLikeSchema.array()
        ])
        .refine(
          v =>
            Array.isArray(v) && (v as any[]).every(v => isValidDecimalInput(v)),
          { message: 'Must be a Decimal' }
        )
        .optional()
        .nullable(),
      lt: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      lte: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      gt: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      gte: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      not: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema
            ])
            .refine(v => isValidDecimalInput(v), {
              message: 'Must be a Decimal'
            }),
          z.lazy(() => NestedDecimalNullableWithAggregatesFilterSchema)
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _avg: z.lazy(() => NestedDecimalNullableFilterSchema).optional(),
      _sum: z.lazy(() => NestedDecimalNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedDecimalNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedDecimalNullableFilterSchema).optional()
    })
    .strict();

export const HistoryListRelationFilterSchema: z.ZodType<Prisma.HistoryListRelationFilter> =
  z
    .object({
      every: z.lazy(() => HistoryWhereInputSchema).optional(),
      some: z.lazy(() => HistoryWhereInputSchema).optional(),
      none: z.lazy(() => HistoryWhereInputSchema).optional()
    })
    .strict();

export const HistoryOrderByRelationAggregateInputSchema: z.ZodType<Prisma.HistoryOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CronCountOrderByAggregateInputSchema: z.ZodType<Prisma.CronCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      cronExpr: z.lazy(() => SortOrderSchema).optional(),
      timezone: z.lazy(() => SortOrderSchema).optional(),
      modulePath: z.lazy(() => SortOrderSchema).optional(),
      functionName: z.lazy(() => SortOrderSchema).optional(),
      enabled: z.lazy(() => SortOrderSchema).optional(),
      lastRunAt: z.lazy(() => SortOrderSchema).optional(),
      lastStatus: z.lazy(() => SortOrderSchema).optional(),
      lastDurationMs: z.lazy(() => SortOrderSchema).optional(),
      lockedAt: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CronAvgOrderByAggregateInputSchema: z.ZodType<Prisma.CronAvgOrderByAggregateInput> =
  z
    .object({
      lastDurationMs: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CronMaxOrderByAggregateInputSchema: z.ZodType<Prisma.CronMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      cronExpr: z.lazy(() => SortOrderSchema).optional(),
      timezone: z.lazy(() => SortOrderSchema).optional(),
      modulePath: z.lazy(() => SortOrderSchema).optional(),
      functionName: z.lazy(() => SortOrderSchema).optional(),
      enabled: z.lazy(() => SortOrderSchema).optional(),
      lastRunAt: z.lazy(() => SortOrderSchema).optional(),
      lastStatus: z.lazy(() => SortOrderSchema).optional(),
      lastDurationMs: z.lazy(() => SortOrderSchema).optional(),
      lockedAt: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CronMinOrderByAggregateInputSchema: z.ZodType<Prisma.CronMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      cronExpr: z.lazy(() => SortOrderSchema).optional(),
      timezone: z.lazy(() => SortOrderSchema).optional(),
      modulePath: z.lazy(() => SortOrderSchema).optional(),
      functionName: z.lazy(() => SortOrderSchema).optional(),
      enabled: z.lazy(() => SortOrderSchema).optional(),
      lastRunAt: z.lazy(() => SortOrderSchema).optional(),
      lastStatus: z.lazy(() => SortOrderSchema).optional(),
      lastDurationMs: z.lazy(() => SortOrderSchema).optional(),
      lockedAt: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CronSumOrderByAggregateInputSchema: z.ZodType<Prisma.CronSumOrderByAggregateInput> =
  z
    .object({
      lastDurationMs: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const CronScalarRelationFilterSchema: z.ZodType<Prisma.CronScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => CronWhereInputSchema).optional(),
      isNot: z.lazy(() => CronWhereInputSchema).optional()
    })
    .strict();

export const HistoryCountOrderByAggregateInputSchema: z.ZodType<Prisma.HistoryCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      startedAt: z.lazy(() => SortOrderSchema).optional(),
      endedAt: z.lazy(() => SortOrderSchema).optional(),
      durationMs: z.lazy(() => SortOrderSchema).optional(),
      message: z.lazy(() => SortOrderSchema).optional(),
      cronId: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const HistoryAvgOrderByAggregateInputSchema: z.ZodType<Prisma.HistoryAvgOrderByAggregateInput> =
  z
    .object({
      durationMs: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const HistoryMaxOrderByAggregateInputSchema: z.ZodType<Prisma.HistoryMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      startedAt: z.lazy(() => SortOrderSchema).optional(),
      endedAt: z.lazy(() => SortOrderSchema).optional(),
      durationMs: z.lazy(() => SortOrderSchema).optional(),
      cronId: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const HistoryMinOrderByAggregateInputSchema: z.ZodType<Prisma.HistoryMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      startedAt: z.lazy(() => SortOrderSchema).optional(),
      endedAt: z.lazy(() => SortOrderSchema).optional(),
      durationMs: z.lazy(() => SortOrderSchema).optional(),
      cronId: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const HistorySumOrderByAggregateInputSchema: z.ZodType<Prisma.HistorySumOrderByAggregateInput> =
  z
    .object({
      durationMs: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const BoolNullableFilterSchema: z.ZodType<Prisma.BoolNullableFilter> = z
  .object({
    equals: z.boolean().optional().nullable(),
    not: z
      .union([z.boolean(), z.lazy(() => NestedBoolNullableFilterSchema)])
      .optional()
      .nullable()
  })
  .strict();

export const EnumUserRoleFilterSchema: z.ZodType<Prisma.EnumUserRoleFilter> = z
  .object({
    equals: z.lazy(() => UserRoleSchema).optional(),
    in: z
      .lazy(() => UserRoleSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => UserRoleSchema)
      .array()
      .optional(),
    not: z
      .union([
        z.lazy(() => UserRoleSchema),
        z.lazy(() => NestedEnumUserRoleFilterSchema)
      ])
      .optional()
  })
  .strict();

export const AccountListRelationFilterSchema: z.ZodType<Prisma.AccountListRelationFilter> =
  z
    .object({
      every: z.lazy(() => AccountWhereInputSchema).optional(),
      some: z.lazy(() => AccountWhereInputSchema).optional(),
      none: z.lazy(() => AccountWhereInputSchema).optional()
    })
    .strict();

export const SessionListRelationFilterSchema: z.ZodType<Prisma.SessionListRelationFilter> =
  z
    .object({
      every: z.lazy(() => SessionWhereInputSchema).optional(),
      some: z.lazy(() => SessionWhereInputSchema).optional(),
      none: z.lazy(() => SessionWhereInputSchema).optional()
    })
    .strict();

export const SiteListRelationFilterSchema: z.ZodType<Prisma.SiteListRelationFilter> =
  z
    .object({
      every: z.lazy(() => SiteWhereInputSchema).optional(),
      some: z.lazy(() => SiteWhereInputSchema).optional(),
      none: z.lazy(() => SiteWhereInputSchema).optional()
    })
    .strict();

export const AuthenticatorListRelationFilterSchema: z.ZodType<Prisma.AuthenticatorListRelationFilter> =
  z
    .object({
      every: z.lazy(() => AuthenticatorWhereInputSchema).optional(),
      some: z.lazy(() => AuthenticatorWhereInputSchema).optional(),
      none: z.lazy(() => AuthenticatorWhereInputSchema).optional()
    })
    .strict();

export const LinkListRelationFilterSchema: z.ZodType<Prisma.LinkListRelationFilter> =
  z
    .object({
      every: z.lazy(() => LinkWhereInputSchema).optional(),
      some: z.lazy(() => LinkWhereInputSchema).optional(),
      none: z.lazy(() => LinkWhereInputSchema).optional()
    })
    .strict();

export const CustomerNullableScalarRelationFilterSchema: z.ZodType<Prisma.CustomerNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => CustomerWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => CustomerWhereInputSchema)
        .optional()
        .nullable()
    })
    .strict();

export const TwoFactorConfirmationNullableScalarRelationFilterSchema: z.ZodType<Prisma.TwoFactorConfirmationNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => TwoFactorConfirmationWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => TwoFactorConfirmationWhereInputSchema)
        .optional()
        .nullable()
    })
    .strict();

export const NafCodeNullableScalarRelationFilterSchema: z.ZodType<Prisma.NafCodeNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => NafCodeWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => NafCodeWhereInputSchema)
        .optional()
        .nullable()
    })
    .strict();

export const FeedbackListRelationFilterSchema: z.ZodType<Prisma.FeedbackListRelationFilter> =
  z
    .object({
      every: z.lazy(() => FeedbackWhereInputSchema).optional(),
      some: z.lazy(() => FeedbackWhereInputSchema).optional(),
      none: z.lazy(() => FeedbackWhereInputSchema).optional()
    })
    .strict();

export const EventListRelationFilterSchema: z.ZodType<Prisma.EventListRelationFilter> =
  z
    .object({
      every: z.lazy(() => EventWhereInputSchema).optional(),
      some: z.lazy(() => EventWhereInputSchema).optional(),
      none: z.lazy(() => EventWhereInputSchema).optional()
    })
    .strict();

export const WorkflowStateListRelationFilterSchema: z.ZodType<Prisma.WorkflowStateListRelationFilter> =
  z
    .object({
      every: z.lazy(() => WorkflowStateWhereInputSchema).optional(),
      some: z.lazy(() => WorkflowStateWhereInputSchema).optional(),
      none: z.lazy(() => WorkflowStateWhereInputSchema).optional()
    })
    .strict();

export const ExecutionListRelationFilterSchema: z.ZodType<Prisma.ExecutionListRelationFilter> =
  z
    .object({
      every: z.lazy(() => ExecutionWhereInputSchema).optional(),
      some: z.lazy(() => ExecutionWhereInputSchema).optional(),
      none: z.lazy(() => ExecutionWhereInputSchema).optional()
    })
    .strict();

export const QueueListRelationFilterSchema: z.ZodType<Prisma.QueueListRelationFilter> =
  z
    .object({
      every: z.lazy(() => QueueWhereInputSchema).optional(),
      some: z.lazy(() => QueueWhereInputSchema).optional(),
      none: z.lazy(() => QueueWhereInputSchema).optional()
    })
    .strict();

export const MessageListRelationFilterSchema: z.ZodType<Prisma.MessageListRelationFilter> =
  z
    .object({
      every: z.lazy(() => MessageWhereInputSchema).optional(),
      some: z.lazy(() => MessageWhereInputSchema).optional(),
      none: z.lazy(() => MessageWhereInputSchema).optional()
    })
    .strict();

export const ListListRelationFilterSchema: z.ZodType<Prisma.ListListRelationFilter> =
  z
    .object({
      every: z.lazy(() => ListWhereInputSchema).optional(),
      some: z.lazy(() => ListWhereInputSchema).optional(),
      none: z.lazy(() => ListWhereInputSchema).optional()
    })
    .strict();

export const EmailListRelationFilterSchema: z.ZodType<Prisma.EmailListRelationFilter> =
  z
    .object({
      every: z.lazy(() => EmailWhereInputSchema).optional(),
      some: z.lazy(() => EmailWhereInputSchema).optional(),
      none: z.lazy(() => EmailWhereInputSchema).optional()
    })
    .strict();

export const AccountOrderByRelationAggregateInputSchema: z.ZodType<Prisma.AccountOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const SessionOrderByRelationAggregateInputSchema: z.ZodType<Prisma.SessionOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const SiteOrderByRelationAggregateInputSchema: z.ZodType<Prisma.SiteOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const AuthenticatorOrderByRelationAggregateInputSchema: z.ZodType<Prisma.AuthenticatorOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const LinkOrderByRelationAggregateInputSchema: z.ZodType<Prisma.LinkOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const FeedbackOrderByRelationAggregateInputSchema: z.ZodType<Prisma.FeedbackOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const EventOrderByRelationAggregateInputSchema: z.ZodType<Prisma.EventOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const WorkflowStateOrderByRelationAggregateInputSchema: z.ZodType<Prisma.WorkflowStateOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ExecutionOrderByRelationAggregateInputSchema: z.ZodType<Prisma.ExecutionOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const QueueOrderByRelationAggregateInputSchema: z.ZodType<Prisma.QueueOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const MessageOrderByRelationAggregateInputSchema: z.ZodType<Prisma.MessageOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ListOrderByRelationAggregateInputSchema: z.ZodType<Prisma.ListOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const EmailOrderByRelationAggregateInputSchema: z.ZodType<Prisma.EmailOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const UserCountOrderByAggregateInputSchema: z.ZodType<Prisma.UserCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      emailVerified: z.lazy(() => SortOrderSchema).optional(),
      image: z.lazy(() => SortOrderSchema).optional(),
      isTwoFactorEnabled: z.lazy(() => SortOrderSchema).optional(),
      billing_address: z.lazy(() => SortOrderSchema).optional(),
      payment_method: z.lazy(() => SortOrderSchema).optional(),
      company: z.lazy(() => SortOrderSchema).optional(),
      address: z.lazy(() => SortOrderSchema).optional(),
      location: z.lazy(() => SortOrderSchema).optional(),
      postcode: z.lazy(() => SortOrderSchema).optional(),
      city: z.lazy(() => SortOrderSchema).optional(),
      phone: z.lazy(() => SortOrderSchema).optional(),
      activity: z.lazy(() => SortOrderSchema).optional(),
      bounced: z.lazy(() => SortOrderSchema).optional(),
      affiliateRate: z.lazy(() => SortOrderSchema).optional(),
      isAnonymous: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      refererId: z.lazy(() => SortOrderSchema).optional(),
      codeNaf: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const UserAvgOrderByAggregateInputSchema: z.ZodType<Prisma.UserAvgOrderByAggregateInput> =
  z
    .object({
      bounced: z.lazy(() => SortOrderSchema).optional(),
      affiliateRate: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const UserMaxOrderByAggregateInputSchema: z.ZodType<Prisma.UserMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      emailVerified: z.lazy(() => SortOrderSchema).optional(),
      image: z.lazy(() => SortOrderSchema).optional(),
      isTwoFactorEnabled: z.lazy(() => SortOrderSchema).optional(),
      company: z.lazy(() => SortOrderSchema).optional(),
      address: z.lazy(() => SortOrderSchema).optional(),
      postcode: z.lazy(() => SortOrderSchema).optional(),
      city: z.lazy(() => SortOrderSchema).optional(),
      phone: z.lazy(() => SortOrderSchema).optional(),
      activity: z.lazy(() => SortOrderSchema).optional(),
      bounced: z.lazy(() => SortOrderSchema).optional(),
      affiliateRate: z.lazy(() => SortOrderSchema).optional(),
      isAnonymous: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      refererId: z.lazy(() => SortOrderSchema).optional(),
      codeNaf: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const UserMinOrderByAggregateInputSchema: z.ZodType<Prisma.UserMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      emailVerified: z.lazy(() => SortOrderSchema).optional(),
      image: z.lazy(() => SortOrderSchema).optional(),
      isTwoFactorEnabled: z.lazy(() => SortOrderSchema).optional(),
      company: z.lazy(() => SortOrderSchema).optional(),
      address: z.lazy(() => SortOrderSchema).optional(),
      postcode: z.lazy(() => SortOrderSchema).optional(),
      city: z.lazy(() => SortOrderSchema).optional(),
      phone: z.lazy(() => SortOrderSchema).optional(),
      activity: z.lazy(() => SortOrderSchema).optional(),
      bounced: z.lazy(() => SortOrderSchema).optional(),
      affiliateRate: z.lazy(() => SortOrderSchema).optional(),
      isAnonymous: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      refererId: z.lazy(() => SortOrderSchema).optional(),
      codeNaf: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const UserSumOrderByAggregateInputSchema: z.ZodType<Prisma.UserSumOrderByAggregateInput> =
  z
    .object({
      bounced: z.lazy(() => SortOrderSchema).optional(),
      affiliateRate: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const BoolNullableWithAggregatesFilterSchema: z.ZodType<Prisma.BoolNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.boolean().optional().nullable(),
      not: z
        .union([
          z.boolean(),
          z.lazy(() => NestedBoolNullableWithAggregatesFilterSchema)
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedBoolNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedBoolNullableFilterSchema).optional()
    })
    .strict();

export const EnumUserRoleWithAggregatesFilterSchema: z.ZodType<Prisma.EnumUserRoleWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => UserRoleSchema).optional(),
      in: z
        .lazy(() => UserRoleSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => UserRoleSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => NestedEnumUserRoleWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumUserRoleFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumUserRoleFilterSchema).optional()
    })
    .strict();

export const MessageCountOrderByAggregateInputSchema: z.ZodType<Prisma.MessageCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      senderEmail: z.lazy(() => SortOrderSchema).optional(),
      receiveEmail: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const MessageMaxOrderByAggregateInputSchema: z.ZodType<Prisma.MessageMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      senderEmail: z.lazy(() => SortOrderSchema).optional(),
      receiveEmail: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const MessageMinOrderByAggregateInputSchema: z.ZodType<Prisma.MessageMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      senderEmail: z.lazy(() => SortOrderSchema).optional(),
      receiveEmail: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const FeedbackCountOrderByAggregateInputSchema: z.ZodType<Prisma.FeedbackCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      message: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const FeedbackMaxOrderByAggregateInputSchema: z.ZodType<Prisma.FeedbackMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      message: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const FeedbackMinOrderByAggregateInputSchema: z.ZodType<Prisma.FeedbackMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      message: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const QueueCountOrderByAggregateInputSchema: z.ZodType<Prisma.QueueCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      job: z.lazy(() => SortOrderSchema).optional(),
      payload: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      attempts: z.lazy(() => SortOrderSchema).optional(),
      lastError: z.lazy(() => SortOrderSchema).optional(),
      runAt: z.lazy(() => SortOrderSchema).optional(),
      priority: z.lazy(() => SortOrderSchema).optional(),
      processingStartedAt: z.lazy(() => SortOrderSchema).optional(),
      correlationId: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const QueueAvgOrderByAggregateInputSchema: z.ZodType<Prisma.QueueAvgOrderByAggregateInput> =
  z
    .object({
      attempts: z.lazy(() => SortOrderSchema).optional(),
      priority: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const QueueMaxOrderByAggregateInputSchema: z.ZodType<Prisma.QueueMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      job: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      attempts: z.lazy(() => SortOrderSchema).optional(),
      lastError: z.lazy(() => SortOrderSchema).optional(),
      runAt: z.lazy(() => SortOrderSchema).optional(),
      priority: z.lazy(() => SortOrderSchema).optional(),
      processingStartedAt: z.lazy(() => SortOrderSchema).optional(),
      correlationId: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const QueueMinOrderByAggregateInputSchema: z.ZodType<Prisma.QueueMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      job: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      attempts: z.lazy(() => SortOrderSchema).optional(),
      lastError: z.lazy(() => SortOrderSchema).optional(),
      runAt: z.lazy(() => SortOrderSchema).optional(),
      priority: z.lazy(() => SortOrderSchema).optional(),
      processingStartedAt: z.lazy(() => SortOrderSchema).optional(),
      correlationId: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const QueueSumOrderByAggregateInputSchema: z.ZodType<Prisma.QueueSumOrderByAggregateInput> =
  z
    .object({
      attempts: z.lazy(() => SortOrderSchema).optional(),
      priority: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const RuleListRelationFilterSchema: z.ZodType<Prisma.RuleListRelationFilter> =
  z
    .object({
      every: z.lazy(() => RuleWhereInputSchema).optional(),
      some: z.lazy(() => RuleWhereInputSchema).optional(),
      none: z.lazy(() => RuleWhereInputSchema).optional()
    })
    .strict();

export const RuleOrderByRelationAggregateInputSchema: z.ZodType<Prisma.RuleOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ActionCountOrderByAggregateInputSchema: z.ZodType<Prisma.ActionCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      code: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      config: z.lazy(() => SortOrderSchema).optional(),
      isPublished: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ActionAvgOrderByAggregateInputSchema: z.ZodType<Prisma.ActionAvgOrderByAggregateInput> =
  z
    .object({
      version: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ActionMaxOrderByAggregateInputSchema: z.ZodType<Prisma.ActionMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      code: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      isPublished: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ActionMinOrderByAggregateInputSchema: z.ZodType<Prisma.ActionMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      code: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      isPublished: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ActionSumOrderByAggregateInputSchema: z.ZodType<Prisma.ActionSumOrderByAggregateInput> =
  z
    .object({
      version: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const WorkflowCountOrderByAggregateInputSchema: z.ZodType<Prisma.WorkflowCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      isDefault: z.lazy(() => SortOrderSchema).optional(),
      isActive: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const WorkflowMaxOrderByAggregateInputSchema: z.ZodType<Prisma.WorkflowMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      isDefault: z.lazy(() => SortOrderSchema).optional(),
      isActive: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const WorkflowMinOrderByAggregateInputSchema: z.ZodType<Prisma.WorkflowMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      isDefault: z.lazy(() => SortOrderSchema).optional(),
      isActive: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const TriggerCountOrderByAggregateInputSchema: z.ZodType<Prisma.TriggerCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      code: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const TriggerMaxOrderByAggregateInputSchema: z.ZodType<Prisma.TriggerMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      code: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const TriggerMinOrderByAggregateInputSchema: z.ZodType<Prisma.TriggerMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      code: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const RuleConditionListRelationFilterSchema: z.ZodType<Prisma.RuleConditionListRelationFilter> =
  z
    .object({
      every: z.lazy(() => RuleConditionWhereInputSchema).optional(),
      some: z.lazy(() => RuleConditionWhereInputSchema).optional(),
      none: z.lazy(() => RuleConditionWhereInputSchema).optional()
    })
    .strict();

export const WorkflowScalarRelationFilterSchema: z.ZodType<Prisma.WorkflowScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => WorkflowWhereInputSchema).optional(),
      isNot: z.lazy(() => WorkflowWhereInputSchema).optional()
    })
    .strict();

export const ActionScalarRelationFilterSchema: z.ZodType<Prisma.ActionScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => ActionWhereInputSchema).optional(),
      isNot: z.lazy(() => ActionWhereInputSchema).optional()
    })
    .strict();

export const TriggerScalarRelationFilterSchema: z.ZodType<Prisma.TriggerScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => TriggerWhereInputSchema).optional(),
      isNot: z.lazy(() => TriggerWhereInputSchema).optional()
    })
    .strict();

export const RuleConditionOrderByRelationAggregateInputSchema: z.ZodType<Prisma.RuleConditionOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const RuleCountOrderByAggregateInputSchema: z.ZodType<Prisma.RuleCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      workflowId: z.lazy(() => SortOrderSchema).optional(),
      actionId: z.lazy(() => SortOrderSchema).optional(),
      triggerId: z.lazy(() => SortOrderSchema).optional(),
      delayMinutes: z.lazy(() => SortOrderSchema).optional(),
      order: z.lazy(() => SortOrderSchema).optional(),
      isActive: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const RuleAvgOrderByAggregateInputSchema: z.ZodType<Prisma.RuleAvgOrderByAggregateInput> =
  z
    .object({
      delayMinutes: z.lazy(() => SortOrderSchema).optional(),
      order: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const RuleMaxOrderByAggregateInputSchema: z.ZodType<Prisma.RuleMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      workflowId: z.lazy(() => SortOrderSchema).optional(),
      actionId: z.lazy(() => SortOrderSchema).optional(),
      triggerId: z.lazy(() => SortOrderSchema).optional(),
      delayMinutes: z.lazy(() => SortOrderSchema).optional(),
      order: z.lazy(() => SortOrderSchema).optional(),
      isActive: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const RuleMinOrderByAggregateInputSchema: z.ZodType<Prisma.RuleMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      workflowId: z.lazy(() => SortOrderSchema).optional(),
      actionId: z.lazy(() => SortOrderSchema).optional(),
      triggerId: z.lazy(() => SortOrderSchema).optional(),
      delayMinutes: z.lazy(() => SortOrderSchema).optional(),
      order: z.lazy(() => SortOrderSchema).optional(),
      isActive: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const RuleSumOrderByAggregateInputSchema: z.ZodType<Prisma.RuleSumOrderByAggregateInput> =
  z
    .object({
      delayMinutes: z.lazy(() => SortOrderSchema).optional(),
      order: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const EnumConditionTypeFilterSchema: z.ZodType<Prisma.EnumConditionTypeFilter> =
  z
    .object({
      equals: z.lazy(() => ConditionTypeSchema).optional(),
      in: z
        .lazy(() => ConditionTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ConditionTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ConditionTypeSchema),
          z.lazy(() => NestedEnumConditionTypeFilterSchema)
        ])
        .optional()
    })
    .strict();

export const ConditionCountOrderByAggregateInputSchema: z.ZodType<Prisma.ConditionCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      parameters: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ConditionMaxOrderByAggregateInputSchema: z.ZodType<Prisma.ConditionMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ConditionMinOrderByAggregateInputSchema: z.ZodType<Prisma.ConditionMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const EnumConditionTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumConditionTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => ConditionTypeSchema).optional(),
      in: z
        .lazy(() => ConditionTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ConditionTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ConditionTypeSchema),
          z.lazy(() => NestedEnumConditionTypeWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumConditionTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumConditionTypeFilterSchema).optional()
    })
    .strict();

export const EnumOperatorFilterSchema: z.ZodType<Prisma.EnumOperatorFilter> = z
  .object({
    equals: z.lazy(() => OperatorSchema).optional(),
    in: z
      .lazy(() => OperatorSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => OperatorSchema)
      .array()
      .optional(),
    not: z
      .union([
        z.lazy(() => OperatorSchema),
        z.lazy(() => NestedEnumOperatorFilterSchema)
      ])
      .optional()
  })
  .strict();

export const RuleScalarRelationFilterSchema: z.ZodType<Prisma.RuleScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => RuleWhereInputSchema).optional(),
      isNot: z.lazy(() => RuleWhereInputSchema).optional()
    })
    .strict();

export const ConditionScalarRelationFilterSchema: z.ZodType<Prisma.ConditionScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => ConditionWhereInputSchema).optional(),
      isNot: z.lazy(() => ConditionWhereInputSchema).optional()
    })
    .strict();

export const RuleConditionRuleIdConditionIdCompoundUniqueInputSchema: z.ZodType<Prisma.RuleConditionRuleIdConditionIdCompoundUniqueInput> =
  z
    .object({
      ruleId: z.string(),
      conditionId: z.string()
    })
    .strict();

export const RuleConditionCountOrderByAggregateInputSchema: z.ZodType<Prisma.RuleConditionCountOrderByAggregateInput> =
  z
    .object({
      ruleId: z.lazy(() => SortOrderSchema).optional(),
      conditionId: z.lazy(() => SortOrderSchema).optional(),
      group: z.lazy(() => SortOrderSchema).optional(),
      logic: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const RuleConditionAvgOrderByAggregateInputSchema: z.ZodType<Prisma.RuleConditionAvgOrderByAggregateInput> =
  z
    .object({
      group: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const RuleConditionMaxOrderByAggregateInputSchema: z.ZodType<Prisma.RuleConditionMaxOrderByAggregateInput> =
  z
    .object({
      ruleId: z.lazy(() => SortOrderSchema).optional(),
      conditionId: z.lazy(() => SortOrderSchema).optional(),
      group: z.lazy(() => SortOrderSchema).optional(),
      logic: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const RuleConditionMinOrderByAggregateInputSchema: z.ZodType<Prisma.RuleConditionMinOrderByAggregateInput> =
  z
    .object({
      ruleId: z.lazy(() => SortOrderSchema).optional(),
      conditionId: z.lazy(() => SortOrderSchema).optional(),
      group: z.lazy(() => SortOrderSchema).optional(),
      logic: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const RuleConditionSumOrderByAggregateInputSchema: z.ZodType<Prisma.RuleConditionSumOrderByAggregateInput> =
  z
    .object({
      group: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const EnumOperatorWithAggregatesFilterSchema: z.ZodType<Prisma.EnumOperatorWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => OperatorSchema).optional(),
      in: z
        .lazy(() => OperatorSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => OperatorSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => OperatorSchema),
          z.lazy(() => NestedEnumOperatorWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumOperatorFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumOperatorFilterSchema).optional()
    })
    .strict();

export const EventCountOrderByAggregateInputSchema: z.ZodType<Prisma.EventCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      eventType: z.lazy(() => SortOrderSchema).optional(),
      payload: z.lazy(() => SortOrderSchema).optional(),
      correlationId: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      attempts: z.lazy(() => SortOrderSchema).optional(),
      lastError: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const EventAvgOrderByAggregateInputSchema: z.ZodType<Prisma.EventAvgOrderByAggregateInput> =
  z
    .object({
      attempts: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const EventMaxOrderByAggregateInputSchema: z.ZodType<Prisma.EventMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      eventType: z.lazy(() => SortOrderSchema).optional(),
      correlationId: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      attempts: z.lazy(() => SortOrderSchema).optional(),
      lastError: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const EventMinOrderByAggregateInputSchema: z.ZodType<Prisma.EventMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      eventType: z.lazy(() => SortOrderSchema).optional(),
      correlationId: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      attempts: z.lazy(() => SortOrderSchema).optional(),
      lastError: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const EventSumOrderByAggregateInputSchema: z.ZodType<Prisma.EventSumOrderByAggregateInput> =
  z
    .object({
      attempts: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const EnumWorkflowStateStatusFilterSchema: z.ZodType<Prisma.EnumWorkflowStateStatusFilter> =
  z
    .object({
      equals: z.lazy(() => WorkflowStateStatusSchema).optional(),
      in: z
        .lazy(() => WorkflowStateStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => WorkflowStateStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => WorkflowStateStatusSchema),
          z.lazy(() => NestedEnumWorkflowStateStatusFilterSchema)
        ])
        .optional()
    })
    .strict();

export const WorkflowStateUserIdWorkflowIdCompoundUniqueInputSchema: z.ZodType<Prisma.WorkflowStateUserIdWorkflowIdCompoundUniqueInput> =
  z
    .object({
      userId: z.string(),
      workflowId: z.string()
    })
    .strict();

export const WorkflowStateCountOrderByAggregateInputSchema: z.ZodType<Prisma.WorkflowStateCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      workflowId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      startedAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const WorkflowStateMaxOrderByAggregateInputSchema: z.ZodType<Prisma.WorkflowStateMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      workflowId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      startedAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const WorkflowStateMinOrderByAggregateInputSchema: z.ZodType<Prisma.WorkflowStateMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      workflowId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      startedAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const EnumWorkflowStateStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumWorkflowStateStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => WorkflowStateStatusSchema).optional(),
      in: z
        .lazy(() => WorkflowStateStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => WorkflowStateStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => WorkflowStateStatusSchema),
          z.lazy(() => NestedEnumWorkflowStateStatusWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumWorkflowStateStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumWorkflowStateStatusFilterSchema).optional()
    })
    .strict();

export const EnumExecutionStatusFilterSchema: z.ZodType<Prisma.EnumExecutionStatusFilter> =
  z
    .object({
      equals: z.lazy(() => ExecutionStatusSchema).optional(),
      in: z
        .lazy(() => ExecutionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ExecutionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ExecutionStatusSchema),
          z.lazy(() => NestedEnumExecutionStatusFilterSchema)
        ])
        .optional()
    })
    .strict();

export const RuleNullableScalarRelationFilterSchema: z.ZodType<Prisma.RuleNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => RuleWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => RuleWhereInputSchema)
        .optional()
        .nullable()
    })
    .strict();

export const ExecutionCountOrderByAggregateInputSchema: z.ZodType<Prisma.ExecutionCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      actionId: z.lazy(() => SortOrderSchema).optional(),
      ruleId: z.lazy(() => SortOrderSchema).optional(),
      executedAt: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      errorMessage: z.lazy(() => SortOrderSchema).optional(),
      resultPayload: z.lazy(() => SortOrderSchema).optional(),
      correlationId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ExecutionMaxOrderByAggregateInputSchema: z.ZodType<Prisma.ExecutionMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      actionId: z.lazy(() => SortOrderSchema).optional(),
      ruleId: z.lazy(() => SortOrderSchema).optional(),
      executedAt: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      errorMessage: z.lazy(() => SortOrderSchema).optional(),
      correlationId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const ExecutionMinOrderByAggregateInputSchema: z.ZodType<Prisma.ExecutionMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      actionId: z.lazy(() => SortOrderSchema).optional(),
      ruleId: z.lazy(() => SortOrderSchema).optional(),
      executedAt: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      errorMessage: z.lazy(() => SortOrderSchema).optional(),
      correlationId: z.lazy(() => SortOrderSchema).optional()
    })
    .strict();

export const EnumExecutionStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumExecutionStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => ExecutionStatusSchema).optional(),
      in: z
        .lazy(() => ExecutionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ExecutionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ExecutionStatusSchema),
          z.lazy(() => NestedEnumExecutionStatusWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumExecutionStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumExecutionStatusFilterSchema).optional()
    })
    .strict();

export const UserCreateNestedOneWithoutTwoFactorConfirmationInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutTwoFactorConfirmationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutTwoFactorConfirmationInputSchema),
          z.lazy(
            () => UserUncheckedCreateWithoutTwoFactorConfirmationInputSchema
          )
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutTwoFactorConfirmationInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const StringFieldUpdateOperationsInputSchema: z.ZodType<Prisma.StringFieldUpdateOperationsInput> =
  z
    .object({
      set: z.string().optional()
    })
    .strict();

export const UserUpdateOneRequiredWithoutTwoFactorConfirmationNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutTwoFactorConfirmationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutTwoFactorConfirmationInputSchema),
          z.lazy(
            () => UserUncheckedCreateWithoutTwoFactorConfirmationInputSchema
          )
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutTwoFactorConfirmationInputSchema)
        .optional(),
      upsert: z
        .lazy(() => UserUpsertWithoutTwoFactorConfirmationInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () =>
              UserUpdateToOneWithWhereWithoutTwoFactorConfirmationInputSchema
          ),
          z.lazy(() => UserUpdateWithoutTwoFactorConfirmationInputSchema),
          z.lazy(
            () => UserUncheckedUpdateWithoutTwoFactorConfirmationInputSchema
          )
        ])
        .optional()
    })
    .strict();

export const UserCreateNestedOneWithoutAccountsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutAccountsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutAccountsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutAccountsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutAccountsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const NullableStringFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableStringFieldUpdateOperationsInput> =
  z
    .object({
      set: z.string().optional().nullable()
    })
    .strict();

export const NullableIntFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableIntFieldUpdateOperationsInput> =
  z
    .object({
      set: z.number().optional().nullable(),
      increment: z.number().optional(),
      decrement: z.number().optional(),
      multiply: z.number().optional(),
      divide: z.number().optional()
    })
    .strict();

export const DateTimeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.DateTimeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.coerce.date().optional()
    })
    .strict();

export const UserUpdateOneRequiredWithoutAccountsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutAccountsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutAccountsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutAccountsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutAccountsInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutAccountsInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutAccountsInputSchema),
          z.lazy(() => UserUpdateWithoutAccountsInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutAccountsInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserCreateNestedOneWithoutSessionsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutSessionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutSessionsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutSessionsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutSessionsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const UserUpdateOneRequiredWithoutSessionsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutSessionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutSessionsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutSessionsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutSessionsInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutSessionsInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutSessionsInputSchema),
          z.lazy(() => UserUpdateWithoutSessionsInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutSessionsInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserCreateNestedOneWithoutAuthenticatorInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutAuthenticatorInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutAuthenticatorInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutAuthenticatorInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutAuthenticatorInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const IntFieldUpdateOperationsInputSchema: z.ZodType<Prisma.IntFieldUpdateOperationsInput> =
  z
    .object({
      set: z.number().optional(),
      increment: z.number().optional(),
      decrement: z.number().optional(),
      multiply: z.number().optional(),
      divide: z.number().optional()
    })
    .strict();

export const BoolFieldUpdateOperationsInputSchema: z.ZodType<Prisma.BoolFieldUpdateOperationsInput> =
  z
    .object({
      set: z.boolean().optional()
    })
    .strict();

export const UserUpdateOneRequiredWithoutAuthenticatorNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutAuthenticatorNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutAuthenticatorInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutAuthenticatorInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutAuthenticatorInputSchema)
        .optional(),
      upsert: z
        .lazy(() => UserUpsertWithoutAuthenticatorInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutAuthenticatorInputSchema),
          z.lazy(() => UserUpdateWithoutAuthenticatorInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutAuthenticatorInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserCreateNestedOneWithoutCustomerInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutCustomerInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutCustomerInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutCustomerInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutCustomerInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const UserUpdateOneRequiredWithoutCustomerNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutCustomerNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutCustomerInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutCustomerInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutCustomerInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutCustomerInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutCustomerInputSchema),
          z.lazy(() => UserUpdateWithoutCustomerInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutCustomerInputSchema)
        ])
        .optional()
    })
    .strict();

export const PriceCreateNestedManyWithoutProductInputSchema: z.ZodType<Prisma.PriceCreateNestedManyWithoutProductInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => PriceCreateWithoutProductInputSchema),
          z.lazy(() => PriceCreateWithoutProductInputSchema).array(),
          z.lazy(() => PriceUncheckedCreateWithoutProductInputSchema),
          z.lazy(() => PriceUncheckedCreateWithoutProductInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => PriceCreateOrConnectWithoutProductInputSchema),
          z.lazy(() => PriceCreateOrConnectWithoutProductInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => PriceCreateManyProductInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => PriceWhereUniqueInputSchema),
          z.lazy(() => PriceWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const PriceUncheckedCreateNestedManyWithoutProductInputSchema: z.ZodType<Prisma.PriceUncheckedCreateNestedManyWithoutProductInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => PriceCreateWithoutProductInputSchema),
          z.lazy(() => PriceCreateWithoutProductInputSchema).array(),
          z.lazy(() => PriceUncheckedCreateWithoutProductInputSchema),
          z.lazy(() => PriceUncheckedCreateWithoutProductInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => PriceCreateOrConnectWithoutProductInputSchema),
          z.lazy(() => PriceCreateOrConnectWithoutProductInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => PriceCreateManyProductInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => PriceWhereUniqueInputSchema),
          z.lazy(() => PriceWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const PriceUpdateManyWithoutProductNestedInputSchema: z.ZodType<Prisma.PriceUpdateManyWithoutProductNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => PriceCreateWithoutProductInputSchema),
          z.lazy(() => PriceCreateWithoutProductInputSchema).array(),
          z.lazy(() => PriceUncheckedCreateWithoutProductInputSchema),
          z.lazy(() => PriceUncheckedCreateWithoutProductInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => PriceCreateOrConnectWithoutProductInputSchema),
          z.lazy(() => PriceCreateOrConnectWithoutProductInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => PriceUpsertWithWhereUniqueWithoutProductInputSchema),
          z
            .lazy(() => PriceUpsertWithWhereUniqueWithoutProductInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => PriceCreateManyProductInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => PriceWhereUniqueInputSchema),
          z.lazy(() => PriceWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => PriceWhereUniqueInputSchema),
          z.lazy(() => PriceWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => PriceWhereUniqueInputSchema),
          z.lazy(() => PriceWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => PriceWhereUniqueInputSchema),
          z.lazy(() => PriceWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => PriceUpdateWithWhereUniqueWithoutProductInputSchema),
          z
            .lazy(() => PriceUpdateWithWhereUniqueWithoutProductInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => PriceUpdateManyWithWhereWithoutProductInputSchema),
          z
            .lazy(() => PriceUpdateManyWithWhereWithoutProductInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => PriceScalarWhereInputSchema),
          z.lazy(() => PriceScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const PriceUncheckedUpdateManyWithoutProductNestedInputSchema: z.ZodType<Prisma.PriceUncheckedUpdateManyWithoutProductNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => PriceCreateWithoutProductInputSchema),
          z.lazy(() => PriceCreateWithoutProductInputSchema).array(),
          z.lazy(() => PriceUncheckedCreateWithoutProductInputSchema),
          z.lazy(() => PriceUncheckedCreateWithoutProductInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => PriceCreateOrConnectWithoutProductInputSchema),
          z.lazy(() => PriceCreateOrConnectWithoutProductInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => PriceUpsertWithWhereUniqueWithoutProductInputSchema),
          z
            .lazy(() => PriceUpsertWithWhereUniqueWithoutProductInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => PriceCreateManyProductInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => PriceWhereUniqueInputSchema),
          z.lazy(() => PriceWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => PriceWhereUniqueInputSchema),
          z.lazy(() => PriceWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => PriceWhereUniqueInputSchema),
          z.lazy(() => PriceWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => PriceWhereUniqueInputSchema),
          z.lazy(() => PriceWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => PriceUpdateWithWhereUniqueWithoutProductInputSchema),
          z
            .lazy(() => PriceUpdateWithWhereUniqueWithoutProductInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => PriceUpdateManyWithWhereWithoutProductInputSchema),
          z
            .lazy(() => PriceUpdateManyWithWhereWithoutProductInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => PriceScalarWhereInputSchema),
          z.lazy(() => PriceScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const SubscriptionCreateNestedManyWithoutPriceInputSchema: z.ZodType<Prisma.SubscriptionCreateNestedManyWithoutPriceInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutPriceInputSchema),
          z.lazy(() => SubscriptionCreateWithoutPriceInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutPriceInputSchema),
          z
            .lazy(() => SubscriptionUncheckedCreateWithoutPriceInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutPriceInputSchema),
          z
            .lazy(() => SubscriptionCreateOrConnectWithoutPriceInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => SubscriptionCreateManyPriceInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ProductCreateNestedOneWithoutPricesInputSchema: z.ZodType<Prisma.ProductCreateNestedOneWithoutPricesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductCreateWithoutPricesInputSchema),
          z.lazy(() => ProductUncheckedCreateWithoutPricesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ProductCreateOrConnectWithoutPricesInputSchema)
        .optional(),
      connect: z.lazy(() => ProductWhereUniqueInputSchema).optional()
    })
    .strict();

export const SubscriptionUncheckedCreateNestedManyWithoutPriceInputSchema: z.ZodType<Prisma.SubscriptionUncheckedCreateNestedManyWithoutPriceInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutPriceInputSchema),
          z.lazy(() => SubscriptionCreateWithoutPriceInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutPriceInputSchema),
          z
            .lazy(() => SubscriptionUncheckedCreateWithoutPriceInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutPriceInputSchema),
          z
            .lazy(() => SubscriptionCreateOrConnectWithoutPriceInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => SubscriptionCreateManyPriceInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const EnumPricingTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumPricingTypeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => PricingTypeSchema).optional()
    })
    .strict();

export const NullableEnumPricingPlanIntervalFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableEnumPricingPlanIntervalFieldUpdateOperationsInput> =
  z
    .object({
      set: z
        .lazy(() => PricingPlanIntervalSchema)
        .optional()
        .nullable()
    })
    .strict();

export const SubscriptionUpdateManyWithoutPriceNestedInputSchema: z.ZodType<Prisma.SubscriptionUpdateManyWithoutPriceNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutPriceInputSchema),
          z.lazy(() => SubscriptionCreateWithoutPriceInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutPriceInputSchema),
          z
            .lazy(() => SubscriptionUncheckedCreateWithoutPriceInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutPriceInputSchema),
          z
            .lazy(() => SubscriptionCreateOrConnectWithoutPriceInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => SubscriptionUpsertWithWhereUniqueWithoutPriceInputSchema
          ),
          z
            .lazy(
              () => SubscriptionUpsertWithWhereUniqueWithoutPriceInputSchema
            )
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => SubscriptionCreateManyPriceInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => SubscriptionUpdateWithWhereUniqueWithoutPriceInputSchema
          ),
          z
            .lazy(
              () => SubscriptionUpdateWithWhereUniqueWithoutPriceInputSchema
            )
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => SubscriptionUpdateManyWithWhereWithoutPriceInputSchema),
          z
            .lazy(() => SubscriptionUpdateManyWithWhereWithoutPriceInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => SubscriptionScalarWhereInputSchema),
          z.lazy(() => SubscriptionScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ProductUpdateOneRequiredWithoutPricesNestedInputSchema: z.ZodType<Prisma.ProductUpdateOneRequiredWithoutPricesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProductCreateWithoutPricesInputSchema),
          z.lazy(() => ProductUncheckedCreateWithoutPricesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ProductCreateOrConnectWithoutPricesInputSchema)
        .optional(),
      upsert: z.lazy(() => ProductUpsertWithoutPricesInputSchema).optional(),
      connect: z.lazy(() => ProductWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ProductUpdateToOneWithWhereWithoutPricesInputSchema),
          z.lazy(() => ProductUpdateWithoutPricesInputSchema),
          z.lazy(() => ProductUncheckedUpdateWithoutPricesInputSchema)
        ])
        .optional()
    })
    .strict();

export const SubscriptionUncheckedUpdateManyWithoutPriceNestedInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateManyWithoutPriceNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutPriceInputSchema),
          z.lazy(() => SubscriptionCreateWithoutPriceInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutPriceInputSchema),
          z
            .lazy(() => SubscriptionUncheckedCreateWithoutPriceInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutPriceInputSchema),
          z
            .lazy(() => SubscriptionCreateOrConnectWithoutPriceInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => SubscriptionUpsertWithWhereUniqueWithoutPriceInputSchema
          ),
          z
            .lazy(
              () => SubscriptionUpsertWithWhereUniqueWithoutPriceInputSchema
            )
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => SubscriptionCreateManyPriceInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => SubscriptionUpdateWithWhereUniqueWithoutPriceInputSchema
          ),
          z
            .lazy(
              () => SubscriptionUpdateWithWhereUniqueWithoutPriceInputSchema
            )
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => SubscriptionUpdateManyWithWhereWithoutPriceInputSchema),
          z
            .lazy(() => SubscriptionUpdateManyWithWhereWithoutPriceInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => SubscriptionScalarWhereInputSchema),
          z.lazy(() => SubscriptionScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const PriceCreateNestedOneWithoutSubscriptionsInputSchema: z.ZodType<Prisma.PriceCreateNestedOneWithoutSubscriptionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => PriceCreateWithoutSubscriptionsInputSchema),
          z.lazy(() => PriceUncheckedCreateWithoutSubscriptionsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => PriceCreateOrConnectWithoutSubscriptionsInputSchema)
        .optional(),
      connect: z.lazy(() => PriceWhereUniqueInputSchema).optional()
    })
    .strict();

export const UserCreateNestedOneWithoutSubscriptionsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutSubscriptionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutSubscriptionsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutSubscriptionsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutSubscriptionsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const EnumSubscriptionStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumSubscriptionStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => SubscriptionStatusSchema).optional()
    })
    .strict();

export const NullableDateTimeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableDateTimeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.coerce.date().optional().nullable()
    })
    .strict();

export const PriceUpdateOneRequiredWithoutSubscriptionsNestedInputSchema: z.ZodType<Prisma.PriceUpdateOneRequiredWithoutSubscriptionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => PriceCreateWithoutSubscriptionsInputSchema),
          z.lazy(() => PriceUncheckedCreateWithoutSubscriptionsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => PriceCreateOrConnectWithoutSubscriptionsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => PriceUpsertWithoutSubscriptionsInputSchema)
        .optional(),
      connect: z.lazy(() => PriceWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => PriceUpdateToOneWithWhereWithoutSubscriptionsInputSchema
          ),
          z.lazy(() => PriceUpdateWithoutSubscriptionsInputSchema),
          z.lazy(() => PriceUncheckedUpdateWithoutSubscriptionsInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserUpdateOneRequiredWithoutSubscriptionsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutSubscriptionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutSubscriptionsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutSubscriptionsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutSubscriptionsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => UserUpsertWithoutSubscriptionsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutSubscriptionsInputSchema),
          z.lazy(() => UserUpdateWithoutSubscriptionsInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutSubscriptionsInputSchema)
        ])
        .optional()
    })
    .strict();

export const SiteCreateNestedOneWithoutFeedInputSchema: z.ZodType<Prisma.SiteCreateNestedOneWithoutFeedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SiteCreateWithoutFeedInputSchema),
          z.lazy(() => SiteUncheckedCreateWithoutFeedInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => SiteCreateOrConnectWithoutFeedInputSchema)
        .optional(),
      connect: z.lazy(() => SiteWhereUniqueInputSchema).optional()
    })
    .strict();

export const UserCreateNestedOneWithoutFeedInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutFeedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutFeedInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutFeedInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutFeedInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const CommentCreateNestedManyWithoutFeedInputSchema: z.ZodType<Prisma.CommentCreateNestedManyWithoutFeedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CommentCreateWithoutFeedInputSchema),
          z.lazy(() => CommentCreateWithoutFeedInputSchema).array(),
          z.lazy(() => CommentUncheckedCreateWithoutFeedInputSchema),
          z.lazy(() => CommentUncheckedCreateWithoutFeedInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CommentCreateOrConnectWithoutFeedInputSchema),
          z.lazy(() => CommentCreateOrConnectWithoutFeedInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CommentCreateManyFeedInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CommentWhereUniqueInputSchema),
          z.lazy(() => CommentWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const LikeCreateNestedManyWithoutFeedInputSchema: z.ZodType<Prisma.LikeCreateNestedManyWithoutFeedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LikeCreateWithoutFeedInputSchema),
          z.lazy(() => LikeCreateWithoutFeedInputSchema).array(),
          z.lazy(() => LikeUncheckedCreateWithoutFeedInputSchema),
          z.lazy(() => LikeUncheckedCreateWithoutFeedInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => LikeCreateOrConnectWithoutFeedInputSchema),
          z.lazy(() => LikeCreateOrConnectWithoutFeedInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => LikeCreateManyFeedInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CommentUncheckedCreateNestedManyWithoutFeedInputSchema: z.ZodType<Prisma.CommentUncheckedCreateNestedManyWithoutFeedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CommentCreateWithoutFeedInputSchema),
          z.lazy(() => CommentCreateWithoutFeedInputSchema).array(),
          z.lazy(() => CommentUncheckedCreateWithoutFeedInputSchema),
          z.lazy(() => CommentUncheckedCreateWithoutFeedInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CommentCreateOrConnectWithoutFeedInputSchema),
          z.lazy(() => CommentCreateOrConnectWithoutFeedInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CommentCreateManyFeedInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CommentWhereUniqueInputSchema),
          z.lazy(() => CommentWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const LikeUncheckedCreateNestedManyWithoutFeedInputSchema: z.ZodType<Prisma.LikeUncheckedCreateNestedManyWithoutFeedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LikeCreateWithoutFeedInputSchema),
          z.lazy(() => LikeCreateWithoutFeedInputSchema).array(),
          z.lazy(() => LikeUncheckedCreateWithoutFeedInputSchema),
          z.lazy(() => LikeUncheckedCreateWithoutFeedInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => LikeCreateOrConnectWithoutFeedInputSchema),
          z.lazy(() => LikeCreateOrConnectWithoutFeedInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => LikeCreateManyFeedInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const EnumFeedTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumFeedTypeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => FeedTypeSchema).optional()
    })
    .strict();

export const SiteUpdateOneRequiredWithoutFeedNestedInputSchema: z.ZodType<Prisma.SiteUpdateOneRequiredWithoutFeedNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SiteCreateWithoutFeedInputSchema),
          z.lazy(() => SiteUncheckedCreateWithoutFeedInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => SiteCreateOrConnectWithoutFeedInputSchema)
        .optional(),
      upsert: z.lazy(() => SiteUpsertWithoutFeedInputSchema).optional(),
      connect: z.lazy(() => SiteWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => SiteUpdateToOneWithWhereWithoutFeedInputSchema),
          z.lazy(() => SiteUpdateWithoutFeedInputSchema),
          z.lazy(() => SiteUncheckedUpdateWithoutFeedInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserUpdateOneRequiredWithoutFeedNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutFeedNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutFeedInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutFeedInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutFeedInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutFeedInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutFeedInputSchema),
          z.lazy(() => UserUpdateWithoutFeedInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutFeedInputSchema)
        ])
        .optional()
    })
    .strict();

export const CommentUpdateManyWithoutFeedNestedInputSchema: z.ZodType<Prisma.CommentUpdateManyWithoutFeedNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CommentCreateWithoutFeedInputSchema),
          z.lazy(() => CommentCreateWithoutFeedInputSchema).array(),
          z.lazy(() => CommentUncheckedCreateWithoutFeedInputSchema),
          z.lazy(() => CommentUncheckedCreateWithoutFeedInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CommentCreateOrConnectWithoutFeedInputSchema),
          z.lazy(() => CommentCreateOrConnectWithoutFeedInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CommentUpsertWithWhereUniqueWithoutFeedInputSchema),
          z
            .lazy(() => CommentUpsertWithWhereUniqueWithoutFeedInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CommentCreateManyFeedInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CommentWhereUniqueInputSchema),
          z.lazy(() => CommentWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CommentWhereUniqueInputSchema),
          z.lazy(() => CommentWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CommentWhereUniqueInputSchema),
          z.lazy(() => CommentWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CommentWhereUniqueInputSchema),
          z.lazy(() => CommentWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CommentUpdateWithWhereUniqueWithoutFeedInputSchema),
          z
            .lazy(() => CommentUpdateWithWhereUniqueWithoutFeedInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CommentUpdateManyWithWhereWithoutFeedInputSchema),
          z.lazy(() => CommentUpdateManyWithWhereWithoutFeedInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CommentScalarWhereInputSchema),
          z.lazy(() => CommentScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const LikeUpdateManyWithoutFeedNestedInputSchema: z.ZodType<Prisma.LikeUpdateManyWithoutFeedNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LikeCreateWithoutFeedInputSchema),
          z.lazy(() => LikeCreateWithoutFeedInputSchema).array(),
          z.lazy(() => LikeUncheckedCreateWithoutFeedInputSchema),
          z.lazy(() => LikeUncheckedCreateWithoutFeedInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => LikeCreateOrConnectWithoutFeedInputSchema),
          z.lazy(() => LikeCreateOrConnectWithoutFeedInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => LikeUpsertWithWhereUniqueWithoutFeedInputSchema),
          z.lazy(() => LikeUpsertWithWhereUniqueWithoutFeedInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => LikeCreateManyFeedInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => LikeUpdateWithWhereUniqueWithoutFeedInputSchema),
          z.lazy(() => LikeUpdateWithWhereUniqueWithoutFeedInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => LikeUpdateManyWithWhereWithoutFeedInputSchema),
          z.lazy(() => LikeUpdateManyWithWhereWithoutFeedInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => LikeScalarWhereInputSchema),
          z.lazy(() => LikeScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CommentUncheckedUpdateManyWithoutFeedNestedInputSchema: z.ZodType<Prisma.CommentUncheckedUpdateManyWithoutFeedNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CommentCreateWithoutFeedInputSchema),
          z.lazy(() => CommentCreateWithoutFeedInputSchema).array(),
          z.lazy(() => CommentUncheckedCreateWithoutFeedInputSchema),
          z.lazy(() => CommentUncheckedCreateWithoutFeedInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CommentCreateOrConnectWithoutFeedInputSchema),
          z.lazy(() => CommentCreateOrConnectWithoutFeedInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CommentUpsertWithWhereUniqueWithoutFeedInputSchema),
          z
            .lazy(() => CommentUpsertWithWhereUniqueWithoutFeedInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CommentCreateManyFeedInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CommentWhereUniqueInputSchema),
          z.lazy(() => CommentWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CommentWhereUniqueInputSchema),
          z.lazy(() => CommentWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CommentWhereUniqueInputSchema),
          z.lazy(() => CommentWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CommentWhereUniqueInputSchema),
          z.lazy(() => CommentWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CommentUpdateWithWhereUniqueWithoutFeedInputSchema),
          z
            .lazy(() => CommentUpdateWithWhereUniqueWithoutFeedInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CommentUpdateManyWithWhereWithoutFeedInputSchema),
          z.lazy(() => CommentUpdateManyWithWhereWithoutFeedInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CommentScalarWhereInputSchema),
          z.lazy(() => CommentScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const LikeUncheckedUpdateManyWithoutFeedNestedInputSchema: z.ZodType<Prisma.LikeUncheckedUpdateManyWithoutFeedNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LikeCreateWithoutFeedInputSchema),
          z.lazy(() => LikeCreateWithoutFeedInputSchema).array(),
          z.lazy(() => LikeUncheckedCreateWithoutFeedInputSchema),
          z.lazy(() => LikeUncheckedCreateWithoutFeedInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => LikeCreateOrConnectWithoutFeedInputSchema),
          z.lazy(() => LikeCreateOrConnectWithoutFeedInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => LikeUpsertWithWhereUniqueWithoutFeedInputSchema),
          z.lazy(() => LikeUpsertWithWhereUniqueWithoutFeedInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => LikeCreateManyFeedInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => LikeUpdateWithWhereUniqueWithoutFeedInputSchema),
          z.lazy(() => LikeUpdateWithWhereUniqueWithoutFeedInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => LikeUpdateManyWithWhereWithoutFeedInputSchema),
          z.lazy(() => LikeUpdateManyWithWhereWithoutFeedInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => LikeScalarWhereInputSchema),
          z.lazy(() => LikeScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const FeedCreateNestedOneWithoutCommentsInputSchema: z.ZodType<Prisma.FeedCreateNestedOneWithoutCommentsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FeedCreateWithoutCommentsInputSchema),
          z.lazy(() => FeedUncheckedCreateWithoutCommentsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => FeedCreateOrConnectWithoutCommentsInputSchema)
        .optional(),
      connect: z.lazy(() => FeedWhereUniqueInputSchema).optional()
    })
    .strict();

export const UserCreateNestedOneWithoutCommentsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutCommentsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutCommentsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutCommentsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutCommentsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const FeedUpdateOneWithoutCommentsNestedInputSchema: z.ZodType<Prisma.FeedUpdateOneWithoutCommentsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FeedCreateWithoutCommentsInputSchema),
          z.lazy(() => FeedUncheckedCreateWithoutCommentsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => FeedCreateOrConnectWithoutCommentsInputSchema)
        .optional(),
      upsert: z.lazy(() => FeedUpsertWithoutCommentsInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => FeedWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => FeedWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => FeedWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => FeedUpdateToOneWithWhereWithoutCommentsInputSchema),
          z.lazy(() => FeedUpdateWithoutCommentsInputSchema),
          z.lazy(() => FeedUncheckedUpdateWithoutCommentsInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserUpdateOneRequiredWithoutCommentsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutCommentsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutCommentsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutCommentsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutCommentsInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutCommentsInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutCommentsInputSchema),
          z.lazy(() => UserUpdateWithoutCommentsInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutCommentsInputSchema)
        ])
        .optional()
    })
    .strict();

export const NullableFloatFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableFloatFieldUpdateOperationsInput> =
  z
    .object({
      set: z.number().optional().nullable(),
      increment: z.number().optional(),
      decrement: z.number().optional(),
      multiply: z.number().optional(),
      divide: z.number().optional()
    })
    .strict();

export const NafDivisionCreateNestedManyWithoutSectionInputSchema: z.ZodType<Prisma.NafDivisionCreateNestedManyWithoutSectionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafDivisionCreateWithoutSectionInputSchema),
          z.lazy(() => NafDivisionCreateWithoutSectionInputSchema).array(),
          z.lazy(() => NafDivisionUncheckedCreateWithoutSectionInputSchema),
          z
            .lazy(() => NafDivisionUncheckedCreateWithoutSectionInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NafDivisionCreateOrConnectWithoutSectionInputSchema),
          z
            .lazy(() => NafDivisionCreateOrConnectWithoutSectionInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => NafDivisionCreateManySectionInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => NafDivisionWhereUniqueInputSchema),
          z.lazy(() => NafDivisionWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const NafDivisionUncheckedCreateNestedManyWithoutSectionInputSchema: z.ZodType<Prisma.NafDivisionUncheckedCreateNestedManyWithoutSectionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafDivisionCreateWithoutSectionInputSchema),
          z.lazy(() => NafDivisionCreateWithoutSectionInputSchema).array(),
          z.lazy(() => NafDivisionUncheckedCreateWithoutSectionInputSchema),
          z
            .lazy(() => NafDivisionUncheckedCreateWithoutSectionInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NafDivisionCreateOrConnectWithoutSectionInputSchema),
          z
            .lazy(() => NafDivisionCreateOrConnectWithoutSectionInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => NafDivisionCreateManySectionInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => NafDivisionWhereUniqueInputSchema),
          z.lazy(() => NafDivisionWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const NafDivisionUpdateManyWithoutSectionNestedInputSchema: z.ZodType<Prisma.NafDivisionUpdateManyWithoutSectionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafDivisionCreateWithoutSectionInputSchema),
          z.lazy(() => NafDivisionCreateWithoutSectionInputSchema).array(),
          z.lazy(() => NafDivisionUncheckedCreateWithoutSectionInputSchema),
          z
            .lazy(() => NafDivisionUncheckedCreateWithoutSectionInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NafDivisionCreateOrConnectWithoutSectionInputSchema),
          z
            .lazy(() => NafDivisionCreateOrConnectWithoutSectionInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => NafDivisionUpsertWithWhereUniqueWithoutSectionInputSchema
          ),
          z
            .lazy(
              () => NafDivisionUpsertWithWhereUniqueWithoutSectionInputSchema
            )
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => NafDivisionCreateManySectionInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => NafDivisionWhereUniqueInputSchema),
          z.lazy(() => NafDivisionWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => NafDivisionWhereUniqueInputSchema),
          z.lazy(() => NafDivisionWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => NafDivisionWhereUniqueInputSchema),
          z.lazy(() => NafDivisionWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => NafDivisionWhereUniqueInputSchema),
          z.lazy(() => NafDivisionWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => NafDivisionUpdateWithWhereUniqueWithoutSectionInputSchema
          ),
          z
            .lazy(
              () => NafDivisionUpdateWithWhereUniqueWithoutSectionInputSchema
            )
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => NafDivisionUpdateManyWithWhereWithoutSectionInputSchema),
          z
            .lazy(() => NafDivisionUpdateManyWithWhereWithoutSectionInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => NafDivisionScalarWhereInputSchema),
          z.lazy(() => NafDivisionScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const NafDivisionUncheckedUpdateManyWithoutSectionNestedInputSchema: z.ZodType<Prisma.NafDivisionUncheckedUpdateManyWithoutSectionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafDivisionCreateWithoutSectionInputSchema),
          z.lazy(() => NafDivisionCreateWithoutSectionInputSchema).array(),
          z.lazy(() => NafDivisionUncheckedCreateWithoutSectionInputSchema),
          z
            .lazy(() => NafDivisionUncheckedCreateWithoutSectionInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NafDivisionCreateOrConnectWithoutSectionInputSchema),
          z
            .lazy(() => NafDivisionCreateOrConnectWithoutSectionInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => NafDivisionUpsertWithWhereUniqueWithoutSectionInputSchema
          ),
          z
            .lazy(
              () => NafDivisionUpsertWithWhereUniqueWithoutSectionInputSchema
            )
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => NafDivisionCreateManySectionInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => NafDivisionWhereUniqueInputSchema),
          z.lazy(() => NafDivisionWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => NafDivisionWhereUniqueInputSchema),
          z.lazy(() => NafDivisionWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => NafDivisionWhereUniqueInputSchema),
          z.lazy(() => NafDivisionWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => NafDivisionWhereUniqueInputSchema),
          z.lazy(() => NafDivisionWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => NafDivisionUpdateWithWhereUniqueWithoutSectionInputSchema
          ),
          z
            .lazy(
              () => NafDivisionUpdateWithWhereUniqueWithoutSectionInputSchema
            )
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => NafDivisionUpdateManyWithWhereWithoutSectionInputSchema),
          z
            .lazy(() => NafDivisionUpdateManyWithWhereWithoutSectionInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => NafDivisionScalarWhereInputSchema),
          z.lazy(() => NafDivisionScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const NafGroupCreateNestedManyWithoutDivisionInputSchema: z.ZodType<Prisma.NafGroupCreateNestedManyWithoutDivisionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafGroupCreateWithoutDivisionInputSchema),
          z.lazy(() => NafGroupCreateWithoutDivisionInputSchema).array(),
          z.lazy(() => NafGroupUncheckedCreateWithoutDivisionInputSchema),
          z
            .lazy(() => NafGroupUncheckedCreateWithoutDivisionInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NafGroupCreateOrConnectWithoutDivisionInputSchema),
          z
            .lazy(() => NafGroupCreateOrConnectWithoutDivisionInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => NafGroupCreateManyDivisionInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => NafGroupWhereUniqueInputSchema),
          z.lazy(() => NafGroupWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const NafSectionCreateNestedOneWithoutDivisionsInputSchema: z.ZodType<Prisma.NafSectionCreateNestedOneWithoutDivisionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafSectionCreateWithoutDivisionsInputSchema),
          z.lazy(() => NafSectionUncheckedCreateWithoutDivisionsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => NafSectionCreateOrConnectWithoutDivisionsInputSchema)
        .optional(),
      connect: z.lazy(() => NafSectionWhereUniqueInputSchema).optional()
    })
    .strict();

export const NafGroupUncheckedCreateNestedManyWithoutDivisionInputSchema: z.ZodType<Prisma.NafGroupUncheckedCreateNestedManyWithoutDivisionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafGroupCreateWithoutDivisionInputSchema),
          z.lazy(() => NafGroupCreateWithoutDivisionInputSchema).array(),
          z.lazy(() => NafGroupUncheckedCreateWithoutDivisionInputSchema),
          z
            .lazy(() => NafGroupUncheckedCreateWithoutDivisionInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NafGroupCreateOrConnectWithoutDivisionInputSchema),
          z
            .lazy(() => NafGroupCreateOrConnectWithoutDivisionInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => NafGroupCreateManyDivisionInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => NafGroupWhereUniqueInputSchema),
          z.lazy(() => NafGroupWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const NafGroupUpdateManyWithoutDivisionNestedInputSchema: z.ZodType<Prisma.NafGroupUpdateManyWithoutDivisionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafGroupCreateWithoutDivisionInputSchema),
          z.lazy(() => NafGroupCreateWithoutDivisionInputSchema).array(),
          z.lazy(() => NafGroupUncheckedCreateWithoutDivisionInputSchema),
          z
            .lazy(() => NafGroupUncheckedCreateWithoutDivisionInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NafGroupCreateOrConnectWithoutDivisionInputSchema),
          z
            .lazy(() => NafGroupCreateOrConnectWithoutDivisionInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => NafGroupUpsertWithWhereUniqueWithoutDivisionInputSchema),
          z
            .lazy(() => NafGroupUpsertWithWhereUniqueWithoutDivisionInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => NafGroupCreateManyDivisionInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => NafGroupWhereUniqueInputSchema),
          z.lazy(() => NafGroupWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => NafGroupWhereUniqueInputSchema),
          z.lazy(() => NafGroupWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => NafGroupWhereUniqueInputSchema),
          z.lazy(() => NafGroupWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => NafGroupWhereUniqueInputSchema),
          z.lazy(() => NafGroupWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => NafGroupUpdateWithWhereUniqueWithoutDivisionInputSchema),
          z
            .lazy(() => NafGroupUpdateWithWhereUniqueWithoutDivisionInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => NafGroupUpdateManyWithWhereWithoutDivisionInputSchema),
          z
            .lazy(() => NafGroupUpdateManyWithWhereWithoutDivisionInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => NafGroupScalarWhereInputSchema),
          z.lazy(() => NafGroupScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const NafSectionUpdateOneRequiredWithoutDivisionsNestedInputSchema: z.ZodType<Prisma.NafSectionUpdateOneRequiredWithoutDivisionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafSectionCreateWithoutDivisionsInputSchema),
          z.lazy(() => NafSectionUncheckedCreateWithoutDivisionsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => NafSectionCreateOrConnectWithoutDivisionsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => NafSectionUpsertWithoutDivisionsInputSchema)
        .optional(),
      connect: z.lazy(() => NafSectionWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => NafSectionUpdateToOneWithWhereWithoutDivisionsInputSchema
          ),
          z.lazy(() => NafSectionUpdateWithoutDivisionsInputSchema),
          z.lazy(() => NafSectionUncheckedUpdateWithoutDivisionsInputSchema)
        ])
        .optional()
    })
    .strict();

export const NafGroupUncheckedUpdateManyWithoutDivisionNestedInputSchema: z.ZodType<Prisma.NafGroupUncheckedUpdateManyWithoutDivisionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafGroupCreateWithoutDivisionInputSchema),
          z.lazy(() => NafGroupCreateWithoutDivisionInputSchema).array(),
          z.lazy(() => NafGroupUncheckedCreateWithoutDivisionInputSchema),
          z
            .lazy(() => NafGroupUncheckedCreateWithoutDivisionInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NafGroupCreateOrConnectWithoutDivisionInputSchema),
          z
            .lazy(() => NafGroupCreateOrConnectWithoutDivisionInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => NafGroupUpsertWithWhereUniqueWithoutDivisionInputSchema),
          z
            .lazy(() => NafGroupUpsertWithWhereUniqueWithoutDivisionInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => NafGroupCreateManyDivisionInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => NafGroupWhereUniqueInputSchema),
          z.lazy(() => NafGroupWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => NafGroupWhereUniqueInputSchema),
          z.lazy(() => NafGroupWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => NafGroupWhereUniqueInputSchema),
          z.lazy(() => NafGroupWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => NafGroupWhereUniqueInputSchema),
          z.lazy(() => NafGroupWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => NafGroupUpdateWithWhereUniqueWithoutDivisionInputSchema),
          z
            .lazy(() => NafGroupUpdateWithWhereUniqueWithoutDivisionInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => NafGroupUpdateManyWithWhereWithoutDivisionInputSchema),
          z
            .lazy(() => NafGroupUpdateManyWithWhereWithoutDivisionInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => NafGroupScalarWhereInputSchema),
          z.lazy(() => NafGroupScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const NafClassCreateNestedManyWithoutGroupInputSchema: z.ZodType<Prisma.NafClassCreateNestedManyWithoutGroupInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafClassCreateWithoutGroupInputSchema),
          z.lazy(() => NafClassCreateWithoutGroupInputSchema).array(),
          z.lazy(() => NafClassUncheckedCreateWithoutGroupInputSchema),
          z.lazy(() => NafClassUncheckedCreateWithoutGroupInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NafClassCreateOrConnectWithoutGroupInputSchema),
          z.lazy(() => NafClassCreateOrConnectWithoutGroupInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => NafClassCreateManyGroupInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => NafClassWhereUniqueInputSchema),
          z.lazy(() => NafClassWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const NafDivisionCreateNestedOneWithoutGroupsInputSchema: z.ZodType<Prisma.NafDivisionCreateNestedOneWithoutGroupsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafDivisionCreateWithoutGroupsInputSchema),
          z.lazy(() => NafDivisionUncheckedCreateWithoutGroupsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => NafDivisionCreateOrConnectWithoutGroupsInputSchema)
        .optional(),
      connect: z.lazy(() => NafDivisionWhereUniqueInputSchema).optional()
    })
    .strict();

export const NafClassUncheckedCreateNestedManyWithoutGroupInputSchema: z.ZodType<Prisma.NafClassUncheckedCreateNestedManyWithoutGroupInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafClassCreateWithoutGroupInputSchema),
          z.lazy(() => NafClassCreateWithoutGroupInputSchema).array(),
          z.lazy(() => NafClassUncheckedCreateWithoutGroupInputSchema),
          z.lazy(() => NafClassUncheckedCreateWithoutGroupInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NafClassCreateOrConnectWithoutGroupInputSchema),
          z.lazy(() => NafClassCreateOrConnectWithoutGroupInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => NafClassCreateManyGroupInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => NafClassWhereUniqueInputSchema),
          z.lazy(() => NafClassWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const NafClassUpdateManyWithoutGroupNestedInputSchema: z.ZodType<Prisma.NafClassUpdateManyWithoutGroupNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafClassCreateWithoutGroupInputSchema),
          z.lazy(() => NafClassCreateWithoutGroupInputSchema).array(),
          z.lazy(() => NafClassUncheckedCreateWithoutGroupInputSchema),
          z.lazy(() => NafClassUncheckedCreateWithoutGroupInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NafClassCreateOrConnectWithoutGroupInputSchema),
          z.lazy(() => NafClassCreateOrConnectWithoutGroupInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => NafClassUpsertWithWhereUniqueWithoutGroupInputSchema),
          z
            .lazy(() => NafClassUpsertWithWhereUniqueWithoutGroupInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => NafClassCreateManyGroupInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => NafClassWhereUniqueInputSchema),
          z.lazy(() => NafClassWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => NafClassWhereUniqueInputSchema),
          z.lazy(() => NafClassWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => NafClassWhereUniqueInputSchema),
          z.lazy(() => NafClassWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => NafClassWhereUniqueInputSchema),
          z.lazy(() => NafClassWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => NafClassUpdateWithWhereUniqueWithoutGroupInputSchema),
          z
            .lazy(() => NafClassUpdateWithWhereUniqueWithoutGroupInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => NafClassUpdateManyWithWhereWithoutGroupInputSchema),
          z
            .lazy(() => NafClassUpdateManyWithWhereWithoutGroupInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => NafClassScalarWhereInputSchema),
          z.lazy(() => NafClassScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const NafDivisionUpdateOneRequiredWithoutGroupsNestedInputSchema: z.ZodType<Prisma.NafDivisionUpdateOneRequiredWithoutGroupsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafDivisionCreateWithoutGroupsInputSchema),
          z.lazy(() => NafDivisionUncheckedCreateWithoutGroupsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => NafDivisionCreateOrConnectWithoutGroupsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => NafDivisionUpsertWithoutGroupsInputSchema)
        .optional(),
      connect: z.lazy(() => NafDivisionWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => NafDivisionUpdateToOneWithWhereWithoutGroupsInputSchema),
          z.lazy(() => NafDivisionUpdateWithoutGroupsInputSchema),
          z.lazy(() => NafDivisionUncheckedUpdateWithoutGroupsInputSchema)
        ])
        .optional()
    })
    .strict();

export const NafClassUncheckedUpdateManyWithoutGroupNestedInputSchema: z.ZodType<Prisma.NafClassUncheckedUpdateManyWithoutGroupNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafClassCreateWithoutGroupInputSchema),
          z.lazy(() => NafClassCreateWithoutGroupInputSchema).array(),
          z.lazy(() => NafClassUncheckedCreateWithoutGroupInputSchema),
          z.lazy(() => NafClassUncheckedCreateWithoutGroupInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NafClassCreateOrConnectWithoutGroupInputSchema),
          z.lazy(() => NafClassCreateOrConnectWithoutGroupInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => NafClassUpsertWithWhereUniqueWithoutGroupInputSchema),
          z
            .lazy(() => NafClassUpsertWithWhereUniqueWithoutGroupInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => NafClassCreateManyGroupInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => NafClassWhereUniqueInputSchema),
          z.lazy(() => NafClassWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => NafClassWhereUniqueInputSchema),
          z.lazy(() => NafClassWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => NafClassWhereUniqueInputSchema),
          z.lazy(() => NafClassWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => NafClassWhereUniqueInputSchema),
          z.lazy(() => NafClassWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => NafClassUpdateWithWhereUniqueWithoutGroupInputSchema),
          z
            .lazy(() => NafClassUpdateWithWhereUniqueWithoutGroupInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => NafClassUpdateManyWithWhereWithoutGroupInputSchema),
          z
            .lazy(() => NafClassUpdateManyWithWhereWithoutGroupInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => NafClassScalarWhereInputSchema),
          z.lazy(() => NafClassScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const NafCodeCreateNestedManyWithoutClassInputSchema: z.ZodType<Prisma.NafCodeCreateNestedManyWithoutClassInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafCodeCreateWithoutClassInputSchema),
          z.lazy(() => NafCodeCreateWithoutClassInputSchema).array(),
          z.lazy(() => NafCodeUncheckedCreateWithoutClassInputSchema),
          z.lazy(() => NafCodeUncheckedCreateWithoutClassInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NafCodeCreateOrConnectWithoutClassInputSchema),
          z.lazy(() => NafCodeCreateOrConnectWithoutClassInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => NafCodeCreateManyClassInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => NafCodeWhereUniqueInputSchema),
          z.lazy(() => NafCodeWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const NafGroupCreateNestedOneWithoutClassesInputSchema: z.ZodType<Prisma.NafGroupCreateNestedOneWithoutClassesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafGroupCreateWithoutClassesInputSchema),
          z.lazy(() => NafGroupUncheckedCreateWithoutClassesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => NafGroupCreateOrConnectWithoutClassesInputSchema)
        .optional(),
      connect: z.lazy(() => NafGroupWhereUniqueInputSchema).optional()
    })
    .strict();

export const NafCodeUncheckedCreateNestedManyWithoutClassInputSchema: z.ZodType<Prisma.NafCodeUncheckedCreateNestedManyWithoutClassInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafCodeCreateWithoutClassInputSchema),
          z.lazy(() => NafCodeCreateWithoutClassInputSchema).array(),
          z.lazy(() => NafCodeUncheckedCreateWithoutClassInputSchema),
          z.lazy(() => NafCodeUncheckedCreateWithoutClassInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NafCodeCreateOrConnectWithoutClassInputSchema),
          z.lazy(() => NafCodeCreateOrConnectWithoutClassInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => NafCodeCreateManyClassInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => NafCodeWhereUniqueInputSchema),
          z.lazy(() => NafCodeWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const NafCodeUpdateManyWithoutClassNestedInputSchema: z.ZodType<Prisma.NafCodeUpdateManyWithoutClassNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafCodeCreateWithoutClassInputSchema),
          z.lazy(() => NafCodeCreateWithoutClassInputSchema).array(),
          z.lazy(() => NafCodeUncheckedCreateWithoutClassInputSchema),
          z.lazy(() => NafCodeUncheckedCreateWithoutClassInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NafCodeCreateOrConnectWithoutClassInputSchema),
          z.lazy(() => NafCodeCreateOrConnectWithoutClassInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => NafCodeUpsertWithWhereUniqueWithoutClassInputSchema),
          z
            .lazy(() => NafCodeUpsertWithWhereUniqueWithoutClassInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => NafCodeCreateManyClassInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => NafCodeWhereUniqueInputSchema),
          z.lazy(() => NafCodeWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => NafCodeWhereUniqueInputSchema),
          z.lazy(() => NafCodeWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => NafCodeWhereUniqueInputSchema),
          z.lazy(() => NafCodeWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => NafCodeWhereUniqueInputSchema),
          z.lazy(() => NafCodeWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => NafCodeUpdateWithWhereUniqueWithoutClassInputSchema),
          z
            .lazy(() => NafCodeUpdateWithWhereUniqueWithoutClassInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => NafCodeUpdateManyWithWhereWithoutClassInputSchema),
          z
            .lazy(() => NafCodeUpdateManyWithWhereWithoutClassInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => NafCodeScalarWhereInputSchema),
          z.lazy(() => NafCodeScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const NafGroupUpdateOneRequiredWithoutClassesNestedInputSchema: z.ZodType<Prisma.NafGroupUpdateOneRequiredWithoutClassesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafGroupCreateWithoutClassesInputSchema),
          z.lazy(() => NafGroupUncheckedCreateWithoutClassesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => NafGroupCreateOrConnectWithoutClassesInputSchema)
        .optional(),
      upsert: z.lazy(() => NafGroupUpsertWithoutClassesInputSchema).optional(),
      connect: z.lazy(() => NafGroupWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => NafGroupUpdateToOneWithWhereWithoutClassesInputSchema),
          z.lazy(() => NafGroupUpdateWithoutClassesInputSchema),
          z.lazy(() => NafGroupUncheckedUpdateWithoutClassesInputSchema)
        ])
        .optional()
    })
    .strict();

export const NafCodeUncheckedUpdateManyWithoutClassNestedInputSchema: z.ZodType<Prisma.NafCodeUncheckedUpdateManyWithoutClassNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafCodeCreateWithoutClassInputSchema),
          z.lazy(() => NafCodeCreateWithoutClassInputSchema).array(),
          z.lazy(() => NafCodeUncheckedCreateWithoutClassInputSchema),
          z.lazy(() => NafCodeUncheckedCreateWithoutClassInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NafCodeCreateOrConnectWithoutClassInputSchema),
          z.lazy(() => NafCodeCreateOrConnectWithoutClassInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => NafCodeUpsertWithWhereUniqueWithoutClassInputSchema),
          z
            .lazy(() => NafCodeUpsertWithWhereUniqueWithoutClassInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => NafCodeCreateManyClassInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => NafCodeWhereUniqueInputSchema),
          z.lazy(() => NafCodeWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => NafCodeWhereUniqueInputSchema),
          z.lazy(() => NafCodeWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => NafCodeWhereUniqueInputSchema),
          z.lazy(() => NafCodeWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => NafCodeWhereUniqueInputSchema),
          z.lazy(() => NafCodeWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => NafCodeUpdateWithWhereUniqueWithoutClassInputSchema),
          z
            .lazy(() => NafCodeUpdateWithWhereUniqueWithoutClassInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => NafCodeUpdateManyWithWhereWithoutClassInputSchema),
          z
            .lazy(() => NafCodeUpdateManyWithWhereWithoutClassInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => NafCodeScalarWhereInputSchema),
          z.lazy(() => NafCodeScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const NafClassCreateNestedOneWithoutCodesInputSchema: z.ZodType<Prisma.NafClassCreateNestedOneWithoutCodesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafClassCreateWithoutCodesInputSchema),
          z.lazy(() => NafClassUncheckedCreateWithoutCodesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => NafClassCreateOrConnectWithoutCodesInputSchema)
        .optional(),
      connect: z.lazy(() => NafClassWhereUniqueInputSchema).optional()
    })
    .strict();

export const UserCreateNestedManyWithoutNafInputSchema: z.ZodType<Prisma.UserCreateNestedManyWithoutNafInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutNafInputSchema),
          z.lazy(() => UserCreateWithoutNafInputSchema).array(),
          z.lazy(() => UserUncheckedCreateWithoutNafInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutNafInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserCreateOrConnectWithoutNafInputSchema),
          z.lazy(() => UserCreateOrConnectWithoutNafInputSchema).array()
        ])
        .optional(),
      createMany: z.lazy(() => UserCreateManyNafInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const UserUncheckedCreateNestedManyWithoutNafInputSchema: z.ZodType<Prisma.UserUncheckedCreateNestedManyWithoutNafInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutNafInputSchema),
          z.lazy(() => UserCreateWithoutNafInputSchema).array(),
          z.lazy(() => UserUncheckedCreateWithoutNafInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutNafInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserCreateOrConnectWithoutNafInputSchema),
          z.lazy(() => UserCreateOrConnectWithoutNafInputSchema).array()
        ])
        .optional(),
      createMany: z.lazy(() => UserCreateManyNafInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const NafClassUpdateOneRequiredWithoutCodesNestedInputSchema: z.ZodType<Prisma.NafClassUpdateOneRequiredWithoutCodesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafClassCreateWithoutCodesInputSchema),
          z.lazy(() => NafClassUncheckedCreateWithoutCodesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => NafClassCreateOrConnectWithoutCodesInputSchema)
        .optional(),
      upsert: z.lazy(() => NafClassUpsertWithoutCodesInputSchema).optional(),
      connect: z.lazy(() => NafClassWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => NafClassUpdateToOneWithWhereWithoutCodesInputSchema),
          z.lazy(() => NafClassUpdateWithoutCodesInputSchema),
          z.lazy(() => NafClassUncheckedUpdateWithoutCodesInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserUpdateManyWithoutNafNestedInputSchema: z.ZodType<Prisma.UserUpdateManyWithoutNafNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutNafInputSchema),
          z.lazy(() => UserCreateWithoutNafInputSchema).array(),
          z.lazy(() => UserUncheckedCreateWithoutNafInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutNafInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserCreateOrConnectWithoutNafInputSchema),
          z.lazy(() => UserCreateOrConnectWithoutNafInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => UserUpsertWithWhereUniqueWithoutNafInputSchema),
          z.lazy(() => UserUpsertWithWhereUniqueWithoutNafInputSchema).array()
        ])
        .optional(),
      createMany: z.lazy(() => UserCreateManyNafInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateWithWhereUniqueWithoutNafInputSchema),
          z.lazy(() => UserUpdateWithWhereUniqueWithoutNafInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => UserUpdateManyWithWhereWithoutNafInputSchema),
          z.lazy(() => UserUpdateManyWithWhereWithoutNafInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => UserScalarWhereInputSchema),
          z.lazy(() => UserScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const UserUncheckedUpdateManyWithoutNafNestedInputSchema: z.ZodType<Prisma.UserUncheckedUpdateManyWithoutNafNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutNafInputSchema),
          z.lazy(() => UserCreateWithoutNafInputSchema).array(),
          z.lazy(() => UserUncheckedCreateWithoutNafInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutNafInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserCreateOrConnectWithoutNafInputSchema),
          z.lazy(() => UserCreateOrConnectWithoutNafInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => UserUpsertWithWhereUniqueWithoutNafInputSchema),
          z.lazy(() => UserUpsertWithWhereUniqueWithoutNafInputSchema).array()
        ])
        .optional(),
      createMany: z.lazy(() => UserCreateManyNafInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateWithWhereUniqueWithoutNafInputSchema),
          z.lazy(() => UserUpdateWithWhereUniqueWithoutNafInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => UserUpdateManyWithWhereWithoutNafInputSchema),
          z.lazy(() => UserUpdateManyWithWhereWithoutNafInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => UserScalarWhereInputSchema),
          z.lazy(() => UserScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CampaignCreateNestedOneWithoutOutboxesInputSchema: z.ZodType<Prisma.CampaignCreateNestedOneWithoutOutboxesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CampaignCreateWithoutOutboxesInputSchema),
          z.lazy(() => CampaignUncheckedCreateWithoutOutboxesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CampaignCreateOrConnectWithoutOutboxesInputSchema)
        .optional(),
      connect: z.lazy(() => CampaignWhereUniqueInputSchema).optional()
    })
    .strict();

export const UserCreateNestedOneWithoutOutboxInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutOutboxInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutOutboxInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutOutboxInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutOutboxInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const CampaignUpdateOneWithoutOutboxesNestedInputSchema: z.ZodType<Prisma.CampaignUpdateOneWithoutOutboxesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CampaignCreateWithoutOutboxesInputSchema),
          z.lazy(() => CampaignUncheckedCreateWithoutOutboxesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CampaignCreateOrConnectWithoutOutboxesInputSchema)
        .optional(),
      upsert: z.lazy(() => CampaignUpsertWithoutOutboxesInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => CampaignWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => CampaignWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => CampaignWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => CampaignUpdateToOneWithWhereWithoutOutboxesInputSchema),
          z.lazy(() => CampaignUpdateWithoutOutboxesInputSchema),
          z.lazy(() => CampaignUncheckedUpdateWithoutOutboxesInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserUpdateOneWithoutOutboxNestedInputSchema: z.ZodType<Prisma.UserUpdateOneWithoutOutboxNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutOutboxInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutOutboxInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutOutboxInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutOutboxInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutOutboxInputSchema),
          z.lazy(() => UserUpdateWithoutOutboxInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutOutboxInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserCreateNestedManyWithoutListsManageInputSchema: z.ZodType<Prisma.UserCreateNestedManyWithoutListsManageInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutListsManageInputSchema),
          z.lazy(() => UserCreateWithoutListsManageInputSchema).array(),
          z.lazy(() => UserUncheckedCreateWithoutListsManageInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutListsManageInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserCreateOrConnectWithoutListsManageInputSchema),
          z.lazy(() => UserCreateOrConnectWithoutListsManageInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const UserCreateNestedManyWithoutListsInputSchema: z.ZodType<Prisma.UserCreateNestedManyWithoutListsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutListsInputSchema),
          z.lazy(() => UserCreateWithoutListsInputSchema).array(),
          z.lazy(() => UserUncheckedCreateWithoutListsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutListsInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserCreateOrConnectWithoutListsInputSchema),
          z.lazy(() => UserCreateOrConnectWithoutListsInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CampaignCreateNestedManyWithoutListInputSchema: z.ZodType<Prisma.CampaignCreateNestedManyWithoutListInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CampaignCreateWithoutListInputSchema),
          z.lazy(() => CampaignCreateWithoutListInputSchema).array(),
          z.lazy(() => CampaignUncheckedCreateWithoutListInputSchema),
          z.lazy(() => CampaignUncheckedCreateWithoutListInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CampaignCreateOrConnectWithoutListInputSchema),
          z.lazy(() => CampaignCreateOrConnectWithoutListInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CampaignCreateManyListInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CampaignWhereUniqueInputSchema),
          z.lazy(() => CampaignWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const UserUncheckedCreateNestedManyWithoutListsManageInputSchema: z.ZodType<Prisma.UserUncheckedCreateNestedManyWithoutListsManageInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutListsManageInputSchema),
          z.lazy(() => UserCreateWithoutListsManageInputSchema).array(),
          z.lazy(() => UserUncheckedCreateWithoutListsManageInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutListsManageInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserCreateOrConnectWithoutListsManageInputSchema),
          z.lazy(() => UserCreateOrConnectWithoutListsManageInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const UserUncheckedCreateNestedManyWithoutListsInputSchema: z.ZodType<Prisma.UserUncheckedCreateNestedManyWithoutListsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutListsInputSchema),
          z.lazy(() => UserCreateWithoutListsInputSchema).array(),
          z.lazy(() => UserUncheckedCreateWithoutListsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutListsInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserCreateOrConnectWithoutListsInputSchema),
          z.lazy(() => UserCreateOrConnectWithoutListsInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CampaignUncheckedCreateNestedManyWithoutListInputSchema: z.ZodType<Prisma.CampaignUncheckedCreateNestedManyWithoutListInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CampaignCreateWithoutListInputSchema),
          z.lazy(() => CampaignCreateWithoutListInputSchema).array(),
          z.lazy(() => CampaignUncheckedCreateWithoutListInputSchema),
          z.lazy(() => CampaignUncheckedCreateWithoutListInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CampaignCreateOrConnectWithoutListInputSchema),
          z.lazy(() => CampaignCreateOrConnectWithoutListInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CampaignCreateManyListInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CampaignWhereUniqueInputSchema),
          z.lazy(() => CampaignWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const UserUpdateManyWithoutListsManageNestedInputSchema: z.ZodType<Prisma.UserUpdateManyWithoutListsManageNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutListsManageInputSchema),
          z.lazy(() => UserCreateWithoutListsManageInputSchema).array(),
          z.lazy(() => UserUncheckedCreateWithoutListsManageInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutListsManageInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserCreateOrConnectWithoutListsManageInputSchema),
          z.lazy(() => UserCreateOrConnectWithoutListsManageInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => UserUpsertWithWhereUniqueWithoutListsManageInputSchema),
          z
            .lazy(() => UserUpsertWithWhereUniqueWithoutListsManageInputSchema)
            .array()
        ])
        .optional(),
      set: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateWithWhereUniqueWithoutListsManageInputSchema),
          z
            .lazy(() => UserUpdateWithWhereUniqueWithoutListsManageInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => UserUpdateManyWithWhereWithoutListsManageInputSchema),
          z
            .lazy(() => UserUpdateManyWithWhereWithoutListsManageInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => UserScalarWhereInputSchema),
          z.lazy(() => UserScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const UserUpdateManyWithoutListsNestedInputSchema: z.ZodType<Prisma.UserUpdateManyWithoutListsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutListsInputSchema),
          z.lazy(() => UserCreateWithoutListsInputSchema).array(),
          z.lazy(() => UserUncheckedCreateWithoutListsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutListsInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserCreateOrConnectWithoutListsInputSchema),
          z.lazy(() => UserCreateOrConnectWithoutListsInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => UserUpsertWithWhereUniqueWithoutListsInputSchema),
          z.lazy(() => UserUpsertWithWhereUniqueWithoutListsInputSchema).array()
        ])
        .optional(),
      set: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateWithWhereUniqueWithoutListsInputSchema),
          z.lazy(() => UserUpdateWithWhereUniqueWithoutListsInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => UserUpdateManyWithWhereWithoutListsInputSchema),
          z.lazy(() => UserUpdateManyWithWhereWithoutListsInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => UserScalarWhereInputSchema),
          z.lazy(() => UserScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CampaignUpdateManyWithoutListNestedInputSchema: z.ZodType<Prisma.CampaignUpdateManyWithoutListNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CampaignCreateWithoutListInputSchema),
          z.lazy(() => CampaignCreateWithoutListInputSchema).array(),
          z.lazy(() => CampaignUncheckedCreateWithoutListInputSchema),
          z.lazy(() => CampaignUncheckedCreateWithoutListInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CampaignCreateOrConnectWithoutListInputSchema),
          z.lazy(() => CampaignCreateOrConnectWithoutListInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CampaignUpsertWithWhereUniqueWithoutListInputSchema),
          z
            .lazy(() => CampaignUpsertWithWhereUniqueWithoutListInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CampaignCreateManyListInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CampaignWhereUniqueInputSchema),
          z.lazy(() => CampaignWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CampaignWhereUniqueInputSchema),
          z.lazy(() => CampaignWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CampaignWhereUniqueInputSchema),
          z.lazy(() => CampaignWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CampaignWhereUniqueInputSchema),
          z.lazy(() => CampaignWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CampaignUpdateWithWhereUniqueWithoutListInputSchema),
          z
            .lazy(() => CampaignUpdateWithWhereUniqueWithoutListInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CampaignUpdateManyWithWhereWithoutListInputSchema),
          z
            .lazy(() => CampaignUpdateManyWithWhereWithoutListInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CampaignScalarWhereInputSchema),
          z.lazy(() => CampaignScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const UserUncheckedUpdateManyWithoutListsManageNestedInputSchema: z.ZodType<Prisma.UserUncheckedUpdateManyWithoutListsManageNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutListsManageInputSchema),
          z.lazy(() => UserCreateWithoutListsManageInputSchema).array(),
          z.lazy(() => UserUncheckedCreateWithoutListsManageInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutListsManageInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserCreateOrConnectWithoutListsManageInputSchema),
          z.lazy(() => UserCreateOrConnectWithoutListsManageInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => UserUpsertWithWhereUniqueWithoutListsManageInputSchema),
          z
            .lazy(() => UserUpsertWithWhereUniqueWithoutListsManageInputSchema)
            .array()
        ])
        .optional(),
      set: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateWithWhereUniqueWithoutListsManageInputSchema),
          z
            .lazy(() => UserUpdateWithWhereUniqueWithoutListsManageInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => UserUpdateManyWithWhereWithoutListsManageInputSchema),
          z
            .lazy(() => UserUpdateManyWithWhereWithoutListsManageInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => UserScalarWhereInputSchema),
          z.lazy(() => UserScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const UserUncheckedUpdateManyWithoutListsNestedInputSchema: z.ZodType<Prisma.UserUncheckedUpdateManyWithoutListsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutListsInputSchema),
          z.lazy(() => UserCreateWithoutListsInputSchema).array(),
          z.lazy(() => UserUncheckedCreateWithoutListsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutListsInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserCreateOrConnectWithoutListsInputSchema),
          z.lazy(() => UserCreateOrConnectWithoutListsInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => UserUpsertWithWhereUniqueWithoutListsInputSchema),
          z.lazy(() => UserUpsertWithWhereUniqueWithoutListsInputSchema).array()
        ])
        .optional(),
      set: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateWithWhereUniqueWithoutListsInputSchema),
          z.lazy(() => UserUpdateWithWhereUniqueWithoutListsInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => UserUpdateManyWithWhereWithoutListsInputSchema),
          z.lazy(() => UserUpdateManyWithWhereWithoutListsInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => UserScalarWhereInputSchema),
          z.lazy(() => UserScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CampaignUncheckedUpdateManyWithoutListNestedInputSchema: z.ZodType<Prisma.CampaignUncheckedUpdateManyWithoutListNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CampaignCreateWithoutListInputSchema),
          z.lazy(() => CampaignCreateWithoutListInputSchema).array(),
          z.lazy(() => CampaignUncheckedCreateWithoutListInputSchema),
          z.lazy(() => CampaignUncheckedCreateWithoutListInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CampaignCreateOrConnectWithoutListInputSchema),
          z.lazy(() => CampaignCreateOrConnectWithoutListInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CampaignUpsertWithWhereUniqueWithoutListInputSchema),
          z
            .lazy(() => CampaignUpsertWithWhereUniqueWithoutListInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CampaignCreateManyListInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CampaignWhereUniqueInputSchema),
          z.lazy(() => CampaignWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CampaignWhereUniqueInputSchema),
          z.lazy(() => CampaignWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CampaignWhereUniqueInputSchema),
          z.lazy(() => CampaignWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CampaignWhereUniqueInputSchema),
          z.lazy(() => CampaignWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CampaignUpdateWithWhereUniqueWithoutListInputSchema),
          z
            .lazy(() => CampaignUpdateWithWhereUniqueWithoutListInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CampaignUpdateManyWithWhereWithoutListInputSchema),
          z
            .lazy(() => CampaignUpdateManyWithWhereWithoutListInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CampaignScalarWhereInputSchema),
          z.lazy(() => CampaignScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ListCreateNestedOneWithoutCampaignsInputSchema: z.ZodType<Prisma.ListCreateNestedOneWithoutCampaignsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ListCreateWithoutCampaignsInputSchema),
          z.lazy(() => ListUncheckedCreateWithoutCampaignsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ListCreateOrConnectWithoutCampaignsInputSchema)
        .optional(),
      connect: z.lazy(() => ListWhereUniqueInputSchema).optional()
    })
    .strict();

export const EmailCreateNestedOneWithoutCampaignsInputSchema: z.ZodType<Prisma.EmailCreateNestedOneWithoutCampaignsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => EmailCreateWithoutCampaignsInputSchema),
          z.lazy(() => EmailUncheckedCreateWithoutCampaignsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => EmailCreateOrConnectWithoutCampaignsInputSchema)
        .optional(),
      connect: z.lazy(() => EmailWhereUniqueInputSchema).optional()
    })
    .strict();

export const OutboxCreateNestedManyWithoutCampaignInputSchema: z.ZodType<Prisma.OutboxCreateNestedManyWithoutCampaignInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OutboxCreateWithoutCampaignInputSchema),
          z.lazy(() => OutboxCreateWithoutCampaignInputSchema).array(),
          z.lazy(() => OutboxUncheckedCreateWithoutCampaignInputSchema),
          z.lazy(() => OutboxUncheckedCreateWithoutCampaignInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OutboxCreateOrConnectWithoutCampaignInputSchema),
          z.lazy(() => OutboxCreateOrConnectWithoutCampaignInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => OutboxCreateManyCampaignInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OutboxWhereUniqueInputSchema),
          z.lazy(() => OutboxWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const OutboxUncheckedCreateNestedManyWithoutCampaignInputSchema: z.ZodType<Prisma.OutboxUncheckedCreateNestedManyWithoutCampaignInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OutboxCreateWithoutCampaignInputSchema),
          z.lazy(() => OutboxCreateWithoutCampaignInputSchema).array(),
          z.lazy(() => OutboxUncheckedCreateWithoutCampaignInputSchema),
          z.lazy(() => OutboxUncheckedCreateWithoutCampaignInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OutboxCreateOrConnectWithoutCampaignInputSchema),
          z.lazy(() => OutboxCreateOrConnectWithoutCampaignInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => OutboxCreateManyCampaignInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OutboxWhereUniqueInputSchema),
          z.lazy(() => OutboxWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const EnumCampaignTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumCampaignTypeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => CampaignTypeSchema).optional()
    })
    .strict();

export const ListUpdateOneWithoutCampaignsNestedInputSchema: z.ZodType<Prisma.ListUpdateOneWithoutCampaignsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ListCreateWithoutCampaignsInputSchema),
          z.lazy(() => ListUncheckedCreateWithoutCampaignsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ListCreateOrConnectWithoutCampaignsInputSchema)
        .optional(),
      upsert: z.lazy(() => ListUpsertWithoutCampaignsInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => ListWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => ListWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => ListWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ListUpdateToOneWithWhereWithoutCampaignsInputSchema),
          z.lazy(() => ListUpdateWithoutCampaignsInputSchema),
          z.lazy(() => ListUncheckedUpdateWithoutCampaignsInputSchema)
        ])
        .optional()
    })
    .strict();

export const EmailUpdateOneRequiredWithoutCampaignsNestedInputSchema: z.ZodType<Prisma.EmailUpdateOneRequiredWithoutCampaignsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => EmailCreateWithoutCampaignsInputSchema),
          z.lazy(() => EmailUncheckedCreateWithoutCampaignsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => EmailCreateOrConnectWithoutCampaignsInputSchema)
        .optional(),
      upsert: z.lazy(() => EmailUpsertWithoutCampaignsInputSchema).optional(),
      connect: z.lazy(() => EmailWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => EmailUpdateToOneWithWhereWithoutCampaignsInputSchema),
          z.lazy(() => EmailUpdateWithoutCampaignsInputSchema),
          z.lazy(() => EmailUncheckedUpdateWithoutCampaignsInputSchema)
        ])
        .optional()
    })
    .strict();

export const OutboxUpdateManyWithoutCampaignNestedInputSchema: z.ZodType<Prisma.OutboxUpdateManyWithoutCampaignNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OutboxCreateWithoutCampaignInputSchema),
          z.lazy(() => OutboxCreateWithoutCampaignInputSchema).array(),
          z.lazy(() => OutboxUncheckedCreateWithoutCampaignInputSchema),
          z.lazy(() => OutboxUncheckedCreateWithoutCampaignInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OutboxCreateOrConnectWithoutCampaignInputSchema),
          z.lazy(() => OutboxCreateOrConnectWithoutCampaignInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => OutboxUpsertWithWhereUniqueWithoutCampaignInputSchema),
          z
            .lazy(() => OutboxUpsertWithWhereUniqueWithoutCampaignInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => OutboxCreateManyCampaignInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OutboxWhereUniqueInputSchema),
          z.lazy(() => OutboxWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OutboxWhereUniqueInputSchema),
          z.lazy(() => OutboxWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OutboxWhereUniqueInputSchema),
          z.lazy(() => OutboxWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OutboxWhereUniqueInputSchema),
          z.lazy(() => OutboxWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => OutboxUpdateWithWhereUniqueWithoutCampaignInputSchema),
          z
            .lazy(() => OutboxUpdateWithWhereUniqueWithoutCampaignInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => OutboxUpdateManyWithWhereWithoutCampaignInputSchema),
          z
            .lazy(() => OutboxUpdateManyWithWhereWithoutCampaignInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OutboxScalarWhereInputSchema),
          z.lazy(() => OutboxScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const OutboxUncheckedUpdateManyWithoutCampaignNestedInputSchema: z.ZodType<Prisma.OutboxUncheckedUpdateManyWithoutCampaignNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OutboxCreateWithoutCampaignInputSchema),
          z.lazy(() => OutboxCreateWithoutCampaignInputSchema).array(),
          z.lazy(() => OutboxUncheckedCreateWithoutCampaignInputSchema),
          z.lazy(() => OutboxUncheckedCreateWithoutCampaignInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OutboxCreateOrConnectWithoutCampaignInputSchema),
          z.lazy(() => OutboxCreateOrConnectWithoutCampaignInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => OutboxUpsertWithWhereUniqueWithoutCampaignInputSchema),
          z
            .lazy(() => OutboxUpsertWithWhereUniqueWithoutCampaignInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => OutboxCreateManyCampaignInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OutboxWhereUniqueInputSchema),
          z.lazy(() => OutboxWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OutboxWhereUniqueInputSchema),
          z.lazy(() => OutboxWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OutboxWhereUniqueInputSchema),
          z.lazy(() => OutboxWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OutboxWhereUniqueInputSchema),
          z.lazy(() => OutboxWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => OutboxUpdateWithWhereUniqueWithoutCampaignInputSchema),
          z
            .lazy(() => OutboxUpdateWithWhereUniqueWithoutCampaignInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => OutboxUpdateManyWithWhereWithoutCampaignInputSchema),
          z
            .lazy(() => OutboxUpdateManyWithWhereWithoutCampaignInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OutboxScalarWhereInputSchema),
          z.lazy(() => OutboxScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const UserCreateNestedOneWithoutEmailsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutEmailsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutEmailsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutEmailsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutEmailsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const CampaignCreateNestedManyWithoutEmailInputSchema: z.ZodType<Prisma.CampaignCreateNestedManyWithoutEmailInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CampaignCreateWithoutEmailInputSchema),
          z.lazy(() => CampaignCreateWithoutEmailInputSchema).array(),
          z.lazy(() => CampaignUncheckedCreateWithoutEmailInputSchema),
          z.lazy(() => CampaignUncheckedCreateWithoutEmailInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CampaignCreateOrConnectWithoutEmailInputSchema),
          z.lazy(() => CampaignCreateOrConnectWithoutEmailInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CampaignCreateManyEmailInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CampaignWhereUniqueInputSchema),
          z.lazy(() => CampaignWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CampaignUncheckedCreateNestedManyWithoutEmailInputSchema: z.ZodType<Prisma.CampaignUncheckedCreateNestedManyWithoutEmailInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CampaignCreateWithoutEmailInputSchema),
          z.lazy(() => CampaignCreateWithoutEmailInputSchema).array(),
          z.lazy(() => CampaignUncheckedCreateWithoutEmailInputSchema),
          z.lazy(() => CampaignUncheckedCreateWithoutEmailInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CampaignCreateOrConnectWithoutEmailInputSchema),
          z.lazy(() => CampaignCreateOrConnectWithoutEmailInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CampaignCreateManyEmailInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CampaignWhereUniqueInputSchema),
          z.lazy(() => CampaignWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const UserUpdateOneRequiredWithoutEmailsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutEmailsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutEmailsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutEmailsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutEmailsInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutEmailsInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutEmailsInputSchema),
          z.lazy(() => UserUpdateWithoutEmailsInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutEmailsInputSchema)
        ])
        .optional()
    })
    .strict();

export const CampaignUpdateManyWithoutEmailNestedInputSchema: z.ZodType<Prisma.CampaignUpdateManyWithoutEmailNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CampaignCreateWithoutEmailInputSchema),
          z.lazy(() => CampaignCreateWithoutEmailInputSchema).array(),
          z.lazy(() => CampaignUncheckedCreateWithoutEmailInputSchema),
          z.lazy(() => CampaignUncheckedCreateWithoutEmailInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CampaignCreateOrConnectWithoutEmailInputSchema),
          z.lazy(() => CampaignCreateOrConnectWithoutEmailInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CampaignUpsertWithWhereUniqueWithoutEmailInputSchema),
          z
            .lazy(() => CampaignUpsertWithWhereUniqueWithoutEmailInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CampaignCreateManyEmailInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CampaignWhereUniqueInputSchema),
          z.lazy(() => CampaignWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CampaignWhereUniqueInputSchema),
          z.lazy(() => CampaignWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CampaignWhereUniqueInputSchema),
          z.lazy(() => CampaignWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CampaignWhereUniqueInputSchema),
          z.lazy(() => CampaignWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CampaignUpdateWithWhereUniqueWithoutEmailInputSchema),
          z
            .lazy(() => CampaignUpdateWithWhereUniqueWithoutEmailInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CampaignUpdateManyWithWhereWithoutEmailInputSchema),
          z
            .lazy(() => CampaignUpdateManyWithWhereWithoutEmailInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CampaignScalarWhereInputSchema),
          z.lazy(() => CampaignScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CampaignUncheckedUpdateManyWithoutEmailNestedInputSchema: z.ZodType<Prisma.CampaignUncheckedUpdateManyWithoutEmailNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CampaignCreateWithoutEmailInputSchema),
          z.lazy(() => CampaignCreateWithoutEmailInputSchema).array(),
          z.lazy(() => CampaignUncheckedCreateWithoutEmailInputSchema),
          z.lazy(() => CampaignUncheckedCreateWithoutEmailInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CampaignCreateOrConnectWithoutEmailInputSchema),
          z.lazy(() => CampaignCreateOrConnectWithoutEmailInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CampaignUpsertWithWhereUniqueWithoutEmailInputSchema),
          z
            .lazy(() => CampaignUpsertWithWhereUniqueWithoutEmailInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CampaignCreateManyEmailInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CampaignWhereUniqueInputSchema),
          z.lazy(() => CampaignWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CampaignWhereUniqueInputSchema),
          z.lazy(() => CampaignWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CampaignWhereUniqueInputSchema),
          z.lazy(() => CampaignWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CampaignWhereUniqueInputSchema),
          z.lazy(() => CampaignWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CampaignUpdateWithWhereUniqueWithoutEmailInputSchema),
          z
            .lazy(() => CampaignUpdateWithWhereUniqueWithoutEmailInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CampaignUpdateManyWithWhereWithoutEmailInputSchema),
          z
            .lazy(() => CampaignUpdateManyWithWhereWithoutEmailInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CampaignScalarWhereInputSchema),
          z.lazy(() => CampaignScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const EnumEntityTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumEntityTypeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => EntityTypeSchema).optional()
    })
    .strict();

export const EnumMediaTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumMediaTypeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => MediaTypeSchema).optional()
    })
    .strict();

export const BlockCreateNestedOneWithoutClicksInputSchema: z.ZodType<Prisma.BlockCreateNestedOneWithoutClicksInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BlockCreateWithoutClicksInputSchema),
          z.lazy(() => BlockUncheckedCreateWithoutClicksInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => BlockCreateOrConnectWithoutClicksInputSchema)
        .optional(),
      connect: z.lazy(() => BlockWhereUniqueInputSchema).optional()
    })
    .strict();

export const SiteCreateNestedOneWithoutClicksInputSchema: z.ZodType<Prisma.SiteCreateNestedOneWithoutClicksInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SiteCreateWithoutClicksInputSchema),
          z.lazy(() => SiteUncheckedCreateWithoutClicksInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => SiteCreateOrConnectWithoutClicksInputSchema)
        .optional(),
      connect: z.lazy(() => SiteWhereUniqueInputSchema).optional()
    })
    .strict();

export const LinkCreateNestedOneWithoutClicksInputSchema: z.ZodType<Prisma.LinkCreateNestedOneWithoutClicksInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LinkCreateWithoutClicksInputSchema),
          z.lazy(() => LinkUncheckedCreateWithoutClicksInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => LinkCreateOrConnectWithoutClicksInputSchema)
        .optional(),
      connect: z.lazy(() => LinkWhereUniqueInputSchema).optional()
    })
    .strict();

export const UserCreateNestedOneWithoutClicksInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutClicksInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutClicksInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutClicksInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutClicksInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const UserCreateNestedOneWithoutReferralsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutReferralsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutReferralsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutReferralsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutReferralsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const BlockUpdateOneWithoutClicksNestedInputSchema: z.ZodType<Prisma.BlockUpdateOneWithoutClicksNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BlockCreateWithoutClicksInputSchema),
          z.lazy(() => BlockUncheckedCreateWithoutClicksInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => BlockCreateOrConnectWithoutClicksInputSchema)
        .optional(),
      upsert: z.lazy(() => BlockUpsertWithoutClicksInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => BlockWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => BlockWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => BlockWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => BlockUpdateToOneWithWhereWithoutClicksInputSchema),
          z.lazy(() => BlockUpdateWithoutClicksInputSchema),
          z.lazy(() => BlockUncheckedUpdateWithoutClicksInputSchema)
        ])
        .optional()
    })
    .strict();

export const SiteUpdateOneWithoutClicksNestedInputSchema: z.ZodType<Prisma.SiteUpdateOneWithoutClicksNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SiteCreateWithoutClicksInputSchema),
          z.lazy(() => SiteUncheckedCreateWithoutClicksInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => SiteCreateOrConnectWithoutClicksInputSchema)
        .optional(),
      upsert: z.lazy(() => SiteUpsertWithoutClicksInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => SiteWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => SiteWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => SiteWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => SiteUpdateToOneWithWhereWithoutClicksInputSchema),
          z.lazy(() => SiteUpdateWithoutClicksInputSchema),
          z.lazy(() => SiteUncheckedUpdateWithoutClicksInputSchema)
        ])
        .optional()
    })
    .strict();

export const LinkUpdateOneWithoutClicksNestedInputSchema: z.ZodType<Prisma.LinkUpdateOneWithoutClicksNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LinkCreateWithoutClicksInputSchema),
          z.lazy(() => LinkUncheckedCreateWithoutClicksInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => LinkCreateOrConnectWithoutClicksInputSchema)
        .optional(),
      upsert: z.lazy(() => LinkUpsertWithoutClicksInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => LinkWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => LinkWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => LinkWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => LinkUpdateToOneWithWhereWithoutClicksInputSchema),
          z.lazy(() => LinkUpdateWithoutClicksInputSchema),
          z.lazy(() => LinkUncheckedUpdateWithoutClicksInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserUpdateOneWithoutClicksNestedInputSchema: z.ZodType<Prisma.UserUpdateOneWithoutClicksNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutClicksInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutClicksInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutClicksInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutClicksInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutClicksInputSchema),
          z.lazy(() => UserUpdateWithoutClicksInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutClicksInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserUpdateOneWithoutReferralsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneWithoutReferralsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutReferralsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutReferralsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutReferralsInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutReferralsInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutReferralsInputSchema),
          z.lazy(() => UserUpdateWithoutReferralsInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutReferralsInputSchema)
        ])
        .optional()
    })
    .strict();

export const ClickCreateNestedManyWithoutLinkInputSchema: z.ZodType<Prisma.ClickCreateNestedManyWithoutLinkInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ClickCreateWithoutLinkInputSchema),
          z.lazy(() => ClickCreateWithoutLinkInputSchema).array(),
          z.lazy(() => ClickUncheckedCreateWithoutLinkInputSchema),
          z.lazy(() => ClickUncheckedCreateWithoutLinkInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ClickCreateOrConnectWithoutLinkInputSchema),
          z.lazy(() => ClickCreateOrConnectWithoutLinkInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ClickCreateManyLinkInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const UserCreateNestedOneWithoutLinksInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutLinksInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutLinksInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutLinksInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutLinksInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const ClickUncheckedCreateNestedManyWithoutLinkInputSchema: z.ZodType<Prisma.ClickUncheckedCreateNestedManyWithoutLinkInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ClickCreateWithoutLinkInputSchema),
          z.lazy(() => ClickCreateWithoutLinkInputSchema).array(),
          z.lazy(() => ClickUncheckedCreateWithoutLinkInputSchema),
          z.lazy(() => ClickUncheckedCreateWithoutLinkInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ClickCreateOrConnectWithoutLinkInputSchema),
          z.lazy(() => ClickCreateOrConnectWithoutLinkInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ClickCreateManyLinkInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ClickUpdateManyWithoutLinkNestedInputSchema: z.ZodType<Prisma.ClickUpdateManyWithoutLinkNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ClickCreateWithoutLinkInputSchema),
          z.lazy(() => ClickCreateWithoutLinkInputSchema).array(),
          z.lazy(() => ClickUncheckedCreateWithoutLinkInputSchema),
          z.lazy(() => ClickUncheckedCreateWithoutLinkInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ClickCreateOrConnectWithoutLinkInputSchema),
          z.lazy(() => ClickCreateOrConnectWithoutLinkInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ClickUpsertWithWhereUniqueWithoutLinkInputSchema),
          z.lazy(() => ClickUpsertWithWhereUniqueWithoutLinkInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ClickCreateManyLinkInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ClickUpdateWithWhereUniqueWithoutLinkInputSchema),
          z.lazy(() => ClickUpdateWithWhereUniqueWithoutLinkInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ClickUpdateManyWithWhereWithoutLinkInputSchema),
          z.lazy(() => ClickUpdateManyWithWhereWithoutLinkInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ClickScalarWhereInputSchema),
          z.lazy(() => ClickScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const UserUpdateOneWithoutLinksNestedInputSchema: z.ZodType<Prisma.UserUpdateOneWithoutLinksNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutLinksInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutLinksInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutLinksInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutLinksInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutLinksInputSchema),
          z.lazy(() => UserUpdateWithoutLinksInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutLinksInputSchema)
        ])
        .optional()
    })
    .strict();

export const ClickUncheckedUpdateManyWithoutLinkNestedInputSchema: z.ZodType<Prisma.ClickUncheckedUpdateManyWithoutLinkNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ClickCreateWithoutLinkInputSchema),
          z.lazy(() => ClickCreateWithoutLinkInputSchema).array(),
          z.lazy(() => ClickUncheckedCreateWithoutLinkInputSchema),
          z.lazy(() => ClickUncheckedCreateWithoutLinkInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ClickCreateOrConnectWithoutLinkInputSchema),
          z.lazy(() => ClickCreateOrConnectWithoutLinkInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ClickUpsertWithWhereUniqueWithoutLinkInputSchema),
          z.lazy(() => ClickUpsertWithWhereUniqueWithoutLinkInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ClickCreateManyLinkInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ClickUpdateWithWhereUniqueWithoutLinkInputSchema),
          z.lazy(() => ClickUpdateWithWhereUniqueWithoutLinkInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ClickUpdateManyWithWhereWithoutLinkInputSchema),
          z.lazy(() => ClickUpdateManyWithWhereWithoutLinkInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ClickScalarWhereInputSchema),
          z.lazy(() => ClickScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ClickCreateNestedManyWithoutBlockInputSchema: z.ZodType<Prisma.ClickCreateNestedManyWithoutBlockInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ClickCreateWithoutBlockInputSchema),
          z.lazy(() => ClickCreateWithoutBlockInputSchema).array(),
          z.lazy(() => ClickUncheckedCreateWithoutBlockInputSchema),
          z.lazy(() => ClickUncheckedCreateWithoutBlockInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ClickCreateOrConnectWithoutBlockInputSchema),
          z.lazy(() => ClickCreateOrConnectWithoutBlockInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ClickCreateManyBlockInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ReservationCreateNestedManyWithoutBlockInputSchema: z.ZodType<Prisma.ReservationCreateNestedManyWithoutBlockInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ReservationCreateWithoutBlockInputSchema),
          z.lazy(() => ReservationCreateWithoutBlockInputSchema).array(),
          z.lazy(() => ReservationUncheckedCreateWithoutBlockInputSchema),
          z
            .lazy(() => ReservationUncheckedCreateWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ReservationCreateOrConnectWithoutBlockInputSchema),
          z
            .lazy(() => ReservationCreateOrConnectWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ReservationCreateManyBlockInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ReservationWhereUniqueInputSchema),
          z.lazy(() => ReservationWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const SiteCreateNestedOneWithoutBlocksInputSchema: z.ZodType<Prisma.SiteCreateNestedOneWithoutBlocksInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SiteCreateWithoutBlocksInputSchema),
          z.lazy(() => SiteUncheckedCreateWithoutBlocksInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => SiteCreateOrConnectWithoutBlocksInputSchema)
        .optional(),
      connect: z.lazy(() => SiteWhereUniqueInputSchema).optional()
    })
    .strict();

export const CategoryCreateNestedManyWithoutBlockInputSchema: z.ZodType<Prisma.CategoryCreateNestedManyWithoutBlockInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CategoryCreateWithoutBlockInputSchema),
          z.lazy(() => CategoryCreateWithoutBlockInputSchema).array(),
          z.lazy(() => CategoryUncheckedCreateWithoutBlockInputSchema),
          z.lazy(() => CategoryUncheckedCreateWithoutBlockInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CategoryCreateOrConnectWithoutBlockInputSchema),
          z.lazy(() => CategoryCreateOrConnectWithoutBlockInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CategoryCreateManyBlockInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const InventoryCreateNestedManyWithoutBlockInputSchema: z.ZodType<Prisma.InventoryCreateNestedManyWithoutBlockInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InventoryCreateWithoutBlockInputSchema),
          z.lazy(() => InventoryCreateWithoutBlockInputSchema).array(),
          z.lazy(() => InventoryUncheckedCreateWithoutBlockInputSchema),
          z.lazy(() => InventoryUncheckedCreateWithoutBlockInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => InventoryCreateOrConnectWithoutBlockInputSchema),
          z.lazy(() => InventoryCreateOrConnectWithoutBlockInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => InventoryCreateManyBlockInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => InventoryWhereUniqueInputSchema),
          z.lazy(() => InventoryWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ClickUncheckedCreateNestedManyWithoutBlockInputSchema: z.ZodType<Prisma.ClickUncheckedCreateNestedManyWithoutBlockInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ClickCreateWithoutBlockInputSchema),
          z.lazy(() => ClickCreateWithoutBlockInputSchema).array(),
          z.lazy(() => ClickUncheckedCreateWithoutBlockInputSchema),
          z.lazy(() => ClickUncheckedCreateWithoutBlockInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ClickCreateOrConnectWithoutBlockInputSchema),
          z.lazy(() => ClickCreateOrConnectWithoutBlockInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ClickCreateManyBlockInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ReservationUncheckedCreateNestedManyWithoutBlockInputSchema: z.ZodType<Prisma.ReservationUncheckedCreateNestedManyWithoutBlockInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ReservationCreateWithoutBlockInputSchema),
          z.lazy(() => ReservationCreateWithoutBlockInputSchema).array(),
          z.lazy(() => ReservationUncheckedCreateWithoutBlockInputSchema),
          z
            .lazy(() => ReservationUncheckedCreateWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ReservationCreateOrConnectWithoutBlockInputSchema),
          z
            .lazy(() => ReservationCreateOrConnectWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ReservationCreateManyBlockInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ReservationWhereUniqueInputSchema),
          z.lazy(() => ReservationWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CategoryUncheckedCreateNestedManyWithoutBlockInputSchema: z.ZodType<Prisma.CategoryUncheckedCreateNestedManyWithoutBlockInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CategoryCreateWithoutBlockInputSchema),
          z.lazy(() => CategoryCreateWithoutBlockInputSchema).array(),
          z.lazy(() => CategoryUncheckedCreateWithoutBlockInputSchema),
          z.lazy(() => CategoryUncheckedCreateWithoutBlockInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CategoryCreateOrConnectWithoutBlockInputSchema),
          z.lazy(() => CategoryCreateOrConnectWithoutBlockInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CategoryCreateManyBlockInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const InventoryUncheckedCreateNestedManyWithoutBlockInputSchema: z.ZodType<Prisma.InventoryUncheckedCreateNestedManyWithoutBlockInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InventoryCreateWithoutBlockInputSchema),
          z.lazy(() => InventoryCreateWithoutBlockInputSchema).array(),
          z.lazy(() => InventoryUncheckedCreateWithoutBlockInputSchema),
          z.lazy(() => InventoryUncheckedCreateWithoutBlockInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => InventoryCreateOrConnectWithoutBlockInputSchema),
          z.lazy(() => InventoryCreateOrConnectWithoutBlockInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => InventoryCreateManyBlockInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => InventoryWhereUniqueInputSchema),
          z.lazy(() => InventoryWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ClickUpdateManyWithoutBlockNestedInputSchema: z.ZodType<Prisma.ClickUpdateManyWithoutBlockNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ClickCreateWithoutBlockInputSchema),
          z.lazy(() => ClickCreateWithoutBlockInputSchema).array(),
          z.lazy(() => ClickUncheckedCreateWithoutBlockInputSchema),
          z.lazy(() => ClickUncheckedCreateWithoutBlockInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ClickCreateOrConnectWithoutBlockInputSchema),
          z.lazy(() => ClickCreateOrConnectWithoutBlockInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ClickUpsertWithWhereUniqueWithoutBlockInputSchema),
          z
            .lazy(() => ClickUpsertWithWhereUniqueWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ClickCreateManyBlockInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ClickUpdateWithWhereUniqueWithoutBlockInputSchema),
          z
            .lazy(() => ClickUpdateWithWhereUniqueWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ClickUpdateManyWithWhereWithoutBlockInputSchema),
          z.lazy(() => ClickUpdateManyWithWhereWithoutBlockInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ClickScalarWhereInputSchema),
          z.lazy(() => ClickScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ReservationUpdateManyWithoutBlockNestedInputSchema: z.ZodType<Prisma.ReservationUpdateManyWithoutBlockNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ReservationCreateWithoutBlockInputSchema),
          z.lazy(() => ReservationCreateWithoutBlockInputSchema).array(),
          z.lazy(() => ReservationUncheckedCreateWithoutBlockInputSchema),
          z
            .lazy(() => ReservationUncheckedCreateWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ReservationCreateOrConnectWithoutBlockInputSchema),
          z
            .lazy(() => ReservationCreateOrConnectWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ReservationUpsertWithWhereUniqueWithoutBlockInputSchema),
          z
            .lazy(() => ReservationUpsertWithWhereUniqueWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ReservationCreateManyBlockInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ReservationWhereUniqueInputSchema),
          z.lazy(() => ReservationWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ReservationWhereUniqueInputSchema),
          z.lazy(() => ReservationWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ReservationWhereUniqueInputSchema),
          z.lazy(() => ReservationWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ReservationWhereUniqueInputSchema),
          z.lazy(() => ReservationWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ReservationUpdateWithWhereUniqueWithoutBlockInputSchema),
          z
            .lazy(() => ReservationUpdateWithWhereUniqueWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ReservationUpdateManyWithWhereWithoutBlockInputSchema),
          z
            .lazy(() => ReservationUpdateManyWithWhereWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ReservationScalarWhereInputSchema),
          z.lazy(() => ReservationScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const SiteUpdateOneRequiredWithoutBlocksNestedInputSchema: z.ZodType<Prisma.SiteUpdateOneRequiredWithoutBlocksNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SiteCreateWithoutBlocksInputSchema),
          z.lazy(() => SiteUncheckedCreateWithoutBlocksInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => SiteCreateOrConnectWithoutBlocksInputSchema)
        .optional(),
      upsert: z.lazy(() => SiteUpsertWithoutBlocksInputSchema).optional(),
      connect: z.lazy(() => SiteWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => SiteUpdateToOneWithWhereWithoutBlocksInputSchema),
          z.lazy(() => SiteUpdateWithoutBlocksInputSchema),
          z.lazy(() => SiteUncheckedUpdateWithoutBlocksInputSchema)
        ])
        .optional()
    })
    .strict();

export const CategoryUpdateManyWithoutBlockNestedInputSchema: z.ZodType<Prisma.CategoryUpdateManyWithoutBlockNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CategoryCreateWithoutBlockInputSchema),
          z.lazy(() => CategoryCreateWithoutBlockInputSchema).array(),
          z.lazy(() => CategoryUncheckedCreateWithoutBlockInputSchema),
          z.lazy(() => CategoryUncheckedCreateWithoutBlockInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CategoryCreateOrConnectWithoutBlockInputSchema),
          z.lazy(() => CategoryCreateOrConnectWithoutBlockInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CategoryUpsertWithWhereUniqueWithoutBlockInputSchema),
          z
            .lazy(() => CategoryUpsertWithWhereUniqueWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CategoryCreateManyBlockInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CategoryUpdateWithWhereUniqueWithoutBlockInputSchema),
          z
            .lazy(() => CategoryUpdateWithWhereUniqueWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CategoryUpdateManyWithWhereWithoutBlockInputSchema),
          z
            .lazy(() => CategoryUpdateManyWithWhereWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CategoryScalarWhereInputSchema),
          z.lazy(() => CategoryScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const InventoryUpdateManyWithoutBlockNestedInputSchema: z.ZodType<Prisma.InventoryUpdateManyWithoutBlockNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InventoryCreateWithoutBlockInputSchema),
          z.lazy(() => InventoryCreateWithoutBlockInputSchema).array(),
          z.lazy(() => InventoryUncheckedCreateWithoutBlockInputSchema),
          z.lazy(() => InventoryUncheckedCreateWithoutBlockInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => InventoryCreateOrConnectWithoutBlockInputSchema),
          z.lazy(() => InventoryCreateOrConnectWithoutBlockInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => InventoryUpsertWithWhereUniqueWithoutBlockInputSchema),
          z
            .lazy(() => InventoryUpsertWithWhereUniqueWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => InventoryCreateManyBlockInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => InventoryWhereUniqueInputSchema),
          z.lazy(() => InventoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => InventoryWhereUniqueInputSchema),
          z.lazy(() => InventoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => InventoryWhereUniqueInputSchema),
          z.lazy(() => InventoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => InventoryWhereUniqueInputSchema),
          z.lazy(() => InventoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => InventoryUpdateWithWhereUniqueWithoutBlockInputSchema),
          z
            .lazy(() => InventoryUpdateWithWhereUniqueWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => InventoryUpdateManyWithWhereWithoutBlockInputSchema),
          z
            .lazy(() => InventoryUpdateManyWithWhereWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => InventoryScalarWhereInputSchema),
          z.lazy(() => InventoryScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ClickUncheckedUpdateManyWithoutBlockNestedInputSchema: z.ZodType<Prisma.ClickUncheckedUpdateManyWithoutBlockNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ClickCreateWithoutBlockInputSchema),
          z.lazy(() => ClickCreateWithoutBlockInputSchema).array(),
          z.lazy(() => ClickUncheckedCreateWithoutBlockInputSchema),
          z.lazy(() => ClickUncheckedCreateWithoutBlockInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ClickCreateOrConnectWithoutBlockInputSchema),
          z.lazy(() => ClickCreateOrConnectWithoutBlockInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ClickUpsertWithWhereUniqueWithoutBlockInputSchema),
          z
            .lazy(() => ClickUpsertWithWhereUniqueWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ClickCreateManyBlockInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ClickUpdateWithWhereUniqueWithoutBlockInputSchema),
          z
            .lazy(() => ClickUpdateWithWhereUniqueWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ClickUpdateManyWithWhereWithoutBlockInputSchema),
          z.lazy(() => ClickUpdateManyWithWhereWithoutBlockInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ClickScalarWhereInputSchema),
          z.lazy(() => ClickScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ReservationUncheckedUpdateManyWithoutBlockNestedInputSchema: z.ZodType<Prisma.ReservationUncheckedUpdateManyWithoutBlockNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ReservationCreateWithoutBlockInputSchema),
          z.lazy(() => ReservationCreateWithoutBlockInputSchema).array(),
          z.lazy(() => ReservationUncheckedCreateWithoutBlockInputSchema),
          z
            .lazy(() => ReservationUncheckedCreateWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ReservationCreateOrConnectWithoutBlockInputSchema),
          z
            .lazy(() => ReservationCreateOrConnectWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ReservationUpsertWithWhereUniqueWithoutBlockInputSchema),
          z
            .lazy(() => ReservationUpsertWithWhereUniqueWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ReservationCreateManyBlockInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ReservationWhereUniqueInputSchema),
          z.lazy(() => ReservationWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ReservationWhereUniqueInputSchema),
          z.lazy(() => ReservationWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ReservationWhereUniqueInputSchema),
          z.lazy(() => ReservationWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ReservationWhereUniqueInputSchema),
          z.lazy(() => ReservationWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ReservationUpdateWithWhereUniqueWithoutBlockInputSchema),
          z
            .lazy(() => ReservationUpdateWithWhereUniqueWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ReservationUpdateManyWithWhereWithoutBlockInputSchema),
          z
            .lazy(() => ReservationUpdateManyWithWhereWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ReservationScalarWhereInputSchema),
          z.lazy(() => ReservationScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CategoryUncheckedUpdateManyWithoutBlockNestedInputSchema: z.ZodType<Prisma.CategoryUncheckedUpdateManyWithoutBlockNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CategoryCreateWithoutBlockInputSchema),
          z.lazy(() => CategoryCreateWithoutBlockInputSchema).array(),
          z.lazy(() => CategoryUncheckedCreateWithoutBlockInputSchema),
          z.lazy(() => CategoryUncheckedCreateWithoutBlockInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CategoryCreateOrConnectWithoutBlockInputSchema),
          z.lazy(() => CategoryCreateOrConnectWithoutBlockInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CategoryUpsertWithWhereUniqueWithoutBlockInputSchema),
          z
            .lazy(() => CategoryUpsertWithWhereUniqueWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CategoryCreateManyBlockInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CategoryUpdateWithWhereUniqueWithoutBlockInputSchema),
          z
            .lazy(() => CategoryUpdateWithWhereUniqueWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CategoryUpdateManyWithWhereWithoutBlockInputSchema),
          z
            .lazy(() => CategoryUpdateManyWithWhereWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CategoryScalarWhereInputSchema),
          z.lazy(() => CategoryScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const InventoryUncheckedUpdateManyWithoutBlockNestedInputSchema: z.ZodType<Prisma.InventoryUncheckedUpdateManyWithoutBlockNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InventoryCreateWithoutBlockInputSchema),
          z.lazy(() => InventoryCreateWithoutBlockInputSchema).array(),
          z.lazy(() => InventoryUncheckedCreateWithoutBlockInputSchema),
          z.lazy(() => InventoryUncheckedCreateWithoutBlockInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => InventoryCreateOrConnectWithoutBlockInputSchema),
          z.lazy(() => InventoryCreateOrConnectWithoutBlockInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => InventoryUpsertWithWhereUniqueWithoutBlockInputSchema),
          z
            .lazy(() => InventoryUpsertWithWhereUniqueWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => InventoryCreateManyBlockInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => InventoryWhereUniqueInputSchema),
          z.lazy(() => InventoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => InventoryWhereUniqueInputSchema),
          z.lazy(() => InventoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => InventoryWhereUniqueInputSchema),
          z.lazy(() => InventoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => InventoryWhereUniqueInputSchema),
          z.lazy(() => InventoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => InventoryUpdateWithWhereUniqueWithoutBlockInputSchema),
          z
            .lazy(() => InventoryUpdateWithWhereUniqueWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => InventoryUpdateManyWithWhereWithoutBlockInputSchema),
          z
            .lazy(() => InventoryUpdateManyWithWhereWithoutBlockInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => InventoryScalarWhereInputSchema),
          z.lazy(() => InventoryScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const SiteCreateNestedOneWithoutLikesInputSchema: z.ZodType<Prisma.SiteCreateNestedOneWithoutLikesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SiteCreateWithoutLikesInputSchema),
          z.lazy(() => SiteUncheckedCreateWithoutLikesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => SiteCreateOrConnectWithoutLikesInputSchema)
        .optional(),
      connect: z.lazy(() => SiteWhereUniqueInputSchema).optional()
    })
    .strict();

export const UserCreateNestedOneWithoutLikesInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutLikesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutLikesInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutLikesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutLikesInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const FeedCreateNestedOneWithoutLikesInputSchema: z.ZodType<Prisma.FeedCreateNestedOneWithoutLikesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FeedCreateWithoutLikesInputSchema),
          z.lazy(() => FeedUncheckedCreateWithoutLikesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => FeedCreateOrConnectWithoutLikesInputSchema)
        .optional(),
      connect: z.lazy(() => FeedWhereUniqueInputSchema).optional()
    })
    .strict();

export const SiteUpdateOneRequiredWithoutLikesNestedInputSchema: z.ZodType<Prisma.SiteUpdateOneRequiredWithoutLikesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SiteCreateWithoutLikesInputSchema),
          z.lazy(() => SiteUncheckedCreateWithoutLikesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => SiteCreateOrConnectWithoutLikesInputSchema)
        .optional(),
      upsert: z.lazy(() => SiteUpsertWithoutLikesInputSchema).optional(),
      connect: z.lazy(() => SiteWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => SiteUpdateToOneWithWhereWithoutLikesInputSchema),
          z.lazy(() => SiteUpdateWithoutLikesInputSchema),
          z.lazy(() => SiteUncheckedUpdateWithoutLikesInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserUpdateOneWithoutLikesNestedInputSchema: z.ZodType<Prisma.UserUpdateOneWithoutLikesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutLikesInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutLikesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutLikesInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutLikesInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutLikesInputSchema),
          z.lazy(() => UserUpdateWithoutLikesInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutLikesInputSchema)
        ])
        .optional()
    })
    .strict();

export const FeedUpdateOneWithoutLikesNestedInputSchema: z.ZodType<Prisma.FeedUpdateOneWithoutLikesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FeedCreateWithoutLikesInputSchema),
          z.lazy(() => FeedUncheckedCreateWithoutLikesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => FeedCreateOrConnectWithoutLikesInputSchema)
        .optional(),
      upsert: z.lazy(() => FeedUpsertWithoutLikesInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => FeedWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => FeedWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => FeedWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => FeedUpdateToOneWithWhereWithoutLikesInputSchema),
          z.lazy(() => FeedUpdateWithoutLikesInputSchema),
          z.lazy(() => FeedUncheckedUpdateWithoutLikesInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserCreateNestedOneWithoutSitesInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutSitesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutSitesInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutSitesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutSitesInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const BlockCreateNestedManyWithoutSiteInputSchema: z.ZodType<Prisma.BlockCreateNestedManyWithoutSiteInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BlockCreateWithoutSiteInputSchema),
          z.lazy(() => BlockCreateWithoutSiteInputSchema).array(),
          z.lazy(() => BlockUncheckedCreateWithoutSiteInputSchema),
          z.lazy(() => BlockUncheckedCreateWithoutSiteInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => BlockCreateOrConnectWithoutSiteInputSchema),
          z.lazy(() => BlockCreateOrConnectWithoutSiteInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => BlockCreateManySiteInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => BlockWhereUniqueInputSchema),
          z.lazy(() => BlockWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ClickCreateNestedManyWithoutSiteInputSchema: z.ZodType<Prisma.ClickCreateNestedManyWithoutSiteInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ClickCreateWithoutSiteInputSchema),
          z.lazy(() => ClickCreateWithoutSiteInputSchema).array(),
          z.lazy(() => ClickUncheckedCreateWithoutSiteInputSchema),
          z.lazy(() => ClickUncheckedCreateWithoutSiteInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ClickCreateOrConnectWithoutSiteInputSchema),
          z.lazy(() => ClickCreateOrConnectWithoutSiteInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ClickCreateManySiteInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const SubscriberCreateNestedManyWithoutSiteInputSchema: z.ZodType<Prisma.SubscriberCreateNestedManyWithoutSiteInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriberCreateWithoutSiteInputSchema),
          z.lazy(() => SubscriberCreateWithoutSiteInputSchema).array(),
          z.lazy(() => SubscriberUncheckedCreateWithoutSiteInputSchema),
          z.lazy(() => SubscriberUncheckedCreateWithoutSiteInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriberCreateOrConnectWithoutSiteInputSchema),
          z.lazy(() => SubscriberCreateOrConnectWithoutSiteInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => SubscriberCreateManySiteInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => SubscriberWhereUniqueInputSchema),
          z.lazy(() => SubscriberWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const LikeCreateNestedManyWithoutSiteInputSchema: z.ZodType<Prisma.LikeCreateNestedManyWithoutSiteInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LikeCreateWithoutSiteInputSchema),
          z.lazy(() => LikeCreateWithoutSiteInputSchema).array(),
          z.lazy(() => LikeUncheckedCreateWithoutSiteInputSchema),
          z.lazy(() => LikeUncheckedCreateWithoutSiteInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => LikeCreateOrConnectWithoutSiteInputSchema),
          z.lazy(() => LikeCreateOrConnectWithoutSiteInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => LikeCreateManySiteInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const FeedCreateNestedManyWithoutSiteInputSchema: z.ZodType<Prisma.FeedCreateNestedManyWithoutSiteInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FeedCreateWithoutSiteInputSchema),
          z.lazy(() => FeedCreateWithoutSiteInputSchema).array(),
          z.lazy(() => FeedUncheckedCreateWithoutSiteInputSchema),
          z.lazy(() => FeedUncheckedCreateWithoutSiteInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => FeedCreateOrConnectWithoutSiteInputSchema),
          z.lazy(() => FeedCreateOrConnectWithoutSiteInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => FeedCreateManySiteInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => FeedWhereUniqueInputSchema),
          z.lazy(() => FeedWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const BlockUncheckedCreateNestedManyWithoutSiteInputSchema: z.ZodType<Prisma.BlockUncheckedCreateNestedManyWithoutSiteInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BlockCreateWithoutSiteInputSchema),
          z.lazy(() => BlockCreateWithoutSiteInputSchema).array(),
          z.lazy(() => BlockUncheckedCreateWithoutSiteInputSchema),
          z.lazy(() => BlockUncheckedCreateWithoutSiteInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => BlockCreateOrConnectWithoutSiteInputSchema),
          z.lazy(() => BlockCreateOrConnectWithoutSiteInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => BlockCreateManySiteInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => BlockWhereUniqueInputSchema),
          z.lazy(() => BlockWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ClickUncheckedCreateNestedManyWithoutSiteInputSchema: z.ZodType<Prisma.ClickUncheckedCreateNestedManyWithoutSiteInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ClickCreateWithoutSiteInputSchema),
          z.lazy(() => ClickCreateWithoutSiteInputSchema).array(),
          z.lazy(() => ClickUncheckedCreateWithoutSiteInputSchema),
          z.lazy(() => ClickUncheckedCreateWithoutSiteInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ClickCreateOrConnectWithoutSiteInputSchema),
          z.lazy(() => ClickCreateOrConnectWithoutSiteInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ClickCreateManySiteInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const SubscriberUncheckedCreateNestedManyWithoutSiteInputSchema: z.ZodType<Prisma.SubscriberUncheckedCreateNestedManyWithoutSiteInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriberCreateWithoutSiteInputSchema),
          z.lazy(() => SubscriberCreateWithoutSiteInputSchema).array(),
          z.lazy(() => SubscriberUncheckedCreateWithoutSiteInputSchema),
          z.lazy(() => SubscriberUncheckedCreateWithoutSiteInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriberCreateOrConnectWithoutSiteInputSchema),
          z.lazy(() => SubscriberCreateOrConnectWithoutSiteInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => SubscriberCreateManySiteInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => SubscriberWhereUniqueInputSchema),
          z.lazy(() => SubscriberWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const LikeUncheckedCreateNestedManyWithoutSiteInputSchema: z.ZodType<Prisma.LikeUncheckedCreateNestedManyWithoutSiteInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LikeCreateWithoutSiteInputSchema),
          z.lazy(() => LikeCreateWithoutSiteInputSchema).array(),
          z.lazy(() => LikeUncheckedCreateWithoutSiteInputSchema),
          z.lazy(() => LikeUncheckedCreateWithoutSiteInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => LikeCreateOrConnectWithoutSiteInputSchema),
          z.lazy(() => LikeCreateOrConnectWithoutSiteInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => LikeCreateManySiteInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const FeedUncheckedCreateNestedManyWithoutSiteInputSchema: z.ZodType<Prisma.FeedUncheckedCreateNestedManyWithoutSiteInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FeedCreateWithoutSiteInputSchema),
          z.lazy(() => FeedCreateWithoutSiteInputSchema).array(),
          z.lazy(() => FeedUncheckedCreateWithoutSiteInputSchema),
          z.lazy(() => FeedUncheckedCreateWithoutSiteInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => FeedCreateOrConnectWithoutSiteInputSchema),
          z.lazy(() => FeedCreateOrConnectWithoutSiteInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => FeedCreateManySiteInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => FeedWhereUniqueInputSchema),
          z.lazy(() => FeedWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const UserUpdateOneRequiredWithoutSitesNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutSitesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutSitesInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutSitesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutSitesInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutSitesInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutSitesInputSchema),
          z.lazy(() => UserUpdateWithoutSitesInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutSitesInputSchema)
        ])
        .optional()
    })
    .strict();

export const BlockUpdateManyWithoutSiteNestedInputSchema: z.ZodType<Prisma.BlockUpdateManyWithoutSiteNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BlockCreateWithoutSiteInputSchema),
          z.lazy(() => BlockCreateWithoutSiteInputSchema).array(),
          z.lazy(() => BlockUncheckedCreateWithoutSiteInputSchema),
          z.lazy(() => BlockUncheckedCreateWithoutSiteInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => BlockCreateOrConnectWithoutSiteInputSchema),
          z.lazy(() => BlockCreateOrConnectWithoutSiteInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => BlockUpsertWithWhereUniqueWithoutSiteInputSchema),
          z.lazy(() => BlockUpsertWithWhereUniqueWithoutSiteInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => BlockCreateManySiteInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => BlockWhereUniqueInputSchema),
          z.lazy(() => BlockWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => BlockWhereUniqueInputSchema),
          z.lazy(() => BlockWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => BlockWhereUniqueInputSchema),
          z.lazy(() => BlockWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => BlockWhereUniqueInputSchema),
          z.lazy(() => BlockWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => BlockUpdateWithWhereUniqueWithoutSiteInputSchema),
          z.lazy(() => BlockUpdateWithWhereUniqueWithoutSiteInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => BlockUpdateManyWithWhereWithoutSiteInputSchema),
          z.lazy(() => BlockUpdateManyWithWhereWithoutSiteInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => BlockScalarWhereInputSchema),
          z.lazy(() => BlockScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ClickUpdateManyWithoutSiteNestedInputSchema: z.ZodType<Prisma.ClickUpdateManyWithoutSiteNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ClickCreateWithoutSiteInputSchema),
          z.lazy(() => ClickCreateWithoutSiteInputSchema).array(),
          z.lazy(() => ClickUncheckedCreateWithoutSiteInputSchema),
          z.lazy(() => ClickUncheckedCreateWithoutSiteInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ClickCreateOrConnectWithoutSiteInputSchema),
          z.lazy(() => ClickCreateOrConnectWithoutSiteInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ClickUpsertWithWhereUniqueWithoutSiteInputSchema),
          z.lazy(() => ClickUpsertWithWhereUniqueWithoutSiteInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ClickCreateManySiteInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ClickUpdateWithWhereUniqueWithoutSiteInputSchema),
          z.lazy(() => ClickUpdateWithWhereUniqueWithoutSiteInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ClickUpdateManyWithWhereWithoutSiteInputSchema),
          z.lazy(() => ClickUpdateManyWithWhereWithoutSiteInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ClickScalarWhereInputSchema),
          z.lazy(() => ClickScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const SubscriberUpdateManyWithoutSiteNestedInputSchema: z.ZodType<Prisma.SubscriberUpdateManyWithoutSiteNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriberCreateWithoutSiteInputSchema),
          z.lazy(() => SubscriberCreateWithoutSiteInputSchema).array(),
          z.lazy(() => SubscriberUncheckedCreateWithoutSiteInputSchema),
          z.lazy(() => SubscriberUncheckedCreateWithoutSiteInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriberCreateOrConnectWithoutSiteInputSchema),
          z.lazy(() => SubscriberCreateOrConnectWithoutSiteInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => SubscriberUpsertWithWhereUniqueWithoutSiteInputSchema),
          z
            .lazy(() => SubscriberUpsertWithWhereUniqueWithoutSiteInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => SubscriberCreateManySiteInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => SubscriberWhereUniqueInputSchema),
          z.lazy(() => SubscriberWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => SubscriberWhereUniqueInputSchema),
          z.lazy(() => SubscriberWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => SubscriberWhereUniqueInputSchema),
          z.lazy(() => SubscriberWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => SubscriberWhereUniqueInputSchema),
          z.lazy(() => SubscriberWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => SubscriberUpdateWithWhereUniqueWithoutSiteInputSchema),
          z
            .lazy(() => SubscriberUpdateWithWhereUniqueWithoutSiteInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => SubscriberUpdateManyWithWhereWithoutSiteInputSchema),
          z
            .lazy(() => SubscriberUpdateManyWithWhereWithoutSiteInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => SubscriberScalarWhereInputSchema),
          z.lazy(() => SubscriberScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const LikeUpdateManyWithoutSiteNestedInputSchema: z.ZodType<Prisma.LikeUpdateManyWithoutSiteNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LikeCreateWithoutSiteInputSchema),
          z.lazy(() => LikeCreateWithoutSiteInputSchema).array(),
          z.lazy(() => LikeUncheckedCreateWithoutSiteInputSchema),
          z.lazy(() => LikeUncheckedCreateWithoutSiteInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => LikeCreateOrConnectWithoutSiteInputSchema),
          z.lazy(() => LikeCreateOrConnectWithoutSiteInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => LikeUpsertWithWhereUniqueWithoutSiteInputSchema),
          z.lazy(() => LikeUpsertWithWhereUniqueWithoutSiteInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => LikeCreateManySiteInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => LikeUpdateWithWhereUniqueWithoutSiteInputSchema),
          z.lazy(() => LikeUpdateWithWhereUniqueWithoutSiteInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => LikeUpdateManyWithWhereWithoutSiteInputSchema),
          z.lazy(() => LikeUpdateManyWithWhereWithoutSiteInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => LikeScalarWhereInputSchema),
          z.lazy(() => LikeScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const FeedUpdateManyWithoutSiteNestedInputSchema: z.ZodType<Prisma.FeedUpdateManyWithoutSiteNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FeedCreateWithoutSiteInputSchema),
          z.lazy(() => FeedCreateWithoutSiteInputSchema).array(),
          z.lazy(() => FeedUncheckedCreateWithoutSiteInputSchema),
          z.lazy(() => FeedUncheckedCreateWithoutSiteInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => FeedCreateOrConnectWithoutSiteInputSchema),
          z.lazy(() => FeedCreateOrConnectWithoutSiteInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => FeedUpsertWithWhereUniqueWithoutSiteInputSchema),
          z.lazy(() => FeedUpsertWithWhereUniqueWithoutSiteInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => FeedCreateManySiteInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => FeedWhereUniqueInputSchema),
          z.lazy(() => FeedWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => FeedWhereUniqueInputSchema),
          z.lazy(() => FeedWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => FeedWhereUniqueInputSchema),
          z.lazy(() => FeedWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => FeedWhereUniqueInputSchema),
          z.lazy(() => FeedWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => FeedUpdateWithWhereUniqueWithoutSiteInputSchema),
          z.lazy(() => FeedUpdateWithWhereUniqueWithoutSiteInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => FeedUpdateManyWithWhereWithoutSiteInputSchema),
          z.lazy(() => FeedUpdateManyWithWhereWithoutSiteInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => FeedScalarWhereInputSchema),
          z.lazy(() => FeedScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const BlockUncheckedUpdateManyWithoutSiteNestedInputSchema: z.ZodType<Prisma.BlockUncheckedUpdateManyWithoutSiteNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BlockCreateWithoutSiteInputSchema),
          z.lazy(() => BlockCreateWithoutSiteInputSchema).array(),
          z.lazy(() => BlockUncheckedCreateWithoutSiteInputSchema),
          z.lazy(() => BlockUncheckedCreateWithoutSiteInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => BlockCreateOrConnectWithoutSiteInputSchema),
          z.lazy(() => BlockCreateOrConnectWithoutSiteInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => BlockUpsertWithWhereUniqueWithoutSiteInputSchema),
          z.lazy(() => BlockUpsertWithWhereUniqueWithoutSiteInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => BlockCreateManySiteInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => BlockWhereUniqueInputSchema),
          z.lazy(() => BlockWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => BlockWhereUniqueInputSchema),
          z.lazy(() => BlockWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => BlockWhereUniqueInputSchema),
          z.lazy(() => BlockWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => BlockWhereUniqueInputSchema),
          z.lazy(() => BlockWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => BlockUpdateWithWhereUniqueWithoutSiteInputSchema),
          z.lazy(() => BlockUpdateWithWhereUniqueWithoutSiteInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => BlockUpdateManyWithWhereWithoutSiteInputSchema),
          z.lazy(() => BlockUpdateManyWithWhereWithoutSiteInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => BlockScalarWhereInputSchema),
          z.lazy(() => BlockScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ClickUncheckedUpdateManyWithoutSiteNestedInputSchema: z.ZodType<Prisma.ClickUncheckedUpdateManyWithoutSiteNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ClickCreateWithoutSiteInputSchema),
          z.lazy(() => ClickCreateWithoutSiteInputSchema).array(),
          z.lazy(() => ClickUncheckedCreateWithoutSiteInputSchema),
          z.lazy(() => ClickUncheckedCreateWithoutSiteInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ClickCreateOrConnectWithoutSiteInputSchema),
          z.lazy(() => ClickCreateOrConnectWithoutSiteInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ClickUpsertWithWhereUniqueWithoutSiteInputSchema),
          z.lazy(() => ClickUpsertWithWhereUniqueWithoutSiteInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ClickCreateManySiteInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ClickUpdateWithWhereUniqueWithoutSiteInputSchema),
          z.lazy(() => ClickUpdateWithWhereUniqueWithoutSiteInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ClickUpdateManyWithWhereWithoutSiteInputSchema),
          z.lazy(() => ClickUpdateManyWithWhereWithoutSiteInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ClickScalarWhereInputSchema),
          z.lazy(() => ClickScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const SubscriberUncheckedUpdateManyWithoutSiteNestedInputSchema: z.ZodType<Prisma.SubscriberUncheckedUpdateManyWithoutSiteNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriberCreateWithoutSiteInputSchema),
          z.lazy(() => SubscriberCreateWithoutSiteInputSchema).array(),
          z.lazy(() => SubscriberUncheckedCreateWithoutSiteInputSchema),
          z.lazy(() => SubscriberUncheckedCreateWithoutSiteInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriberCreateOrConnectWithoutSiteInputSchema),
          z.lazy(() => SubscriberCreateOrConnectWithoutSiteInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => SubscriberUpsertWithWhereUniqueWithoutSiteInputSchema),
          z
            .lazy(() => SubscriberUpsertWithWhereUniqueWithoutSiteInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => SubscriberCreateManySiteInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => SubscriberWhereUniqueInputSchema),
          z.lazy(() => SubscriberWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => SubscriberWhereUniqueInputSchema),
          z.lazy(() => SubscriberWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => SubscriberWhereUniqueInputSchema),
          z.lazy(() => SubscriberWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => SubscriberWhereUniqueInputSchema),
          z.lazy(() => SubscriberWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => SubscriberUpdateWithWhereUniqueWithoutSiteInputSchema),
          z
            .lazy(() => SubscriberUpdateWithWhereUniqueWithoutSiteInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => SubscriberUpdateManyWithWhereWithoutSiteInputSchema),
          z
            .lazy(() => SubscriberUpdateManyWithWhereWithoutSiteInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => SubscriberScalarWhereInputSchema),
          z.lazy(() => SubscriberScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const LikeUncheckedUpdateManyWithoutSiteNestedInputSchema: z.ZodType<Prisma.LikeUncheckedUpdateManyWithoutSiteNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LikeCreateWithoutSiteInputSchema),
          z.lazy(() => LikeCreateWithoutSiteInputSchema).array(),
          z.lazy(() => LikeUncheckedCreateWithoutSiteInputSchema),
          z.lazy(() => LikeUncheckedCreateWithoutSiteInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => LikeCreateOrConnectWithoutSiteInputSchema),
          z.lazy(() => LikeCreateOrConnectWithoutSiteInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => LikeUpsertWithWhereUniqueWithoutSiteInputSchema),
          z.lazy(() => LikeUpsertWithWhereUniqueWithoutSiteInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => LikeCreateManySiteInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => LikeUpdateWithWhereUniqueWithoutSiteInputSchema),
          z.lazy(() => LikeUpdateWithWhereUniqueWithoutSiteInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => LikeUpdateManyWithWhereWithoutSiteInputSchema),
          z.lazy(() => LikeUpdateManyWithWhereWithoutSiteInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => LikeScalarWhereInputSchema),
          z.lazy(() => LikeScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const FeedUncheckedUpdateManyWithoutSiteNestedInputSchema: z.ZodType<Prisma.FeedUncheckedUpdateManyWithoutSiteNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FeedCreateWithoutSiteInputSchema),
          z.lazy(() => FeedCreateWithoutSiteInputSchema).array(),
          z.lazy(() => FeedUncheckedCreateWithoutSiteInputSchema),
          z.lazy(() => FeedUncheckedCreateWithoutSiteInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => FeedCreateOrConnectWithoutSiteInputSchema),
          z.lazy(() => FeedCreateOrConnectWithoutSiteInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => FeedUpsertWithWhereUniqueWithoutSiteInputSchema),
          z.lazy(() => FeedUpsertWithWhereUniqueWithoutSiteInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => FeedCreateManySiteInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => FeedWhereUniqueInputSchema),
          z.lazy(() => FeedWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => FeedWhereUniqueInputSchema),
          z.lazy(() => FeedWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => FeedWhereUniqueInputSchema),
          z.lazy(() => FeedWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => FeedWhereUniqueInputSchema),
          z.lazy(() => FeedWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => FeedUpdateWithWhereUniqueWithoutSiteInputSchema),
          z.lazy(() => FeedUpdateWithWhereUniqueWithoutSiteInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => FeedUpdateManyWithWhereWithoutSiteInputSchema),
          z.lazy(() => FeedUpdateManyWithWhereWithoutSiteInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => FeedScalarWhereInputSchema),
          z.lazy(() => FeedScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const SiteCreateNestedOneWithoutSubscribersInputSchema: z.ZodType<Prisma.SiteCreateNestedOneWithoutSubscribersInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SiteCreateWithoutSubscribersInputSchema),
          z.lazy(() => SiteUncheckedCreateWithoutSubscribersInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => SiteCreateOrConnectWithoutSubscribersInputSchema)
        .optional(),
      connect: z.lazy(() => SiteWhereUniqueInputSchema).optional()
    })
    .strict();

export const SiteUpdateOneRequiredWithoutSubscribersNestedInputSchema: z.ZodType<Prisma.SiteUpdateOneRequiredWithoutSubscribersNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SiteCreateWithoutSubscribersInputSchema),
          z.lazy(() => SiteUncheckedCreateWithoutSubscribersInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => SiteCreateOrConnectWithoutSubscribersInputSchema)
        .optional(),
      upsert: z.lazy(() => SiteUpsertWithoutSubscribersInputSchema).optional(),
      connect: z.lazy(() => SiteWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => SiteUpdateToOneWithWhereWithoutSubscribersInputSchema),
          z.lazy(() => SiteUpdateWithoutSubscribersInputSchema),
          z.lazy(() => SiteUncheckedUpdateWithoutSubscribersInputSchema)
        ])
        .optional()
    })
    .strict();

export const BlockCreateNestedOneWithoutReservationsInputSchema: z.ZodType<Prisma.BlockCreateNestedOneWithoutReservationsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BlockCreateWithoutReservationsInputSchema),
          z.lazy(() => BlockUncheckedCreateWithoutReservationsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => BlockCreateOrConnectWithoutReservationsInputSchema)
        .optional(),
      connect: z.lazy(() => BlockWhereUniqueInputSchema).optional()
    })
    .strict();

export const UserCreateNestedOneWithoutReservationsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutReservationsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutReservationsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutReservationsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutReservationsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const BlockUpdateOneWithoutReservationsNestedInputSchema: z.ZodType<Prisma.BlockUpdateOneWithoutReservationsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BlockCreateWithoutReservationsInputSchema),
          z.lazy(() => BlockUncheckedCreateWithoutReservationsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => BlockCreateOrConnectWithoutReservationsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => BlockUpsertWithoutReservationsInputSchema)
        .optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => BlockWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => BlockWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => BlockWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => BlockUpdateToOneWithWhereWithoutReservationsInputSchema),
          z.lazy(() => BlockUpdateWithoutReservationsInputSchema),
          z.lazy(() => BlockUncheckedUpdateWithoutReservationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserUpdateOneWithoutReservationsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneWithoutReservationsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutReservationsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutReservationsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutReservationsInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutReservationsInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutReservationsInputSchema),
          z.lazy(() => UserUpdateWithoutReservationsInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutReservationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const InventoryCreateNestedManyWithoutCategoryInputSchema: z.ZodType<Prisma.InventoryCreateNestedManyWithoutCategoryInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InventoryCreateWithoutCategoryInputSchema),
          z.lazy(() => InventoryCreateWithoutCategoryInputSchema).array(),
          z.lazy(() => InventoryUncheckedCreateWithoutCategoryInputSchema),
          z
            .lazy(() => InventoryUncheckedCreateWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => InventoryCreateOrConnectWithoutCategoryInputSchema),
          z
            .lazy(() => InventoryCreateOrConnectWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => InventoryCreateManyCategoryInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => InventoryWhereUniqueInputSchema),
          z.lazy(() => InventoryWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CategoryCreateNestedManyWithoutCategoryInputSchema: z.ZodType<Prisma.CategoryCreateNestedManyWithoutCategoryInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CategoryCreateWithoutCategoryInputSchema),
          z.lazy(() => CategoryCreateWithoutCategoryInputSchema).array(),
          z.lazy(() => CategoryUncheckedCreateWithoutCategoryInputSchema),
          z
            .lazy(() => CategoryUncheckedCreateWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CategoryCreateOrConnectWithoutCategoryInputSchema),
          z
            .lazy(() => CategoryCreateOrConnectWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CategoryCreateManyCategoryInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CategoryCreateNestedOneWithoutCategoriesInputSchema: z.ZodType<Prisma.CategoryCreateNestedOneWithoutCategoriesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CategoryCreateWithoutCategoriesInputSchema),
          z.lazy(() => CategoryUncheckedCreateWithoutCategoriesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CategoryCreateOrConnectWithoutCategoriesInputSchema)
        .optional(),
      connect: z.lazy(() => CategoryWhereUniqueInputSchema).optional()
    })
    .strict();

export const BlockCreateNestedOneWithoutCategoriesInputSchema: z.ZodType<Prisma.BlockCreateNestedOneWithoutCategoriesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BlockCreateWithoutCategoriesInputSchema),
          z.lazy(() => BlockUncheckedCreateWithoutCategoriesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => BlockCreateOrConnectWithoutCategoriesInputSchema)
        .optional(),
      connect: z.lazy(() => BlockWhereUniqueInputSchema).optional()
    })
    .strict();

export const InventoryUncheckedCreateNestedManyWithoutCategoryInputSchema: z.ZodType<Prisma.InventoryUncheckedCreateNestedManyWithoutCategoryInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InventoryCreateWithoutCategoryInputSchema),
          z.lazy(() => InventoryCreateWithoutCategoryInputSchema).array(),
          z.lazy(() => InventoryUncheckedCreateWithoutCategoryInputSchema),
          z
            .lazy(() => InventoryUncheckedCreateWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => InventoryCreateOrConnectWithoutCategoryInputSchema),
          z
            .lazy(() => InventoryCreateOrConnectWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => InventoryCreateManyCategoryInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => InventoryWhereUniqueInputSchema),
          z.lazy(() => InventoryWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CategoryUncheckedCreateNestedManyWithoutCategoryInputSchema: z.ZodType<Prisma.CategoryUncheckedCreateNestedManyWithoutCategoryInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CategoryCreateWithoutCategoryInputSchema),
          z.lazy(() => CategoryCreateWithoutCategoryInputSchema).array(),
          z.lazy(() => CategoryUncheckedCreateWithoutCategoryInputSchema),
          z
            .lazy(() => CategoryUncheckedCreateWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CategoryCreateOrConnectWithoutCategoryInputSchema),
          z
            .lazy(() => CategoryCreateOrConnectWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CategoryCreateManyCategoryInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const InventoryUpdateManyWithoutCategoryNestedInputSchema: z.ZodType<Prisma.InventoryUpdateManyWithoutCategoryNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InventoryCreateWithoutCategoryInputSchema),
          z.lazy(() => InventoryCreateWithoutCategoryInputSchema).array(),
          z.lazy(() => InventoryUncheckedCreateWithoutCategoryInputSchema),
          z
            .lazy(() => InventoryUncheckedCreateWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => InventoryCreateOrConnectWithoutCategoryInputSchema),
          z
            .lazy(() => InventoryCreateOrConnectWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => InventoryUpsertWithWhereUniqueWithoutCategoryInputSchema
          ),
          z
            .lazy(
              () => InventoryUpsertWithWhereUniqueWithoutCategoryInputSchema
            )
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => InventoryCreateManyCategoryInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => InventoryWhereUniqueInputSchema),
          z.lazy(() => InventoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => InventoryWhereUniqueInputSchema),
          z.lazy(() => InventoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => InventoryWhereUniqueInputSchema),
          z.lazy(() => InventoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => InventoryWhereUniqueInputSchema),
          z.lazy(() => InventoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => InventoryUpdateWithWhereUniqueWithoutCategoryInputSchema
          ),
          z
            .lazy(
              () => InventoryUpdateWithWhereUniqueWithoutCategoryInputSchema
            )
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => InventoryUpdateManyWithWhereWithoutCategoryInputSchema),
          z
            .lazy(() => InventoryUpdateManyWithWhereWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => InventoryScalarWhereInputSchema),
          z.lazy(() => InventoryScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CategoryUpdateManyWithoutCategoryNestedInputSchema: z.ZodType<Prisma.CategoryUpdateManyWithoutCategoryNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CategoryCreateWithoutCategoryInputSchema),
          z.lazy(() => CategoryCreateWithoutCategoryInputSchema).array(),
          z.lazy(() => CategoryUncheckedCreateWithoutCategoryInputSchema),
          z
            .lazy(() => CategoryUncheckedCreateWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CategoryCreateOrConnectWithoutCategoryInputSchema),
          z
            .lazy(() => CategoryCreateOrConnectWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CategoryUpsertWithWhereUniqueWithoutCategoryInputSchema),
          z
            .lazy(() => CategoryUpsertWithWhereUniqueWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CategoryCreateManyCategoryInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CategoryUpdateWithWhereUniqueWithoutCategoryInputSchema),
          z
            .lazy(() => CategoryUpdateWithWhereUniqueWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CategoryUpdateManyWithWhereWithoutCategoryInputSchema),
          z
            .lazy(() => CategoryUpdateManyWithWhereWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CategoryScalarWhereInputSchema),
          z.lazy(() => CategoryScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CategoryUpdateOneWithoutCategoriesNestedInputSchema: z.ZodType<Prisma.CategoryUpdateOneWithoutCategoriesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CategoryCreateWithoutCategoriesInputSchema),
          z.lazy(() => CategoryUncheckedCreateWithoutCategoriesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CategoryCreateOrConnectWithoutCategoriesInputSchema)
        .optional(),
      upsert: z
        .lazy(() => CategoryUpsertWithoutCategoriesInputSchema)
        .optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => CategoryWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => CategoryWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => CategoryWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => CategoryUpdateToOneWithWhereWithoutCategoriesInputSchema
          ),
          z.lazy(() => CategoryUpdateWithoutCategoriesInputSchema),
          z.lazy(() => CategoryUncheckedUpdateWithoutCategoriesInputSchema)
        ])
        .optional()
    })
    .strict();

export const BlockUpdateOneRequiredWithoutCategoriesNestedInputSchema: z.ZodType<Prisma.BlockUpdateOneRequiredWithoutCategoriesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BlockCreateWithoutCategoriesInputSchema),
          z.lazy(() => BlockUncheckedCreateWithoutCategoriesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => BlockCreateOrConnectWithoutCategoriesInputSchema)
        .optional(),
      upsert: z.lazy(() => BlockUpsertWithoutCategoriesInputSchema).optional(),
      connect: z.lazy(() => BlockWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => BlockUpdateToOneWithWhereWithoutCategoriesInputSchema),
          z.lazy(() => BlockUpdateWithoutCategoriesInputSchema),
          z.lazy(() => BlockUncheckedUpdateWithoutCategoriesInputSchema)
        ])
        .optional()
    })
    .strict();

export const InventoryUncheckedUpdateManyWithoutCategoryNestedInputSchema: z.ZodType<Prisma.InventoryUncheckedUpdateManyWithoutCategoryNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InventoryCreateWithoutCategoryInputSchema),
          z.lazy(() => InventoryCreateWithoutCategoryInputSchema).array(),
          z.lazy(() => InventoryUncheckedCreateWithoutCategoryInputSchema),
          z
            .lazy(() => InventoryUncheckedCreateWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => InventoryCreateOrConnectWithoutCategoryInputSchema),
          z
            .lazy(() => InventoryCreateOrConnectWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => InventoryUpsertWithWhereUniqueWithoutCategoryInputSchema
          ),
          z
            .lazy(
              () => InventoryUpsertWithWhereUniqueWithoutCategoryInputSchema
            )
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => InventoryCreateManyCategoryInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => InventoryWhereUniqueInputSchema),
          z.lazy(() => InventoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => InventoryWhereUniqueInputSchema),
          z.lazy(() => InventoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => InventoryWhereUniqueInputSchema),
          z.lazy(() => InventoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => InventoryWhereUniqueInputSchema),
          z.lazy(() => InventoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => InventoryUpdateWithWhereUniqueWithoutCategoryInputSchema
          ),
          z
            .lazy(
              () => InventoryUpdateWithWhereUniqueWithoutCategoryInputSchema
            )
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => InventoryUpdateManyWithWhereWithoutCategoryInputSchema),
          z
            .lazy(() => InventoryUpdateManyWithWhereWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => InventoryScalarWhereInputSchema),
          z.lazy(() => InventoryScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CategoryUncheckedUpdateManyWithoutCategoryNestedInputSchema: z.ZodType<Prisma.CategoryUncheckedUpdateManyWithoutCategoryNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CategoryCreateWithoutCategoryInputSchema),
          z.lazy(() => CategoryCreateWithoutCategoryInputSchema).array(),
          z.lazy(() => CategoryUncheckedCreateWithoutCategoryInputSchema),
          z
            .lazy(() => CategoryUncheckedCreateWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CategoryCreateOrConnectWithoutCategoryInputSchema),
          z
            .lazy(() => CategoryCreateOrConnectWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CategoryUpsertWithWhereUniqueWithoutCategoryInputSchema),
          z
            .lazy(() => CategoryUpsertWithWhereUniqueWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CategoryCreateManyCategoryInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CategoryWhereUniqueInputSchema),
          z.lazy(() => CategoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CategoryUpdateWithWhereUniqueWithoutCategoryInputSchema),
          z
            .lazy(() => CategoryUpdateWithWhereUniqueWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CategoryUpdateManyWithWhereWithoutCategoryInputSchema),
          z
            .lazy(() => CategoryUpdateManyWithWhereWithoutCategoryInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CategoryScalarWhereInputSchema),
          z.lazy(() => CategoryScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const InventoryCreatetagsInputSchema: z.ZodType<Prisma.InventoryCreatetagsInput> =
  z
    .object({
      set: z.string().array()
    })
    .strict();

export const CategoryCreateNestedOneWithoutInventoriesInputSchema: z.ZodType<Prisma.CategoryCreateNestedOneWithoutInventoriesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CategoryCreateWithoutInventoriesInputSchema),
          z.lazy(() => CategoryUncheckedCreateWithoutInventoriesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CategoryCreateOrConnectWithoutInventoriesInputSchema)
        .optional(),
      connect: z.lazy(() => CategoryWhereUniqueInputSchema).optional()
    })
    .strict();

export const InventoryVariantCreateNestedManyWithoutInventoryInputSchema: z.ZodType<Prisma.InventoryVariantCreateNestedManyWithoutInventoryInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InventoryVariantCreateWithoutInventoryInputSchema),
          z
            .lazy(() => InventoryVariantCreateWithoutInventoryInputSchema)
            .array(),
          z.lazy(
            () => InventoryVariantUncheckedCreateWithoutInventoryInputSchema
          ),
          z
            .lazy(
              () => InventoryVariantUncheckedCreateWithoutInventoryInputSchema
            )
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => InventoryVariantCreateOrConnectWithoutInventoryInputSchema
          ),
          z
            .lazy(
              () => InventoryVariantCreateOrConnectWithoutInventoryInputSchema
            )
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => InventoryVariantCreateManyInventoryInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => InventoryVariantWhereUniqueInputSchema),
          z.lazy(() => InventoryVariantWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const BlockCreateNestedOneWithoutInventoriesInputSchema: z.ZodType<Prisma.BlockCreateNestedOneWithoutInventoriesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BlockCreateWithoutInventoriesInputSchema),
          z.lazy(() => BlockUncheckedCreateWithoutInventoriesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => BlockCreateOrConnectWithoutInventoriesInputSchema)
        .optional(),
      connect: z.lazy(() => BlockWhereUniqueInputSchema).optional()
    })
    .strict();

export const InventoryVariantUncheckedCreateNestedManyWithoutInventoryInputSchema: z.ZodType<Prisma.InventoryVariantUncheckedCreateNestedManyWithoutInventoryInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InventoryVariantCreateWithoutInventoryInputSchema),
          z
            .lazy(() => InventoryVariantCreateWithoutInventoryInputSchema)
            .array(),
          z.lazy(
            () => InventoryVariantUncheckedCreateWithoutInventoryInputSchema
          ),
          z
            .lazy(
              () => InventoryVariantUncheckedCreateWithoutInventoryInputSchema
            )
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => InventoryVariantCreateOrConnectWithoutInventoryInputSchema
          ),
          z
            .lazy(
              () => InventoryVariantCreateOrConnectWithoutInventoryInputSchema
            )
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => InventoryVariantCreateManyInventoryInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => InventoryVariantWhereUniqueInputSchema),
          z.lazy(() => InventoryVariantWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const FloatFieldUpdateOperationsInputSchema: z.ZodType<Prisma.FloatFieldUpdateOperationsInput> =
  z
    .object({
      set: z.number().optional(),
      increment: z.number().optional(),
      decrement: z.number().optional(),
      multiply: z.number().optional(),
      divide: z.number().optional()
    })
    .strict();

export const InventoryUpdatetagsInputSchema: z.ZodType<Prisma.InventoryUpdatetagsInput> =
  z
    .object({
      set: z.string().array().optional(),
      push: z.union([z.string(), z.string().array()]).optional()
    })
    .strict();

export const CategoryUpdateOneWithoutInventoriesNestedInputSchema: z.ZodType<Prisma.CategoryUpdateOneWithoutInventoriesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CategoryCreateWithoutInventoriesInputSchema),
          z.lazy(() => CategoryUncheckedCreateWithoutInventoriesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CategoryCreateOrConnectWithoutInventoriesInputSchema)
        .optional(),
      upsert: z
        .lazy(() => CategoryUpsertWithoutInventoriesInputSchema)
        .optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => CategoryWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => CategoryWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => CategoryWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => CategoryUpdateToOneWithWhereWithoutInventoriesInputSchema
          ),
          z.lazy(() => CategoryUpdateWithoutInventoriesInputSchema),
          z.lazy(() => CategoryUncheckedUpdateWithoutInventoriesInputSchema)
        ])
        .optional()
    })
    .strict();

export const InventoryVariantUpdateManyWithoutInventoryNestedInputSchema: z.ZodType<Prisma.InventoryVariantUpdateManyWithoutInventoryNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InventoryVariantCreateWithoutInventoryInputSchema),
          z
            .lazy(() => InventoryVariantCreateWithoutInventoryInputSchema)
            .array(),
          z.lazy(
            () => InventoryVariantUncheckedCreateWithoutInventoryInputSchema
          ),
          z
            .lazy(
              () => InventoryVariantUncheckedCreateWithoutInventoryInputSchema
            )
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => InventoryVariantCreateOrConnectWithoutInventoryInputSchema
          ),
          z
            .lazy(
              () => InventoryVariantCreateOrConnectWithoutInventoryInputSchema
            )
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              InventoryVariantUpsertWithWhereUniqueWithoutInventoryInputSchema
          ),
          z
            .lazy(
              () =>
                InventoryVariantUpsertWithWhereUniqueWithoutInventoryInputSchema
            )
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => InventoryVariantCreateManyInventoryInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => InventoryVariantWhereUniqueInputSchema),
          z.lazy(() => InventoryVariantWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => InventoryVariantWhereUniqueInputSchema),
          z.lazy(() => InventoryVariantWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => InventoryVariantWhereUniqueInputSchema),
          z.lazy(() => InventoryVariantWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => InventoryVariantWhereUniqueInputSchema),
          z.lazy(() => InventoryVariantWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              InventoryVariantUpdateWithWhereUniqueWithoutInventoryInputSchema
          ),
          z
            .lazy(
              () =>
                InventoryVariantUpdateWithWhereUniqueWithoutInventoryInputSchema
            )
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => InventoryVariantUpdateManyWithWhereWithoutInventoryInputSchema
          ),
          z
            .lazy(
              () =>
                InventoryVariantUpdateManyWithWhereWithoutInventoryInputSchema
            )
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => InventoryVariantScalarWhereInputSchema),
          z.lazy(() => InventoryVariantScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const BlockUpdateOneRequiredWithoutInventoriesNestedInputSchema: z.ZodType<Prisma.BlockUpdateOneRequiredWithoutInventoriesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BlockCreateWithoutInventoriesInputSchema),
          z.lazy(() => BlockUncheckedCreateWithoutInventoriesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => BlockCreateOrConnectWithoutInventoriesInputSchema)
        .optional(),
      upsert: z.lazy(() => BlockUpsertWithoutInventoriesInputSchema).optional(),
      connect: z.lazy(() => BlockWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => BlockUpdateToOneWithWhereWithoutInventoriesInputSchema),
          z.lazy(() => BlockUpdateWithoutInventoriesInputSchema),
          z.lazy(() => BlockUncheckedUpdateWithoutInventoriesInputSchema)
        ])
        .optional()
    })
    .strict();

export const InventoryVariantUncheckedUpdateManyWithoutInventoryNestedInputSchema: z.ZodType<Prisma.InventoryVariantUncheckedUpdateManyWithoutInventoryNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InventoryVariantCreateWithoutInventoryInputSchema),
          z
            .lazy(() => InventoryVariantCreateWithoutInventoryInputSchema)
            .array(),
          z.lazy(
            () => InventoryVariantUncheckedCreateWithoutInventoryInputSchema
          ),
          z
            .lazy(
              () => InventoryVariantUncheckedCreateWithoutInventoryInputSchema
            )
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => InventoryVariantCreateOrConnectWithoutInventoryInputSchema
          ),
          z
            .lazy(
              () => InventoryVariantCreateOrConnectWithoutInventoryInputSchema
            )
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              InventoryVariantUpsertWithWhereUniqueWithoutInventoryInputSchema
          ),
          z
            .lazy(
              () =>
                InventoryVariantUpsertWithWhereUniqueWithoutInventoryInputSchema
            )
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => InventoryVariantCreateManyInventoryInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => InventoryVariantWhereUniqueInputSchema),
          z.lazy(() => InventoryVariantWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => InventoryVariantWhereUniqueInputSchema),
          z.lazy(() => InventoryVariantWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => InventoryVariantWhereUniqueInputSchema),
          z.lazy(() => InventoryVariantWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => InventoryVariantWhereUniqueInputSchema),
          z.lazy(() => InventoryVariantWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              InventoryVariantUpdateWithWhereUniqueWithoutInventoryInputSchema
          ),
          z
            .lazy(
              () =>
                InventoryVariantUpdateWithWhereUniqueWithoutInventoryInputSchema
            )
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => InventoryVariantUpdateManyWithWhereWithoutInventoryInputSchema
          ),
          z
            .lazy(
              () =>
                InventoryVariantUpdateManyWithWhereWithoutInventoryInputSchema
            )
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => InventoryVariantScalarWhereInputSchema),
          z.lazy(() => InventoryVariantScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const InventoryCreateNestedOneWithoutVariantsInputSchema: z.ZodType<Prisma.InventoryCreateNestedOneWithoutVariantsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InventoryCreateWithoutVariantsInputSchema),
          z.lazy(() => InventoryUncheckedCreateWithoutVariantsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => InventoryCreateOrConnectWithoutVariantsInputSchema)
        .optional(),
      connect: z.lazy(() => InventoryWhereUniqueInputSchema).optional()
    })
    .strict();

export const EnumVariantTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumVariantTypeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => VariantTypeSchema).optional()
    })
    .strict();

export const NullableDecimalFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableDecimalFieldUpdateOperationsInput> =
  z
    .object({
      set: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional()
        .nullable(),
      increment: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      decrement: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      multiply: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      divide: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional()
    })
    .strict();

export const InventoryUpdateOneRequiredWithoutVariantsNestedInputSchema: z.ZodType<Prisma.InventoryUpdateOneRequiredWithoutVariantsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InventoryCreateWithoutVariantsInputSchema),
          z.lazy(() => InventoryUncheckedCreateWithoutVariantsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => InventoryCreateOrConnectWithoutVariantsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => InventoryUpsertWithoutVariantsInputSchema)
        .optional(),
      connect: z.lazy(() => InventoryWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => InventoryUpdateToOneWithWhereWithoutVariantsInputSchema),
          z.lazy(() => InventoryUpdateWithoutVariantsInputSchema),
          z.lazy(() => InventoryUncheckedUpdateWithoutVariantsInputSchema)
        ])
        .optional()
    })
    .strict();

export const HistoryCreateNestedManyWithoutCronInputSchema: z.ZodType<Prisma.HistoryCreateNestedManyWithoutCronInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => HistoryCreateWithoutCronInputSchema),
          z.lazy(() => HistoryCreateWithoutCronInputSchema).array(),
          z.lazy(() => HistoryUncheckedCreateWithoutCronInputSchema),
          z.lazy(() => HistoryUncheckedCreateWithoutCronInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => HistoryCreateOrConnectWithoutCronInputSchema),
          z.lazy(() => HistoryCreateOrConnectWithoutCronInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => HistoryCreateManyCronInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => HistoryWhereUniqueInputSchema),
          z.lazy(() => HistoryWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const HistoryUncheckedCreateNestedManyWithoutCronInputSchema: z.ZodType<Prisma.HistoryUncheckedCreateNestedManyWithoutCronInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => HistoryCreateWithoutCronInputSchema),
          z.lazy(() => HistoryCreateWithoutCronInputSchema).array(),
          z.lazy(() => HistoryUncheckedCreateWithoutCronInputSchema),
          z.lazy(() => HistoryUncheckedCreateWithoutCronInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => HistoryCreateOrConnectWithoutCronInputSchema),
          z.lazy(() => HistoryCreateOrConnectWithoutCronInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => HistoryCreateManyCronInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => HistoryWhereUniqueInputSchema),
          z.lazy(() => HistoryWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const HistoryUpdateManyWithoutCronNestedInputSchema: z.ZodType<Prisma.HistoryUpdateManyWithoutCronNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => HistoryCreateWithoutCronInputSchema),
          z.lazy(() => HistoryCreateWithoutCronInputSchema).array(),
          z.lazy(() => HistoryUncheckedCreateWithoutCronInputSchema),
          z.lazy(() => HistoryUncheckedCreateWithoutCronInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => HistoryCreateOrConnectWithoutCronInputSchema),
          z.lazy(() => HistoryCreateOrConnectWithoutCronInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => HistoryUpsertWithWhereUniqueWithoutCronInputSchema),
          z
            .lazy(() => HistoryUpsertWithWhereUniqueWithoutCronInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => HistoryCreateManyCronInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => HistoryWhereUniqueInputSchema),
          z.lazy(() => HistoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => HistoryWhereUniqueInputSchema),
          z.lazy(() => HistoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => HistoryWhereUniqueInputSchema),
          z.lazy(() => HistoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => HistoryWhereUniqueInputSchema),
          z.lazy(() => HistoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => HistoryUpdateWithWhereUniqueWithoutCronInputSchema),
          z
            .lazy(() => HistoryUpdateWithWhereUniqueWithoutCronInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => HistoryUpdateManyWithWhereWithoutCronInputSchema),
          z.lazy(() => HistoryUpdateManyWithWhereWithoutCronInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => HistoryScalarWhereInputSchema),
          z.lazy(() => HistoryScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const HistoryUncheckedUpdateManyWithoutCronNestedInputSchema: z.ZodType<Prisma.HistoryUncheckedUpdateManyWithoutCronNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => HistoryCreateWithoutCronInputSchema),
          z.lazy(() => HistoryCreateWithoutCronInputSchema).array(),
          z.lazy(() => HistoryUncheckedCreateWithoutCronInputSchema),
          z.lazy(() => HistoryUncheckedCreateWithoutCronInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => HistoryCreateOrConnectWithoutCronInputSchema),
          z.lazy(() => HistoryCreateOrConnectWithoutCronInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => HistoryUpsertWithWhereUniqueWithoutCronInputSchema),
          z
            .lazy(() => HistoryUpsertWithWhereUniqueWithoutCronInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => HistoryCreateManyCronInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => HistoryWhereUniqueInputSchema),
          z.lazy(() => HistoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => HistoryWhereUniqueInputSchema),
          z.lazy(() => HistoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => HistoryWhereUniqueInputSchema),
          z.lazy(() => HistoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => HistoryWhereUniqueInputSchema),
          z.lazy(() => HistoryWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => HistoryUpdateWithWhereUniqueWithoutCronInputSchema),
          z
            .lazy(() => HistoryUpdateWithWhereUniqueWithoutCronInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => HistoryUpdateManyWithWhereWithoutCronInputSchema),
          z.lazy(() => HistoryUpdateManyWithWhereWithoutCronInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => HistoryScalarWhereInputSchema),
          z.lazy(() => HistoryScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CronCreateNestedOneWithoutHistoryInputSchema: z.ZodType<Prisma.CronCreateNestedOneWithoutHistoryInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CronCreateWithoutHistoryInputSchema),
          z.lazy(() => CronUncheckedCreateWithoutHistoryInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CronCreateOrConnectWithoutHistoryInputSchema)
        .optional(),
      connect: z.lazy(() => CronWhereUniqueInputSchema).optional()
    })
    .strict();

export const CronUpdateOneRequiredWithoutHistoryNestedInputSchema: z.ZodType<Prisma.CronUpdateOneRequiredWithoutHistoryNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CronCreateWithoutHistoryInputSchema),
          z.lazy(() => CronUncheckedCreateWithoutHistoryInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CronCreateOrConnectWithoutHistoryInputSchema)
        .optional(),
      upsert: z.lazy(() => CronUpsertWithoutHistoryInputSchema).optional(),
      connect: z.lazy(() => CronWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => CronUpdateToOneWithWhereWithoutHistoryInputSchema),
          z.lazy(() => CronUpdateWithoutHistoryInputSchema),
          z.lazy(() => CronUncheckedUpdateWithoutHistoryInputSchema)
        ])
        .optional()
    })
    .strict();

export const AccountCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.AccountCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountCreateWithoutUserInputSchema),
          z.lazy(() => AccountCreateWithoutUserInputSchema).array(),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => AccountCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const SessionCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.SessionCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SessionCreateWithoutUserInputSchema),
          z.lazy(() => SessionCreateWithoutUserInputSchema).array(),
          z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => SessionCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => SessionWhereUniqueInputSchema),
          z.lazy(() => SessionWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const SiteCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.SiteCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SiteCreateWithoutUserInputSchema),
          z.lazy(() => SiteCreateWithoutUserInputSchema).array(),
          z.lazy(() => SiteUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => SiteUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SiteCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => SiteCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => SiteCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => SiteWhereUniqueInputSchema),
          z.lazy(() => SiteWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const SubscriptionCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.SubscriptionCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutUserInputSchema),
          z.lazy(() => SubscriptionCreateWithoutUserInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => SubscriptionUncheckedCreateWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => SubscriptionCreateOrConnectWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => SubscriptionCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const AuthenticatorCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.AuthenticatorCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AuthenticatorCreateWithoutUserInputSchema),
          z.lazy(() => AuthenticatorCreateWithoutUserInputSchema).array(),
          z.lazy(() => AuthenticatorUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => AuthenticatorUncheckedCreateWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AuthenticatorCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => AuthenticatorCreateOrConnectWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => AuthenticatorCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => AuthenticatorWhereUniqueInputSchema),
          z.lazy(() => AuthenticatorWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const LinkCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.LinkCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LinkCreateWithoutUserInputSchema),
          z.lazy(() => LinkCreateWithoutUserInputSchema).array(),
          z.lazy(() => LinkUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => LinkUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => LinkCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => LinkCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => LinkCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => LinkWhereUniqueInputSchema),
          z.lazy(() => LinkWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CustomerCreateNestedOneWithoutUserInputSchema: z.ZodType<Prisma.CustomerCreateNestedOneWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CustomerCreateWithoutUserInputSchema),
          z.lazy(() => CustomerUncheckedCreateWithoutUserInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CustomerCreateOrConnectWithoutUserInputSchema)
        .optional(),
      connect: z.lazy(() => CustomerWhereUniqueInputSchema).optional()
    })
    .strict();

export const TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema: z.ZodType<Prisma.TwoFactorConfirmationCreateNestedOneWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TwoFactorConfirmationCreateWithoutUserInputSchema),
          z.lazy(
            () => TwoFactorConfirmationUncheckedCreateWithoutUserInputSchema
          )
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => TwoFactorConfirmationCreateOrConnectWithoutUserInputSchema)
        .optional(),
      connect: z
        .lazy(() => TwoFactorConfirmationWhereUniqueInputSchema)
        .optional()
    })
    .strict();

export const UserCreateNestedOneWithoutAffiliatesInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutAffiliatesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutAffiliatesInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutAffiliatesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutAffiliatesInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const NafCodeCreateNestedOneWithoutUsersInputSchema: z.ZodType<Prisma.NafCodeCreateNestedOneWithoutUsersInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafCodeCreateWithoutUsersInputSchema),
          z.lazy(() => NafCodeUncheckedCreateWithoutUsersInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => NafCodeCreateOrConnectWithoutUsersInputSchema)
        .optional(),
      connect: z.lazy(() => NafCodeWhereUniqueInputSchema).optional()
    })
    .strict();

export const FeedbackCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.FeedbackCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FeedbackCreateWithoutUserInputSchema),
          z.lazy(() => FeedbackCreateWithoutUserInputSchema).array(),
          z.lazy(() => FeedbackUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => FeedbackUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => FeedbackCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => FeedbackCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => FeedbackCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => FeedbackWhereUniqueInputSchema),
          z.lazy(() => FeedbackWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const LikeCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.LikeCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LikeCreateWithoutUserInputSchema),
          z.lazy(() => LikeCreateWithoutUserInputSchema).array(),
          z.lazy(() => LikeUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => LikeUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => LikeCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => LikeCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => LikeCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const UserCreateNestedManyWithoutRefererInputSchema: z.ZodType<Prisma.UserCreateNestedManyWithoutRefererInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutRefererInputSchema),
          z.lazy(() => UserCreateWithoutRefererInputSchema).array(),
          z.lazy(() => UserUncheckedCreateWithoutRefererInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutRefererInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserCreateOrConnectWithoutRefererInputSchema),
          z.lazy(() => UserCreateOrConnectWithoutRefererInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => UserCreateManyRefererInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const EventCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.EventCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => EventCreateWithoutUserInputSchema),
          z.lazy(() => EventCreateWithoutUserInputSchema).array(),
          z.lazy(() => EventUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => EventUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => EventCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => EventCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => EventCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => EventWhereUniqueInputSchema),
          z.lazy(() => EventWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const WorkflowStateCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.WorkflowStateCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => WorkflowStateCreateWithoutUserInputSchema),
          z.lazy(() => WorkflowStateCreateWithoutUserInputSchema).array(),
          z.lazy(() => WorkflowStateUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => WorkflowStateUncheckedCreateWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => WorkflowStateCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => WorkflowStateCreateOrConnectWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => WorkflowStateCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => WorkflowStateWhereUniqueInputSchema),
          z.lazy(() => WorkflowStateWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ExecutionCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.ExecutionCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ExecutionCreateWithoutUserInputSchema),
          z.lazy(() => ExecutionCreateWithoutUserInputSchema).array(),
          z.lazy(() => ExecutionUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => ExecutionUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ExecutionCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => ExecutionCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ExecutionCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const QueueCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.QueueCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => QueueCreateWithoutUserInputSchema),
          z.lazy(() => QueueCreateWithoutUserInputSchema).array(),
          z.lazy(() => QueueUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => QueueUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => QueueCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => QueueCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => QueueCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => QueueWhereUniqueInputSchema),
          z.lazy(() => QueueWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const OutboxCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.OutboxCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OutboxCreateWithoutUserInputSchema),
          z.lazy(() => OutboxCreateWithoutUserInputSchema).array(),
          z.lazy(() => OutboxUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => OutboxUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OutboxCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => OutboxCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => OutboxCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OutboxWhereUniqueInputSchema),
          z.lazy(() => OutboxWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const FeedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.FeedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FeedCreateWithoutUserInputSchema),
          z.lazy(() => FeedCreateWithoutUserInputSchema).array(),
          z.lazy(() => FeedUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => FeedUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => FeedCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => FeedCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => FeedCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => FeedWhereUniqueInputSchema),
          z.lazy(() => FeedWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CommentCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.CommentCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CommentCreateWithoutUserInputSchema),
          z.lazy(() => CommentCreateWithoutUserInputSchema).array(),
          z.lazy(() => CommentUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => CommentUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CommentCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => CommentCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CommentCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CommentWhereUniqueInputSchema),
          z.lazy(() => CommentWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const MessageCreateNestedManyWithoutSenderInputSchema: z.ZodType<Prisma.MessageCreateNestedManyWithoutSenderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => MessageCreateWithoutSenderInputSchema),
          z.lazy(() => MessageCreateWithoutSenderInputSchema).array(),
          z.lazy(() => MessageUncheckedCreateWithoutSenderInputSchema),
          z.lazy(() => MessageUncheckedCreateWithoutSenderInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => MessageCreateOrConnectWithoutSenderInputSchema),
          z.lazy(() => MessageCreateOrConnectWithoutSenderInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => MessageCreateManySenderInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => MessageWhereUniqueInputSchema),
          z.lazy(() => MessageWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const MessageCreateNestedManyWithoutReceiverInputSchema: z.ZodType<Prisma.MessageCreateNestedManyWithoutReceiverInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => MessageCreateWithoutReceiverInputSchema),
          z.lazy(() => MessageCreateWithoutReceiverInputSchema).array(),
          z.lazy(() => MessageUncheckedCreateWithoutReceiverInputSchema),
          z.lazy(() => MessageUncheckedCreateWithoutReceiverInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => MessageCreateOrConnectWithoutReceiverInputSchema),
          z.lazy(() => MessageCreateOrConnectWithoutReceiverInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => MessageCreateManyReceiverInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => MessageWhereUniqueInputSchema),
          z.lazy(() => MessageWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ReservationCreateNestedManyWithoutAffiliateInputSchema: z.ZodType<Prisma.ReservationCreateNestedManyWithoutAffiliateInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ReservationCreateWithoutAffiliateInputSchema),
          z.lazy(() => ReservationCreateWithoutAffiliateInputSchema).array(),
          z.lazy(() => ReservationUncheckedCreateWithoutAffiliateInputSchema),
          z
            .lazy(() => ReservationUncheckedCreateWithoutAffiliateInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ReservationCreateOrConnectWithoutAffiliateInputSchema),
          z
            .lazy(() => ReservationCreateOrConnectWithoutAffiliateInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ReservationCreateManyAffiliateInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ReservationWhereUniqueInputSchema),
          z.lazy(() => ReservationWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ListCreateNestedManyWithoutContactsInputSchema: z.ZodType<Prisma.ListCreateNestedManyWithoutContactsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ListCreateWithoutContactsInputSchema),
          z.lazy(() => ListCreateWithoutContactsInputSchema).array(),
          z.lazy(() => ListUncheckedCreateWithoutContactsInputSchema),
          z.lazy(() => ListUncheckedCreateWithoutContactsInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ListCreateOrConnectWithoutContactsInputSchema),
          z.lazy(() => ListCreateOrConnectWithoutContactsInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ListWhereUniqueInputSchema),
          z.lazy(() => ListWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ListCreateNestedManyWithoutOwnersInputSchema: z.ZodType<Prisma.ListCreateNestedManyWithoutOwnersInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ListCreateWithoutOwnersInputSchema),
          z.lazy(() => ListCreateWithoutOwnersInputSchema).array(),
          z.lazy(() => ListUncheckedCreateWithoutOwnersInputSchema),
          z.lazy(() => ListUncheckedCreateWithoutOwnersInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ListCreateOrConnectWithoutOwnersInputSchema),
          z.lazy(() => ListCreateOrConnectWithoutOwnersInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ListWhereUniqueInputSchema),
          z.lazy(() => ListWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const EmailCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.EmailCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => EmailCreateWithoutUserInputSchema),
          z.lazy(() => EmailCreateWithoutUserInputSchema).array(),
          z.lazy(() => EmailUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => EmailUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => EmailCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => EmailCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => EmailCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => EmailWhereUniqueInputSchema),
          z.lazy(() => EmailWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ClickCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.ClickCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ClickCreateWithoutUserInputSchema),
          z.lazy(() => ClickCreateWithoutUserInputSchema).array(),
          z.lazy(() => ClickUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => ClickUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ClickCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => ClickCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ClickCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ClickCreateNestedManyWithoutRefererInputSchema: z.ZodType<Prisma.ClickCreateNestedManyWithoutRefererInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ClickCreateWithoutRefererInputSchema),
          z.lazy(() => ClickCreateWithoutRefererInputSchema).array(),
          z.lazy(() => ClickUncheckedCreateWithoutRefererInputSchema),
          z.lazy(() => ClickUncheckedCreateWithoutRefererInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ClickCreateOrConnectWithoutRefererInputSchema),
          z.lazy(() => ClickCreateOrConnectWithoutRefererInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ClickCreateManyRefererInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const AccountUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.AccountUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountCreateWithoutUserInputSchema),
          z.lazy(() => AccountCreateWithoutUserInputSchema).array(),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => AccountCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const SessionUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.SessionUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SessionCreateWithoutUserInputSchema),
          z.lazy(() => SessionCreateWithoutUserInputSchema).array(),
          z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => SessionCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => SessionWhereUniqueInputSchema),
          z.lazy(() => SessionWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const SiteUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.SiteUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SiteCreateWithoutUserInputSchema),
          z.lazy(() => SiteCreateWithoutUserInputSchema).array(),
          z.lazy(() => SiteUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => SiteUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SiteCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => SiteCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => SiteCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => SiteWhereUniqueInputSchema),
          z.lazy(() => SiteWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.SubscriptionUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutUserInputSchema),
          z.lazy(() => SubscriptionCreateWithoutUserInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => SubscriptionUncheckedCreateWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => SubscriptionCreateOrConnectWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => SubscriptionCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.AuthenticatorUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AuthenticatorCreateWithoutUserInputSchema),
          z.lazy(() => AuthenticatorCreateWithoutUserInputSchema).array(),
          z.lazy(() => AuthenticatorUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => AuthenticatorUncheckedCreateWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AuthenticatorCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => AuthenticatorCreateOrConnectWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => AuthenticatorCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => AuthenticatorWhereUniqueInputSchema),
          z.lazy(() => AuthenticatorWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const LinkUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.LinkUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LinkCreateWithoutUserInputSchema),
          z.lazy(() => LinkCreateWithoutUserInputSchema).array(),
          z.lazy(() => LinkUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => LinkUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => LinkCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => LinkCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => LinkCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => LinkWhereUniqueInputSchema),
          z.lazy(() => LinkWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CustomerUncheckedCreateNestedOneWithoutUserInputSchema: z.ZodType<Prisma.CustomerUncheckedCreateNestedOneWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CustomerCreateWithoutUserInputSchema),
          z.lazy(() => CustomerUncheckedCreateWithoutUserInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CustomerCreateOrConnectWithoutUserInputSchema)
        .optional(),
      connect: z.lazy(() => CustomerWhereUniqueInputSchema).optional()
    })
    .strict();

export const TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema: z.ZodType<Prisma.TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TwoFactorConfirmationCreateWithoutUserInputSchema),
          z.lazy(
            () => TwoFactorConfirmationUncheckedCreateWithoutUserInputSchema
          )
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => TwoFactorConfirmationCreateOrConnectWithoutUserInputSchema)
        .optional(),
      connect: z
        .lazy(() => TwoFactorConfirmationWhereUniqueInputSchema)
        .optional()
    })
    .strict();

export const FeedbackUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.FeedbackUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FeedbackCreateWithoutUserInputSchema),
          z.lazy(() => FeedbackCreateWithoutUserInputSchema).array(),
          z.lazy(() => FeedbackUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => FeedbackUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => FeedbackCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => FeedbackCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => FeedbackCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => FeedbackWhereUniqueInputSchema),
          z.lazy(() => FeedbackWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const LikeUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.LikeUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LikeCreateWithoutUserInputSchema),
          z.lazy(() => LikeCreateWithoutUserInputSchema).array(),
          z.lazy(() => LikeUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => LikeUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => LikeCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => LikeCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => LikeCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const UserUncheckedCreateNestedManyWithoutRefererInputSchema: z.ZodType<Prisma.UserUncheckedCreateNestedManyWithoutRefererInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutRefererInputSchema),
          z.lazy(() => UserCreateWithoutRefererInputSchema).array(),
          z.lazy(() => UserUncheckedCreateWithoutRefererInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutRefererInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserCreateOrConnectWithoutRefererInputSchema),
          z.lazy(() => UserCreateOrConnectWithoutRefererInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => UserCreateManyRefererInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const EventUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.EventUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => EventCreateWithoutUserInputSchema),
          z.lazy(() => EventCreateWithoutUserInputSchema).array(),
          z.lazy(() => EventUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => EventUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => EventCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => EventCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => EventCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => EventWhereUniqueInputSchema),
          z.lazy(() => EventWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.WorkflowStateUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => WorkflowStateCreateWithoutUserInputSchema),
          z.lazy(() => WorkflowStateCreateWithoutUserInputSchema).array(),
          z.lazy(() => WorkflowStateUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => WorkflowStateUncheckedCreateWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => WorkflowStateCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => WorkflowStateCreateOrConnectWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => WorkflowStateCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => WorkflowStateWhereUniqueInputSchema),
          z.lazy(() => WorkflowStateWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ExecutionUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.ExecutionUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ExecutionCreateWithoutUserInputSchema),
          z.lazy(() => ExecutionCreateWithoutUserInputSchema).array(),
          z.lazy(() => ExecutionUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => ExecutionUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ExecutionCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => ExecutionCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ExecutionCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const QueueUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.QueueUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => QueueCreateWithoutUserInputSchema),
          z.lazy(() => QueueCreateWithoutUserInputSchema).array(),
          z.lazy(() => QueueUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => QueueUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => QueueCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => QueueCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => QueueCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => QueueWhereUniqueInputSchema),
          z.lazy(() => QueueWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const OutboxUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.OutboxUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OutboxCreateWithoutUserInputSchema),
          z.lazy(() => OutboxCreateWithoutUserInputSchema).array(),
          z.lazy(() => OutboxUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => OutboxUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OutboxCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => OutboxCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => OutboxCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OutboxWhereUniqueInputSchema),
          z.lazy(() => OutboxWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const FeedUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.FeedUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FeedCreateWithoutUserInputSchema),
          z.lazy(() => FeedCreateWithoutUserInputSchema).array(),
          z.lazy(() => FeedUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => FeedUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => FeedCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => FeedCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => FeedCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => FeedWhereUniqueInputSchema),
          z.lazy(() => FeedWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CommentUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.CommentUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CommentCreateWithoutUserInputSchema),
          z.lazy(() => CommentCreateWithoutUserInputSchema).array(),
          z.lazy(() => CommentUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => CommentUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CommentCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => CommentCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CommentCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CommentWhereUniqueInputSchema),
          z.lazy(() => CommentWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const MessageUncheckedCreateNestedManyWithoutSenderInputSchema: z.ZodType<Prisma.MessageUncheckedCreateNestedManyWithoutSenderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => MessageCreateWithoutSenderInputSchema),
          z.lazy(() => MessageCreateWithoutSenderInputSchema).array(),
          z.lazy(() => MessageUncheckedCreateWithoutSenderInputSchema),
          z.lazy(() => MessageUncheckedCreateWithoutSenderInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => MessageCreateOrConnectWithoutSenderInputSchema),
          z.lazy(() => MessageCreateOrConnectWithoutSenderInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => MessageCreateManySenderInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => MessageWhereUniqueInputSchema),
          z.lazy(() => MessageWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const MessageUncheckedCreateNestedManyWithoutReceiverInputSchema: z.ZodType<Prisma.MessageUncheckedCreateNestedManyWithoutReceiverInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => MessageCreateWithoutReceiverInputSchema),
          z.lazy(() => MessageCreateWithoutReceiverInputSchema).array(),
          z.lazy(() => MessageUncheckedCreateWithoutReceiverInputSchema),
          z.lazy(() => MessageUncheckedCreateWithoutReceiverInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => MessageCreateOrConnectWithoutReceiverInputSchema),
          z.lazy(() => MessageCreateOrConnectWithoutReceiverInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => MessageCreateManyReceiverInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => MessageWhereUniqueInputSchema),
          z.lazy(() => MessageWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema: z.ZodType<Prisma.ReservationUncheckedCreateNestedManyWithoutAffiliateInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ReservationCreateWithoutAffiliateInputSchema),
          z.lazy(() => ReservationCreateWithoutAffiliateInputSchema).array(),
          z.lazy(() => ReservationUncheckedCreateWithoutAffiliateInputSchema),
          z
            .lazy(() => ReservationUncheckedCreateWithoutAffiliateInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ReservationCreateOrConnectWithoutAffiliateInputSchema),
          z
            .lazy(() => ReservationCreateOrConnectWithoutAffiliateInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ReservationCreateManyAffiliateInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ReservationWhereUniqueInputSchema),
          z.lazy(() => ReservationWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ListUncheckedCreateNestedManyWithoutContactsInputSchema: z.ZodType<Prisma.ListUncheckedCreateNestedManyWithoutContactsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ListCreateWithoutContactsInputSchema),
          z.lazy(() => ListCreateWithoutContactsInputSchema).array(),
          z.lazy(() => ListUncheckedCreateWithoutContactsInputSchema),
          z.lazy(() => ListUncheckedCreateWithoutContactsInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ListCreateOrConnectWithoutContactsInputSchema),
          z.lazy(() => ListCreateOrConnectWithoutContactsInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ListWhereUniqueInputSchema),
          z.lazy(() => ListWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ListUncheckedCreateNestedManyWithoutOwnersInputSchema: z.ZodType<Prisma.ListUncheckedCreateNestedManyWithoutOwnersInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ListCreateWithoutOwnersInputSchema),
          z.lazy(() => ListCreateWithoutOwnersInputSchema).array(),
          z.lazy(() => ListUncheckedCreateWithoutOwnersInputSchema),
          z.lazy(() => ListUncheckedCreateWithoutOwnersInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ListCreateOrConnectWithoutOwnersInputSchema),
          z.lazy(() => ListCreateOrConnectWithoutOwnersInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ListWhereUniqueInputSchema),
          z.lazy(() => ListWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const EmailUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.EmailUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => EmailCreateWithoutUserInputSchema),
          z.lazy(() => EmailCreateWithoutUserInputSchema).array(),
          z.lazy(() => EmailUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => EmailUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => EmailCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => EmailCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => EmailCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => EmailWhereUniqueInputSchema),
          z.lazy(() => EmailWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ClickUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.ClickUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ClickCreateWithoutUserInputSchema),
          z.lazy(() => ClickCreateWithoutUserInputSchema).array(),
          z.lazy(() => ClickUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => ClickUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ClickCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => ClickCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ClickCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ClickUncheckedCreateNestedManyWithoutRefererInputSchema: z.ZodType<Prisma.ClickUncheckedCreateNestedManyWithoutRefererInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ClickCreateWithoutRefererInputSchema),
          z.lazy(() => ClickCreateWithoutRefererInputSchema).array(),
          z.lazy(() => ClickUncheckedCreateWithoutRefererInputSchema),
          z.lazy(() => ClickUncheckedCreateWithoutRefererInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ClickCreateOrConnectWithoutRefererInputSchema),
          z.lazy(() => ClickCreateOrConnectWithoutRefererInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ClickCreateManyRefererInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const NullableBoolFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableBoolFieldUpdateOperationsInput> =
  z
    .object({
      set: z.boolean().optional().nullable()
    })
    .strict();

export const EnumUserRoleFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumUserRoleFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => UserRoleSchema).optional()
    })
    .strict();

export const AccountUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.AccountUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountCreateWithoutUserInputSchema),
          z.lazy(() => AccountCreateWithoutUserInputSchema).array(),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AccountUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => AccountUpsertWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => AccountCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AccountUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => AccountUpdateWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AccountUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => AccountUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AccountScalarWhereInputSchema),
          z.lazy(() => AccountScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const SessionUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.SessionUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SessionCreateWithoutUserInputSchema),
          z.lazy(() => SessionCreateWithoutUserInputSchema).array(),
          z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => SessionUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => SessionUpsertWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => SessionCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => SessionWhereUniqueInputSchema),
          z.lazy(() => SessionWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => SessionWhereUniqueInputSchema),
          z.lazy(() => SessionWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => SessionWhereUniqueInputSchema),
          z.lazy(() => SessionWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => SessionWhereUniqueInputSchema),
          z.lazy(() => SessionWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => SessionUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => SessionUpdateWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => SessionUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => SessionUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => SessionScalarWhereInputSchema),
          z.lazy(() => SessionScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const SiteUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.SiteUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SiteCreateWithoutUserInputSchema),
          z.lazy(() => SiteCreateWithoutUserInputSchema).array(),
          z.lazy(() => SiteUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => SiteUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SiteCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => SiteCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => SiteUpsertWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => SiteUpsertWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => SiteCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => SiteWhereUniqueInputSchema),
          z.lazy(() => SiteWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => SiteWhereUniqueInputSchema),
          z.lazy(() => SiteWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => SiteWhereUniqueInputSchema),
          z.lazy(() => SiteWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => SiteWhereUniqueInputSchema),
          z.lazy(() => SiteWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => SiteUpdateWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => SiteUpdateWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => SiteUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => SiteUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => SiteScalarWhereInputSchema),
          z.lazy(() => SiteScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const SubscriptionUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.SubscriptionUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutUserInputSchema),
          z.lazy(() => SubscriptionCreateWithoutUserInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => SubscriptionUncheckedCreateWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => SubscriptionCreateOrConnectWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => SubscriptionUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => SubscriptionUpsertWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => SubscriptionCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => SubscriptionUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => SubscriptionUpdateWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => SubscriptionUpdateManyWithWhereWithoutUserInputSchema),
          z
            .lazy(() => SubscriptionUpdateManyWithWhereWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => SubscriptionScalarWhereInputSchema),
          z.lazy(() => SubscriptionScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const AuthenticatorUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.AuthenticatorUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AuthenticatorCreateWithoutUserInputSchema),
          z.lazy(() => AuthenticatorCreateWithoutUserInputSchema).array(),
          z.lazy(() => AuthenticatorUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => AuthenticatorUncheckedCreateWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AuthenticatorCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => AuthenticatorCreateOrConnectWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => AuthenticatorUpsertWithWhereUniqueWithoutUserInputSchema
          ),
          z
            .lazy(
              () => AuthenticatorUpsertWithWhereUniqueWithoutUserInputSchema
            )
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => AuthenticatorCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => AuthenticatorWhereUniqueInputSchema),
          z.lazy(() => AuthenticatorWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AuthenticatorWhereUniqueInputSchema),
          z.lazy(() => AuthenticatorWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AuthenticatorWhereUniqueInputSchema),
          z.lazy(() => AuthenticatorWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AuthenticatorWhereUniqueInputSchema),
          z.lazy(() => AuthenticatorWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => AuthenticatorUpdateWithWhereUniqueWithoutUserInputSchema
          ),
          z
            .lazy(
              () => AuthenticatorUpdateWithWhereUniqueWithoutUserInputSchema
            )
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AuthenticatorUpdateManyWithWhereWithoutUserInputSchema),
          z
            .lazy(() => AuthenticatorUpdateManyWithWhereWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AuthenticatorScalarWhereInputSchema),
          z.lazy(() => AuthenticatorScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const LinkUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.LinkUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LinkCreateWithoutUserInputSchema),
          z.lazy(() => LinkCreateWithoutUserInputSchema).array(),
          z.lazy(() => LinkUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => LinkUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => LinkCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => LinkCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => LinkUpsertWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => LinkUpsertWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => LinkCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => LinkWhereUniqueInputSchema),
          z.lazy(() => LinkWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => LinkWhereUniqueInputSchema),
          z.lazy(() => LinkWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => LinkWhereUniqueInputSchema),
          z.lazy(() => LinkWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => LinkWhereUniqueInputSchema),
          z.lazy(() => LinkWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => LinkUpdateWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => LinkUpdateWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => LinkUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => LinkUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => LinkScalarWhereInputSchema),
          z.lazy(() => LinkScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CustomerUpdateOneWithoutUserNestedInputSchema: z.ZodType<Prisma.CustomerUpdateOneWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CustomerCreateWithoutUserInputSchema),
          z.lazy(() => CustomerUncheckedCreateWithoutUserInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CustomerCreateOrConnectWithoutUserInputSchema)
        .optional(),
      upsert: z.lazy(() => CustomerUpsertWithoutUserInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => CustomerWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => CustomerWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => CustomerWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => CustomerUpdateToOneWithWhereWithoutUserInputSchema),
          z.lazy(() => CustomerUpdateWithoutUserInputSchema),
          z.lazy(() => CustomerUncheckedUpdateWithoutUserInputSchema)
        ])
        .optional()
    })
    .strict();

export const TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema: z.ZodType<Prisma.TwoFactorConfirmationUpdateOneWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TwoFactorConfirmationCreateWithoutUserInputSchema),
          z.lazy(
            () => TwoFactorConfirmationUncheckedCreateWithoutUserInputSchema
          )
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => TwoFactorConfirmationCreateOrConnectWithoutUserInputSchema)
        .optional(),
      upsert: z
        .lazy(() => TwoFactorConfirmationUpsertWithoutUserInputSchema)
        .optional(),
      disconnect: z
        .union([
          z.boolean(),
          z.lazy(() => TwoFactorConfirmationWhereInputSchema)
        ])
        .optional(),
      delete: z
        .union([
          z.boolean(),
          z.lazy(() => TwoFactorConfirmationWhereInputSchema)
        ])
        .optional(),
      connect: z
        .lazy(() => TwoFactorConfirmationWhereUniqueInputSchema)
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              TwoFactorConfirmationUpdateToOneWithWhereWithoutUserInputSchema
          ),
          z.lazy(() => TwoFactorConfirmationUpdateWithoutUserInputSchema),
          z.lazy(
            () => TwoFactorConfirmationUncheckedUpdateWithoutUserInputSchema
          )
        ])
        .optional()
    })
    .strict();

export const UserUpdateOneWithoutAffiliatesNestedInputSchema: z.ZodType<Prisma.UserUpdateOneWithoutAffiliatesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutAffiliatesInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutAffiliatesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutAffiliatesInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutAffiliatesInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutAffiliatesInputSchema),
          z.lazy(() => UserUpdateWithoutAffiliatesInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutAffiliatesInputSchema)
        ])
        .optional()
    })
    .strict();

export const NafCodeUpdateOneWithoutUsersNestedInputSchema: z.ZodType<Prisma.NafCodeUpdateOneWithoutUsersNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NafCodeCreateWithoutUsersInputSchema),
          z.lazy(() => NafCodeUncheckedCreateWithoutUsersInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => NafCodeCreateOrConnectWithoutUsersInputSchema)
        .optional(),
      upsert: z.lazy(() => NafCodeUpsertWithoutUsersInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => NafCodeWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => NafCodeWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => NafCodeWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => NafCodeUpdateToOneWithWhereWithoutUsersInputSchema),
          z.lazy(() => NafCodeUpdateWithoutUsersInputSchema),
          z.lazy(() => NafCodeUncheckedUpdateWithoutUsersInputSchema)
        ])
        .optional()
    })
    .strict();

export const FeedbackUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.FeedbackUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FeedbackCreateWithoutUserInputSchema),
          z.lazy(() => FeedbackCreateWithoutUserInputSchema).array(),
          z.lazy(() => FeedbackUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => FeedbackUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => FeedbackCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => FeedbackCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => FeedbackUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => FeedbackUpsertWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => FeedbackCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => FeedbackWhereUniqueInputSchema),
          z.lazy(() => FeedbackWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => FeedbackWhereUniqueInputSchema),
          z.lazy(() => FeedbackWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => FeedbackWhereUniqueInputSchema),
          z.lazy(() => FeedbackWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => FeedbackWhereUniqueInputSchema),
          z.lazy(() => FeedbackWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => FeedbackUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => FeedbackUpdateWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => FeedbackUpdateManyWithWhereWithoutUserInputSchema),
          z
            .lazy(() => FeedbackUpdateManyWithWhereWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => FeedbackScalarWhereInputSchema),
          z.lazy(() => FeedbackScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const LikeUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.LikeUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LikeCreateWithoutUserInputSchema),
          z.lazy(() => LikeCreateWithoutUserInputSchema).array(),
          z.lazy(() => LikeUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => LikeUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => LikeCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => LikeCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => LikeUpsertWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => LikeUpsertWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => LikeCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => LikeUpdateWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => LikeUpdateWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => LikeUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => LikeUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => LikeScalarWhereInputSchema),
          z.lazy(() => LikeScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const UserUpdateManyWithoutRefererNestedInputSchema: z.ZodType<Prisma.UserUpdateManyWithoutRefererNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutRefererInputSchema),
          z.lazy(() => UserCreateWithoutRefererInputSchema).array(),
          z.lazy(() => UserUncheckedCreateWithoutRefererInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutRefererInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserCreateOrConnectWithoutRefererInputSchema),
          z.lazy(() => UserCreateOrConnectWithoutRefererInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => UserUpsertWithWhereUniqueWithoutRefererInputSchema),
          z
            .lazy(() => UserUpsertWithWhereUniqueWithoutRefererInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => UserCreateManyRefererInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateWithWhereUniqueWithoutRefererInputSchema),
          z
            .lazy(() => UserUpdateWithWhereUniqueWithoutRefererInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => UserUpdateManyWithWhereWithoutRefererInputSchema),
          z.lazy(() => UserUpdateManyWithWhereWithoutRefererInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => UserScalarWhereInputSchema),
          z.lazy(() => UserScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const EventUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.EventUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => EventCreateWithoutUserInputSchema),
          z.lazy(() => EventCreateWithoutUserInputSchema).array(),
          z.lazy(() => EventUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => EventUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => EventCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => EventCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => EventUpsertWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => EventUpsertWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => EventCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => EventWhereUniqueInputSchema),
          z.lazy(() => EventWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => EventWhereUniqueInputSchema),
          z.lazy(() => EventWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => EventWhereUniqueInputSchema),
          z.lazy(() => EventWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => EventWhereUniqueInputSchema),
          z.lazy(() => EventWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => EventUpdateWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => EventUpdateWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => EventUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => EventUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => EventScalarWhereInputSchema),
          z.lazy(() => EventScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const WorkflowStateUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.WorkflowStateUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => WorkflowStateCreateWithoutUserInputSchema),
          z.lazy(() => WorkflowStateCreateWithoutUserInputSchema).array(),
          z.lazy(() => WorkflowStateUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => WorkflowStateUncheckedCreateWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => WorkflowStateCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => WorkflowStateCreateOrConnectWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => WorkflowStateUpsertWithWhereUniqueWithoutUserInputSchema
          ),
          z
            .lazy(
              () => WorkflowStateUpsertWithWhereUniqueWithoutUserInputSchema
            )
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => WorkflowStateCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => WorkflowStateWhereUniqueInputSchema),
          z.lazy(() => WorkflowStateWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => WorkflowStateWhereUniqueInputSchema),
          z.lazy(() => WorkflowStateWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => WorkflowStateWhereUniqueInputSchema),
          z.lazy(() => WorkflowStateWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => WorkflowStateWhereUniqueInputSchema),
          z.lazy(() => WorkflowStateWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => WorkflowStateUpdateWithWhereUniqueWithoutUserInputSchema
          ),
          z
            .lazy(
              () => WorkflowStateUpdateWithWhereUniqueWithoutUserInputSchema
            )
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => WorkflowStateUpdateManyWithWhereWithoutUserInputSchema),
          z
            .lazy(() => WorkflowStateUpdateManyWithWhereWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => WorkflowStateScalarWhereInputSchema),
          z.lazy(() => WorkflowStateScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ExecutionUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.ExecutionUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ExecutionCreateWithoutUserInputSchema),
          z.lazy(() => ExecutionCreateWithoutUserInputSchema).array(),
          z.lazy(() => ExecutionUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => ExecutionUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ExecutionCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => ExecutionCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ExecutionUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => ExecutionUpsertWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ExecutionCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ExecutionUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => ExecutionUpdateWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ExecutionUpdateManyWithWhereWithoutUserInputSchema),
          z
            .lazy(() => ExecutionUpdateManyWithWhereWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ExecutionScalarWhereInputSchema),
          z.lazy(() => ExecutionScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const QueueUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.QueueUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => QueueCreateWithoutUserInputSchema),
          z.lazy(() => QueueCreateWithoutUserInputSchema).array(),
          z.lazy(() => QueueUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => QueueUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => QueueCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => QueueCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => QueueUpsertWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => QueueUpsertWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => QueueCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => QueueWhereUniqueInputSchema),
          z.lazy(() => QueueWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => QueueWhereUniqueInputSchema),
          z.lazy(() => QueueWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => QueueWhereUniqueInputSchema),
          z.lazy(() => QueueWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => QueueWhereUniqueInputSchema),
          z.lazy(() => QueueWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => QueueUpdateWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => QueueUpdateWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => QueueUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => QueueUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => QueueScalarWhereInputSchema),
          z.lazy(() => QueueScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const OutboxUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.OutboxUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OutboxCreateWithoutUserInputSchema),
          z.lazy(() => OutboxCreateWithoutUserInputSchema).array(),
          z.lazy(() => OutboxUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => OutboxUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OutboxCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => OutboxCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => OutboxUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => OutboxUpsertWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => OutboxCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OutboxWhereUniqueInputSchema),
          z.lazy(() => OutboxWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OutboxWhereUniqueInputSchema),
          z.lazy(() => OutboxWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OutboxWhereUniqueInputSchema),
          z.lazy(() => OutboxWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OutboxWhereUniqueInputSchema),
          z.lazy(() => OutboxWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => OutboxUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => OutboxUpdateWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => OutboxUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => OutboxUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OutboxScalarWhereInputSchema),
          z.lazy(() => OutboxScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const FeedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.FeedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FeedCreateWithoutUserInputSchema),
          z.lazy(() => FeedCreateWithoutUserInputSchema).array(),
          z.lazy(() => FeedUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => FeedUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => FeedCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => FeedCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => FeedUpsertWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => FeedUpsertWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => FeedCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => FeedWhereUniqueInputSchema),
          z.lazy(() => FeedWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => FeedWhereUniqueInputSchema),
          z.lazy(() => FeedWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => FeedWhereUniqueInputSchema),
          z.lazy(() => FeedWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => FeedWhereUniqueInputSchema),
          z.lazy(() => FeedWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => FeedUpdateWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => FeedUpdateWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => FeedUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => FeedUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => FeedScalarWhereInputSchema),
          z.lazy(() => FeedScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CommentUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.CommentUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CommentCreateWithoutUserInputSchema),
          z.lazy(() => CommentCreateWithoutUserInputSchema).array(),
          z.lazy(() => CommentUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => CommentUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CommentCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => CommentCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CommentUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => CommentUpsertWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CommentCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CommentWhereUniqueInputSchema),
          z.lazy(() => CommentWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CommentWhereUniqueInputSchema),
          z.lazy(() => CommentWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CommentWhereUniqueInputSchema),
          z.lazy(() => CommentWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CommentWhereUniqueInputSchema),
          z.lazy(() => CommentWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CommentUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => CommentUpdateWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CommentUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => CommentUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CommentScalarWhereInputSchema),
          z.lazy(() => CommentScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const MessageUpdateManyWithoutSenderNestedInputSchema: z.ZodType<Prisma.MessageUpdateManyWithoutSenderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => MessageCreateWithoutSenderInputSchema),
          z.lazy(() => MessageCreateWithoutSenderInputSchema).array(),
          z.lazy(() => MessageUncheckedCreateWithoutSenderInputSchema),
          z.lazy(() => MessageUncheckedCreateWithoutSenderInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => MessageCreateOrConnectWithoutSenderInputSchema),
          z.lazy(() => MessageCreateOrConnectWithoutSenderInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => MessageUpsertWithWhereUniqueWithoutSenderInputSchema),
          z
            .lazy(() => MessageUpsertWithWhereUniqueWithoutSenderInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => MessageCreateManySenderInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => MessageWhereUniqueInputSchema),
          z.lazy(() => MessageWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => MessageWhereUniqueInputSchema),
          z.lazy(() => MessageWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => MessageWhereUniqueInputSchema),
          z.lazy(() => MessageWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => MessageWhereUniqueInputSchema),
          z.lazy(() => MessageWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => MessageUpdateWithWhereUniqueWithoutSenderInputSchema),
          z
            .lazy(() => MessageUpdateWithWhereUniqueWithoutSenderInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => MessageUpdateManyWithWhereWithoutSenderInputSchema),
          z
            .lazy(() => MessageUpdateManyWithWhereWithoutSenderInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => MessageScalarWhereInputSchema),
          z.lazy(() => MessageScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const MessageUpdateManyWithoutReceiverNestedInputSchema: z.ZodType<Prisma.MessageUpdateManyWithoutReceiverNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => MessageCreateWithoutReceiverInputSchema),
          z.lazy(() => MessageCreateWithoutReceiverInputSchema).array(),
          z.lazy(() => MessageUncheckedCreateWithoutReceiverInputSchema),
          z.lazy(() => MessageUncheckedCreateWithoutReceiverInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => MessageCreateOrConnectWithoutReceiverInputSchema),
          z.lazy(() => MessageCreateOrConnectWithoutReceiverInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => MessageUpsertWithWhereUniqueWithoutReceiverInputSchema),
          z
            .lazy(() => MessageUpsertWithWhereUniqueWithoutReceiverInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => MessageCreateManyReceiverInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => MessageWhereUniqueInputSchema),
          z.lazy(() => MessageWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => MessageWhereUniqueInputSchema),
          z.lazy(() => MessageWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => MessageWhereUniqueInputSchema),
          z.lazy(() => MessageWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => MessageWhereUniqueInputSchema),
          z.lazy(() => MessageWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => MessageUpdateWithWhereUniqueWithoutReceiverInputSchema),
          z
            .lazy(() => MessageUpdateWithWhereUniqueWithoutReceiverInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => MessageUpdateManyWithWhereWithoutReceiverInputSchema),
          z
            .lazy(() => MessageUpdateManyWithWhereWithoutReceiverInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => MessageScalarWhereInputSchema),
          z.lazy(() => MessageScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ReservationUpdateManyWithoutAffiliateNestedInputSchema: z.ZodType<Prisma.ReservationUpdateManyWithoutAffiliateNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ReservationCreateWithoutAffiliateInputSchema),
          z.lazy(() => ReservationCreateWithoutAffiliateInputSchema).array(),
          z.lazy(() => ReservationUncheckedCreateWithoutAffiliateInputSchema),
          z
            .lazy(() => ReservationUncheckedCreateWithoutAffiliateInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ReservationCreateOrConnectWithoutAffiliateInputSchema),
          z
            .lazy(() => ReservationCreateOrConnectWithoutAffiliateInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => ReservationUpsertWithWhereUniqueWithoutAffiliateInputSchema
          ),
          z
            .lazy(
              () => ReservationUpsertWithWhereUniqueWithoutAffiliateInputSchema
            )
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ReservationCreateManyAffiliateInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ReservationWhereUniqueInputSchema),
          z.lazy(() => ReservationWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ReservationWhereUniqueInputSchema),
          z.lazy(() => ReservationWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ReservationWhereUniqueInputSchema),
          z.lazy(() => ReservationWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ReservationWhereUniqueInputSchema),
          z.lazy(() => ReservationWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => ReservationUpdateWithWhereUniqueWithoutAffiliateInputSchema
          ),
          z
            .lazy(
              () => ReservationUpdateWithWhereUniqueWithoutAffiliateInputSchema
            )
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => ReservationUpdateManyWithWhereWithoutAffiliateInputSchema
          ),
          z
            .lazy(
              () => ReservationUpdateManyWithWhereWithoutAffiliateInputSchema
            )
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ReservationScalarWhereInputSchema),
          z.lazy(() => ReservationScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ListUpdateManyWithoutContactsNestedInputSchema: z.ZodType<Prisma.ListUpdateManyWithoutContactsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ListCreateWithoutContactsInputSchema),
          z.lazy(() => ListCreateWithoutContactsInputSchema).array(),
          z.lazy(() => ListUncheckedCreateWithoutContactsInputSchema),
          z.lazy(() => ListUncheckedCreateWithoutContactsInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ListCreateOrConnectWithoutContactsInputSchema),
          z.lazy(() => ListCreateOrConnectWithoutContactsInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ListUpsertWithWhereUniqueWithoutContactsInputSchema),
          z
            .lazy(() => ListUpsertWithWhereUniqueWithoutContactsInputSchema)
            .array()
        ])
        .optional(),
      set: z
        .union([
          z.lazy(() => ListWhereUniqueInputSchema),
          z.lazy(() => ListWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ListWhereUniqueInputSchema),
          z.lazy(() => ListWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ListWhereUniqueInputSchema),
          z.lazy(() => ListWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ListWhereUniqueInputSchema),
          z.lazy(() => ListWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ListUpdateWithWhereUniqueWithoutContactsInputSchema),
          z
            .lazy(() => ListUpdateWithWhereUniqueWithoutContactsInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ListUpdateManyWithWhereWithoutContactsInputSchema),
          z
            .lazy(() => ListUpdateManyWithWhereWithoutContactsInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ListScalarWhereInputSchema),
          z.lazy(() => ListScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ListUpdateManyWithoutOwnersNestedInputSchema: z.ZodType<Prisma.ListUpdateManyWithoutOwnersNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ListCreateWithoutOwnersInputSchema),
          z.lazy(() => ListCreateWithoutOwnersInputSchema).array(),
          z.lazy(() => ListUncheckedCreateWithoutOwnersInputSchema),
          z.lazy(() => ListUncheckedCreateWithoutOwnersInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ListCreateOrConnectWithoutOwnersInputSchema),
          z.lazy(() => ListCreateOrConnectWithoutOwnersInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ListUpsertWithWhereUniqueWithoutOwnersInputSchema),
          z
            .lazy(() => ListUpsertWithWhereUniqueWithoutOwnersInputSchema)
            .array()
        ])
        .optional(),
      set: z
        .union([
          z.lazy(() => ListWhereUniqueInputSchema),
          z.lazy(() => ListWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ListWhereUniqueInputSchema),
          z.lazy(() => ListWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ListWhereUniqueInputSchema),
          z.lazy(() => ListWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ListWhereUniqueInputSchema),
          z.lazy(() => ListWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ListUpdateWithWhereUniqueWithoutOwnersInputSchema),
          z
            .lazy(() => ListUpdateWithWhereUniqueWithoutOwnersInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ListUpdateManyWithWhereWithoutOwnersInputSchema),
          z.lazy(() => ListUpdateManyWithWhereWithoutOwnersInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ListScalarWhereInputSchema),
          z.lazy(() => ListScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const EmailUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.EmailUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => EmailCreateWithoutUserInputSchema),
          z.lazy(() => EmailCreateWithoutUserInputSchema).array(),
          z.lazy(() => EmailUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => EmailUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => EmailCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => EmailCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => EmailUpsertWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => EmailUpsertWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => EmailCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => EmailWhereUniqueInputSchema),
          z.lazy(() => EmailWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => EmailWhereUniqueInputSchema),
          z.lazy(() => EmailWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => EmailWhereUniqueInputSchema),
          z.lazy(() => EmailWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => EmailWhereUniqueInputSchema),
          z.lazy(() => EmailWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => EmailUpdateWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => EmailUpdateWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => EmailUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => EmailUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => EmailScalarWhereInputSchema),
          z.lazy(() => EmailScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ClickUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.ClickUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ClickCreateWithoutUserInputSchema),
          z.lazy(() => ClickCreateWithoutUserInputSchema).array(),
          z.lazy(() => ClickUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => ClickUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ClickCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => ClickCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ClickUpsertWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => ClickUpsertWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ClickCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ClickUpdateWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => ClickUpdateWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ClickUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => ClickUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ClickScalarWhereInputSchema),
          z.lazy(() => ClickScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ClickUpdateManyWithoutRefererNestedInputSchema: z.ZodType<Prisma.ClickUpdateManyWithoutRefererNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ClickCreateWithoutRefererInputSchema),
          z.lazy(() => ClickCreateWithoutRefererInputSchema).array(),
          z.lazy(() => ClickUncheckedCreateWithoutRefererInputSchema),
          z.lazy(() => ClickUncheckedCreateWithoutRefererInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ClickCreateOrConnectWithoutRefererInputSchema),
          z.lazy(() => ClickCreateOrConnectWithoutRefererInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ClickUpsertWithWhereUniqueWithoutRefererInputSchema),
          z
            .lazy(() => ClickUpsertWithWhereUniqueWithoutRefererInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ClickCreateManyRefererInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ClickUpdateWithWhereUniqueWithoutRefererInputSchema),
          z
            .lazy(() => ClickUpdateWithWhereUniqueWithoutRefererInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ClickUpdateManyWithWhereWithoutRefererInputSchema),
          z
            .lazy(() => ClickUpdateManyWithWhereWithoutRefererInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ClickScalarWhereInputSchema),
          z.lazy(() => ClickScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const AccountUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.AccountUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountCreateWithoutUserInputSchema),
          z.lazy(() => AccountCreateWithoutUserInputSchema).array(),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AccountUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => AccountUpsertWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => AccountCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AccountUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => AccountUpdateWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AccountUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => AccountUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AccountScalarWhereInputSchema),
          z.lazy(() => AccountScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const SessionUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.SessionUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SessionCreateWithoutUserInputSchema),
          z.lazy(() => SessionCreateWithoutUserInputSchema).array(),
          z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => SessionUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => SessionUpsertWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => SessionCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => SessionWhereUniqueInputSchema),
          z.lazy(() => SessionWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => SessionWhereUniqueInputSchema),
          z.lazy(() => SessionWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => SessionWhereUniqueInputSchema),
          z.lazy(() => SessionWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => SessionWhereUniqueInputSchema),
          z.lazy(() => SessionWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => SessionUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => SessionUpdateWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => SessionUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => SessionUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => SessionScalarWhereInputSchema),
          z.lazy(() => SessionScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const SiteUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.SiteUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SiteCreateWithoutUserInputSchema),
          z.lazy(() => SiteCreateWithoutUserInputSchema).array(),
          z.lazy(() => SiteUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => SiteUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SiteCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => SiteCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => SiteUpsertWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => SiteUpsertWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => SiteCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => SiteWhereUniqueInputSchema),
          z.lazy(() => SiteWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => SiteWhereUniqueInputSchema),
          z.lazy(() => SiteWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => SiteWhereUniqueInputSchema),
          z.lazy(() => SiteWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => SiteWhereUniqueInputSchema),
          z.lazy(() => SiteWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => SiteUpdateWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => SiteUpdateWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => SiteUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => SiteUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => SiteScalarWhereInputSchema),
          z.lazy(() => SiteScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutUserInputSchema),
          z.lazy(() => SubscriptionCreateWithoutUserInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => SubscriptionUncheckedCreateWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => SubscriptionCreateOrConnectWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => SubscriptionUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => SubscriptionUpsertWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => SubscriptionCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => SubscriptionUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => SubscriptionUpdateWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => SubscriptionUpdateManyWithWhereWithoutUserInputSchema),
          z
            .lazy(() => SubscriptionUpdateManyWithWhereWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => SubscriptionScalarWhereInputSchema),
          z.lazy(() => SubscriptionScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.AuthenticatorUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AuthenticatorCreateWithoutUserInputSchema),
          z.lazy(() => AuthenticatorCreateWithoutUserInputSchema).array(),
          z.lazy(() => AuthenticatorUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => AuthenticatorUncheckedCreateWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AuthenticatorCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => AuthenticatorCreateOrConnectWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => AuthenticatorUpsertWithWhereUniqueWithoutUserInputSchema
          ),
          z
            .lazy(
              () => AuthenticatorUpsertWithWhereUniqueWithoutUserInputSchema
            )
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => AuthenticatorCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => AuthenticatorWhereUniqueInputSchema),
          z.lazy(() => AuthenticatorWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AuthenticatorWhereUniqueInputSchema),
          z.lazy(() => AuthenticatorWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AuthenticatorWhereUniqueInputSchema),
          z.lazy(() => AuthenticatorWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AuthenticatorWhereUniqueInputSchema),
          z.lazy(() => AuthenticatorWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => AuthenticatorUpdateWithWhereUniqueWithoutUserInputSchema
          ),
          z
            .lazy(
              () => AuthenticatorUpdateWithWhereUniqueWithoutUserInputSchema
            )
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AuthenticatorUpdateManyWithWhereWithoutUserInputSchema),
          z
            .lazy(() => AuthenticatorUpdateManyWithWhereWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AuthenticatorScalarWhereInputSchema),
          z.lazy(() => AuthenticatorScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const LinkUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.LinkUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LinkCreateWithoutUserInputSchema),
          z.lazy(() => LinkCreateWithoutUserInputSchema).array(),
          z.lazy(() => LinkUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => LinkUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => LinkCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => LinkCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => LinkUpsertWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => LinkUpsertWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => LinkCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => LinkWhereUniqueInputSchema),
          z.lazy(() => LinkWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => LinkWhereUniqueInputSchema),
          z.lazy(() => LinkWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => LinkWhereUniqueInputSchema),
          z.lazy(() => LinkWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => LinkWhereUniqueInputSchema),
          z.lazy(() => LinkWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => LinkUpdateWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => LinkUpdateWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => LinkUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => LinkUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => LinkScalarWhereInputSchema),
          z.lazy(() => LinkScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CustomerUncheckedUpdateOneWithoutUserNestedInputSchema: z.ZodType<Prisma.CustomerUncheckedUpdateOneWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CustomerCreateWithoutUserInputSchema),
          z.lazy(() => CustomerUncheckedCreateWithoutUserInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CustomerCreateOrConnectWithoutUserInputSchema)
        .optional(),
      upsert: z.lazy(() => CustomerUpsertWithoutUserInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => CustomerWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => CustomerWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => CustomerWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => CustomerUpdateToOneWithWhereWithoutUserInputSchema),
          z.lazy(() => CustomerUpdateWithoutUserInputSchema),
          z.lazy(() => CustomerUncheckedUpdateWithoutUserInputSchema)
        ])
        .optional()
    })
    .strict();

export const TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema: z.ZodType<Prisma.TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TwoFactorConfirmationCreateWithoutUserInputSchema),
          z.lazy(
            () => TwoFactorConfirmationUncheckedCreateWithoutUserInputSchema
          )
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => TwoFactorConfirmationCreateOrConnectWithoutUserInputSchema)
        .optional(),
      upsert: z
        .lazy(() => TwoFactorConfirmationUpsertWithoutUserInputSchema)
        .optional(),
      disconnect: z
        .union([
          z.boolean(),
          z.lazy(() => TwoFactorConfirmationWhereInputSchema)
        ])
        .optional(),
      delete: z
        .union([
          z.boolean(),
          z.lazy(() => TwoFactorConfirmationWhereInputSchema)
        ])
        .optional(),
      connect: z
        .lazy(() => TwoFactorConfirmationWhereUniqueInputSchema)
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              TwoFactorConfirmationUpdateToOneWithWhereWithoutUserInputSchema
          ),
          z.lazy(() => TwoFactorConfirmationUpdateWithoutUserInputSchema),
          z.lazy(
            () => TwoFactorConfirmationUncheckedUpdateWithoutUserInputSchema
          )
        ])
        .optional()
    })
    .strict();

export const FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.FeedbackUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FeedbackCreateWithoutUserInputSchema),
          z.lazy(() => FeedbackCreateWithoutUserInputSchema).array(),
          z.lazy(() => FeedbackUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => FeedbackUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => FeedbackCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => FeedbackCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => FeedbackUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => FeedbackUpsertWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => FeedbackCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => FeedbackWhereUniqueInputSchema),
          z.lazy(() => FeedbackWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => FeedbackWhereUniqueInputSchema),
          z.lazy(() => FeedbackWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => FeedbackWhereUniqueInputSchema),
          z.lazy(() => FeedbackWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => FeedbackWhereUniqueInputSchema),
          z.lazy(() => FeedbackWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => FeedbackUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => FeedbackUpdateWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => FeedbackUpdateManyWithWhereWithoutUserInputSchema),
          z
            .lazy(() => FeedbackUpdateManyWithWhereWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => FeedbackScalarWhereInputSchema),
          z.lazy(() => FeedbackScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const LikeUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.LikeUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LikeCreateWithoutUserInputSchema),
          z.lazy(() => LikeCreateWithoutUserInputSchema).array(),
          z.lazy(() => LikeUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => LikeUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => LikeCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => LikeCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => LikeUpsertWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => LikeUpsertWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => LikeCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => LikeWhereUniqueInputSchema),
          z.lazy(() => LikeWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => LikeUpdateWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => LikeUpdateWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => LikeUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => LikeUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => LikeScalarWhereInputSchema),
          z.lazy(() => LikeScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const UserUncheckedUpdateManyWithoutRefererNestedInputSchema: z.ZodType<Prisma.UserUncheckedUpdateManyWithoutRefererNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutRefererInputSchema),
          z.lazy(() => UserCreateWithoutRefererInputSchema).array(),
          z.lazy(() => UserUncheckedCreateWithoutRefererInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutRefererInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UserCreateOrConnectWithoutRefererInputSchema),
          z.lazy(() => UserCreateOrConnectWithoutRefererInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => UserUpsertWithWhereUniqueWithoutRefererInputSchema),
          z
            .lazy(() => UserUpsertWithWhereUniqueWithoutRefererInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => UserCreateManyRefererInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => UserWhereUniqueInputSchema),
          z.lazy(() => UserWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateWithWhereUniqueWithoutRefererInputSchema),
          z
            .lazy(() => UserUpdateWithWhereUniqueWithoutRefererInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => UserUpdateManyWithWhereWithoutRefererInputSchema),
          z.lazy(() => UserUpdateManyWithWhereWithoutRefererInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => UserScalarWhereInputSchema),
          z.lazy(() => UserScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const EventUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.EventUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => EventCreateWithoutUserInputSchema),
          z.lazy(() => EventCreateWithoutUserInputSchema).array(),
          z.lazy(() => EventUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => EventUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => EventCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => EventCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => EventUpsertWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => EventUpsertWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => EventCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => EventWhereUniqueInputSchema),
          z.lazy(() => EventWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => EventWhereUniqueInputSchema),
          z.lazy(() => EventWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => EventWhereUniqueInputSchema),
          z.lazy(() => EventWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => EventWhereUniqueInputSchema),
          z.lazy(() => EventWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => EventUpdateWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => EventUpdateWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => EventUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => EventUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => EventScalarWhereInputSchema),
          z.lazy(() => EventScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.WorkflowStateUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => WorkflowStateCreateWithoutUserInputSchema),
          z.lazy(() => WorkflowStateCreateWithoutUserInputSchema).array(),
          z.lazy(() => WorkflowStateUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => WorkflowStateUncheckedCreateWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => WorkflowStateCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => WorkflowStateCreateOrConnectWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => WorkflowStateUpsertWithWhereUniqueWithoutUserInputSchema
          ),
          z
            .lazy(
              () => WorkflowStateUpsertWithWhereUniqueWithoutUserInputSchema
            )
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => WorkflowStateCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => WorkflowStateWhereUniqueInputSchema),
          z.lazy(() => WorkflowStateWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => WorkflowStateWhereUniqueInputSchema),
          z.lazy(() => WorkflowStateWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => WorkflowStateWhereUniqueInputSchema),
          z.lazy(() => WorkflowStateWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => WorkflowStateWhereUniqueInputSchema),
          z.lazy(() => WorkflowStateWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => WorkflowStateUpdateWithWhereUniqueWithoutUserInputSchema
          ),
          z
            .lazy(
              () => WorkflowStateUpdateWithWhereUniqueWithoutUserInputSchema
            )
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => WorkflowStateUpdateManyWithWhereWithoutUserInputSchema),
          z
            .lazy(() => WorkflowStateUpdateManyWithWhereWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => WorkflowStateScalarWhereInputSchema),
          z.lazy(() => WorkflowStateScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.ExecutionUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ExecutionCreateWithoutUserInputSchema),
          z.lazy(() => ExecutionCreateWithoutUserInputSchema).array(),
          z.lazy(() => ExecutionUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => ExecutionUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ExecutionCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => ExecutionCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ExecutionUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => ExecutionUpsertWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ExecutionCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ExecutionUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => ExecutionUpdateWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ExecutionUpdateManyWithWhereWithoutUserInputSchema),
          z
            .lazy(() => ExecutionUpdateManyWithWhereWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ExecutionScalarWhereInputSchema),
          z.lazy(() => ExecutionScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const QueueUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.QueueUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => QueueCreateWithoutUserInputSchema),
          z.lazy(() => QueueCreateWithoutUserInputSchema).array(),
          z.lazy(() => QueueUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => QueueUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => QueueCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => QueueCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => QueueUpsertWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => QueueUpsertWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => QueueCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => QueueWhereUniqueInputSchema),
          z.lazy(() => QueueWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => QueueWhereUniqueInputSchema),
          z.lazy(() => QueueWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => QueueWhereUniqueInputSchema),
          z.lazy(() => QueueWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => QueueWhereUniqueInputSchema),
          z.lazy(() => QueueWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => QueueUpdateWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => QueueUpdateWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => QueueUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => QueueUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => QueueScalarWhereInputSchema),
          z.lazy(() => QueueScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const OutboxUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.OutboxUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OutboxCreateWithoutUserInputSchema),
          z.lazy(() => OutboxCreateWithoutUserInputSchema).array(),
          z.lazy(() => OutboxUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => OutboxUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OutboxCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => OutboxCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => OutboxUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => OutboxUpsertWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => OutboxCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OutboxWhereUniqueInputSchema),
          z.lazy(() => OutboxWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OutboxWhereUniqueInputSchema),
          z.lazy(() => OutboxWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OutboxWhereUniqueInputSchema),
          z.lazy(() => OutboxWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OutboxWhereUniqueInputSchema),
          z.lazy(() => OutboxWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => OutboxUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => OutboxUpdateWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => OutboxUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => OutboxUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OutboxScalarWhereInputSchema),
          z.lazy(() => OutboxScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const FeedUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.FeedUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FeedCreateWithoutUserInputSchema),
          z.lazy(() => FeedCreateWithoutUserInputSchema).array(),
          z.lazy(() => FeedUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => FeedUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => FeedCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => FeedCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => FeedUpsertWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => FeedUpsertWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => FeedCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => FeedWhereUniqueInputSchema),
          z.lazy(() => FeedWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => FeedWhereUniqueInputSchema),
          z.lazy(() => FeedWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => FeedWhereUniqueInputSchema),
          z.lazy(() => FeedWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => FeedWhereUniqueInputSchema),
          z.lazy(() => FeedWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => FeedUpdateWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => FeedUpdateWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => FeedUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => FeedUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => FeedScalarWhereInputSchema),
          z.lazy(() => FeedScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const CommentUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.CommentUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CommentCreateWithoutUserInputSchema),
          z.lazy(() => CommentCreateWithoutUserInputSchema).array(),
          z.lazy(() => CommentUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => CommentUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CommentCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => CommentCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CommentUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => CommentUpsertWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => CommentCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CommentWhereUniqueInputSchema),
          z.lazy(() => CommentWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CommentWhereUniqueInputSchema),
          z.lazy(() => CommentWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CommentWhereUniqueInputSchema),
          z.lazy(() => CommentWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CommentWhereUniqueInputSchema),
          z.lazy(() => CommentWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CommentUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => CommentUpdateWithWhereUniqueWithoutUserInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CommentUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => CommentUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CommentScalarWhereInputSchema),
          z.lazy(() => CommentScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const MessageUncheckedUpdateManyWithoutSenderNestedInputSchema: z.ZodType<Prisma.MessageUncheckedUpdateManyWithoutSenderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => MessageCreateWithoutSenderInputSchema),
          z.lazy(() => MessageCreateWithoutSenderInputSchema).array(),
          z.lazy(() => MessageUncheckedCreateWithoutSenderInputSchema),
          z.lazy(() => MessageUncheckedCreateWithoutSenderInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => MessageCreateOrConnectWithoutSenderInputSchema),
          z.lazy(() => MessageCreateOrConnectWithoutSenderInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => MessageUpsertWithWhereUniqueWithoutSenderInputSchema),
          z
            .lazy(() => MessageUpsertWithWhereUniqueWithoutSenderInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => MessageCreateManySenderInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => MessageWhereUniqueInputSchema),
          z.lazy(() => MessageWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => MessageWhereUniqueInputSchema),
          z.lazy(() => MessageWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => MessageWhereUniqueInputSchema),
          z.lazy(() => MessageWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => MessageWhereUniqueInputSchema),
          z.lazy(() => MessageWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => MessageUpdateWithWhereUniqueWithoutSenderInputSchema),
          z
            .lazy(() => MessageUpdateWithWhereUniqueWithoutSenderInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => MessageUpdateManyWithWhereWithoutSenderInputSchema),
          z
            .lazy(() => MessageUpdateManyWithWhereWithoutSenderInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => MessageScalarWhereInputSchema),
          z.lazy(() => MessageScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema: z.ZodType<Prisma.MessageUncheckedUpdateManyWithoutReceiverNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => MessageCreateWithoutReceiverInputSchema),
          z.lazy(() => MessageCreateWithoutReceiverInputSchema).array(),
          z.lazy(() => MessageUncheckedCreateWithoutReceiverInputSchema),
          z.lazy(() => MessageUncheckedCreateWithoutReceiverInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => MessageCreateOrConnectWithoutReceiverInputSchema),
          z.lazy(() => MessageCreateOrConnectWithoutReceiverInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => MessageUpsertWithWhereUniqueWithoutReceiverInputSchema),
          z
            .lazy(() => MessageUpsertWithWhereUniqueWithoutReceiverInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => MessageCreateManyReceiverInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => MessageWhereUniqueInputSchema),
          z.lazy(() => MessageWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => MessageWhereUniqueInputSchema),
          z.lazy(() => MessageWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => MessageWhereUniqueInputSchema),
          z.lazy(() => MessageWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => MessageWhereUniqueInputSchema),
          z.lazy(() => MessageWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => MessageUpdateWithWhereUniqueWithoutReceiverInputSchema),
          z
            .lazy(() => MessageUpdateWithWhereUniqueWithoutReceiverInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => MessageUpdateManyWithWhereWithoutReceiverInputSchema),
          z
            .lazy(() => MessageUpdateManyWithWhereWithoutReceiverInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => MessageScalarWhereInputSchema),
          z.lazy(() => MessageScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema: z.ZodType<Prisma.ReservationUncheckedUpdateManyWithoutAffiliateNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ReservationCreateWithoutAffiliateInputSchema),
          z.lazy(() => ReservationCreateWithoutAffiliateInputSchema).array(),
          z.lazy(() => ReservationUncheckedCreateWithoutAffiliateInputSchema),
          z
            .lazy(() => ReservationUncheckedCreateWithoutAffiliateInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ReservationCreateOrConnectWithoutAffiliateInputSchema),
          z
            .lazy(() => ReservationCreateOrConnectWithoutAffiliateInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => ReservationUpsertWithWhereUniqueWithoutAffiliateInputSchema
          ),
          z
            .lazy(
              () => ReservationUpsertWithWhereUniqueWithoutAffiliateInputSchema
            )
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ReservationCreateManyAffiliateInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ReservationWhereUniqueInputSchema),
          z.lazy(() => ReservationWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ReservationWhereUniqueInputSchema),
          z.lazy(() => ReservationWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ReservationWhereUniqueInputSchema),
          z.lazy(() => ReservationWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ReservationWhereUniqueInputSchema),
          z.lazy(() => ReservationWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => ReservationUpdateWithWhereUniqueWithoutAffiliateInputSchema
          ),
          z
            .lazy(
              () => ReservationUpdateWithWhereUniqueWithoutAffiliateInputSchema
            )
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => ReservationUpdateManyWithWhereWithoutAffiliateInputSchema
          ),
          z
            .lazy(
              () => ReservationUpdateManyWithWhereWithoutAffiliateInputSchema
            )
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ReservationScalarWhereInputSchema),
          z.lazy(() => ReservationScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ListUncheckedUpdateManyWithoutContactsNestedInputSchema: z.ZodType<Prisma.ListUncheckedUpdateManyWithoutContactsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ListCreateWithoutContactsInputSchema),
          z.lazy(() => ListCreateWithoutContactsInputSchema).array(),
          z.lazy(() => ListUncheckedCreateWithoutContactsInputSchema),
          z.lazy(() => ListUncheckedCreateWithoutContactsInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ListCreateOrConnectWithoutContactsInputSchema),
          z.lazy(() => ListCreateOrConnectWithoutContactsInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ListUpsertWithWhereUniqueWithoutContactsInputSchema),
          z
            .lazy(() => ListUpsertWithWhereUniqueWithoutContactsInputSchema)
            .array()
        ])
        .optional(),
      set: z
        .union([
          z.lazy(() => ListWhereUniqueInputSchema),
          z.lazy(() => ListWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ListWhereUniqueInputSchema),
          z.lazy(() => ListWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ListWhereUniqueInputSchema),
          z.lazy(() => ListWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ListWhereUniqueInputSchema),
          z.lazy(() => ListWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ListUpdateWithWhereUniqueWithoutContactsInputSchema),
          z
            .lazy(() => ListUpdateWithWhereUniqueWithoutContactsInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ListUpdateManyWithWhereWithoutContactsInputSchema),
          z
            .lazy(() => ListUpdateManyWithWhereWithoutContactsInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ListScalarWhereInputSchema),
          z.lazy(() => ListScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ListUncheckedUpdateManyWithoutOwnersNestedInputSchema: z.ZodType<Prisma.ListUncheckedUpdateManyWithoutOwnersNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ListCreateWithoutOwnersInputSchema),
          z.lazy(() => ListCreateWithoutOwnersInputSchema).array(),
          z.lazy(() => ListUncheckedCreateWithoutOwnersInputSchema),
          z.lazy(() => ListUncheckedCreateWithoutOwnersInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ListCreateOrConnectWithoutOwnersInputSchema),
          z.lazy(() => ListCreateOrConnectWithoutOwnersInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ListUpsertWithWhereUniqueWithoutOwnersInputSchema),
          z
            .lazy(() => ListUpsertWithWhereUniqueWithoutOwnersInputSchema)
            .array()
        ])
        .optional(),
      set: z
        .union([
          z.lazy(() => ListWhereUniqueInputSchema),
          z.lazy(() => ListWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ListWhereUniqueInputSchema),
          z.lazy(() => ListWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ListWhereUniqueInputSchema),
          z.lazy(() => ListWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ListWhereUniqueInputSchema),
          z.lazy(() => ListWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ListUpdateWithWhereUniqueWithoutOwnersInputSchema),
          z
            .lazy(() => ListUpdateWithWhereUniqueWithoutOwnersInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ListUpdateManyWithWhereWithoutOwnersInputSchema),
          z.lazy(() => ListUpdateManyWithWhereWithoutOwnersInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ListScalarWhereInputSchema),
          z.lazy(() => ListScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const EmailUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.EmailUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => EmailCreateWithoutUserInputSchema),
          z.lazy(() => EmailCreateWithoutUserInputSchema).array(),
          z.lazy(() => EmailUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => EmailUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => EmailCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => EmailCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => EmailUpsertWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => EmailUpsertWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => EmailCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => EmailWhereUniqueInputSchema),
          z.lazy(() => EmailWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => EmailWhereUniqueInputSchema),
          z.lazy(() => EmailWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => EmailWhereUniqueInputSchema),
          z.lazy(() => EmailWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => EmailWhereUniqueInputSchema),
          z.lazy(() => EmailWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => EmailUpdateWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => EmailUpdateWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => EmailUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => EmailUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => EmailScalarWhereInputSchema),
          z.lazy(() => EmailScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ClickUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.ClickUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ClickCreateWithoutUserInputSchema),
          z.lazy(() => ClickCreateWithoutUserInputSchema).array(),
          z.lazy(() => ClickUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => ClickUncheckedCreateWithoutUserInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ClickCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => ClickCreateOrConnectWithoutUserInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ClickUpsertWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => ClickUpsertWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ClickCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ClickUpdateWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => ClickUpdateWithWhereUniqueWithoutUserInputSchema).array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ClickUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => ClickUpdateManyWithWhereWithoutUserInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ClickScalarWhereInputSchema),
          z.lazy(() => ClickScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ClickUncheckedUpdateManyWithoutRefererNestedInputSchema: z.ZodType<Prisma.ClickUncheckedUpdateManyWithoutRefererNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ClickCreateWithoutRefererInputSchema),
          z.lazy(() => ClickCreateWithoutRefererInputSchema).array(),
          z.lazy(() => ClickUncheckedCreateWithoutRefererInputSchema),
          z.lazy(() => ClickUncheckedCreateWithoutRefererInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ClickCreateOrConnectWithoutRefererInputSchema),
          z.lazy(() => ClickCreateOrConnectWithoutRefererInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ClickUpsertWithWhereUniqueWithoutRefererInputSchema),
          z
            .lazy(() => ClickUpsertWithWhereUniqueWithoutRefererInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ClickCreateManyRefererInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ClickWhereUniqueInputSchema),
          z.lazy(() => ClickWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ClickUpdateWithWhereUniqueWithoutRefererInputSchema),
          z
            .lazy(() => ClickUpdateWithWhereUniqueWithoutRefererInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ClickUpdateManyWithWhereWithoutRefererInputSchema),
          z
            .lazy(() => ClickUpdateManyWithWhereWithoutRefererInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ClickScalarWhereInputSchema),
          z.lazy(() => ClickScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const UserCreateNestedOneWithoutSentInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutSentInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutSentInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutSentInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutSentInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const UserCreateNestedOneWithoutReceivedInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutReceivedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutReceivedInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutReceivedInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutReceivedInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const UserUpdateOneRequiredWithoutSentNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutSentNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutSentInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutSentInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutSentInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutSentInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutSentInputSchema),
          z.lazy(() => UserUpdateWithoutSentInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutSentInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserUpdateOneRequiredWithoutReceivedNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutReceivedNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutReceivedInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutReceivedInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutReceivedInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutReceivedInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutReceivedInputSchema),
          z.lazy(() => UserUpdateWithoutReceivedInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutReceivedInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserCreateNestedOneWithoutFeedbackInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutFeedbackInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutFeedbackInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutFeedbackInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutFeedbackInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const UserUpdateOneWithoutFeedbackNestedInputSchema: z.ZodType<Prisma.UserUpdateOneWithoutFeedbackNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutFeedbackInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutFeedbackInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutFeedbackInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutFeedbackInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutFeedbackInputSchema),
          z.lazy(() => UserUpdateWithoutFeedbackInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutFeedbackInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserCreateNestedOneWithoutJobsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutJobsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutJobsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutJobsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutJobsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const UserUpdateOneWithoutJobsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneWithoutJobsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutJobsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutJobsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutJobsInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutJobsInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutJobsInputSchema),
          z.lazy(() => UserUpdateWithoutJobsInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutJobsInputSchema)
        ])
        .optional()
    })
    .strict();

export const RuleCreateNestedManyWithoutActionInputSchema: z.ZodType<Prisma.RuleCreateNestedManyWithoutActionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleCreateWithoutActionInputSchema),
          z.lazy(() => RuleCreateWithoutActionInputSchema).array(),
          z.lazy(() => RuleUncheckedCreateWithoutActionInputSchema),
          z.lazy(() => RuleUncheckedCreateWithoutActionInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RuleCreateOrConnectWithoutActionInputSchema),
          z.lazy(() => RuleCreateOrConnectWithoutActionInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => RuleCreateManyActionInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ExecutionCreateNestedManyWithoutActionInputSchema: z.ZodType<Prisma.ExecutionCreateNestedManyWithoutActionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ExecutionCreateWithoutActionInputSchema),
          z.lazy(() => ExecutionCreateWithoutActionInputSchema).array(),
          z.lazy(() => ExecutionUncheckedCreateWithoutActionInputSchema),
          z.lazy(() => ExecutionUncheckedCreateWithoutActionInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ExecutionCreateOrConnectWithoutActionInputSchema),
          z.lazy(() => ExecutionCreateOrConnectWithoutActionInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ExecutionCreateManyActionInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const RuleUncheckedCreateNestedManyWithoutActionInputSchema: z.ZodType<Prisma.RuleUncheckedCreateNestedManyWithoutActionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleCreateWithoutActionInputSchema),
          z.lazy(() => RuleCreateWithoutActionInputSchema).array(),
          z.lazy(() => RuleUncheckedCreateWithoutActionInputSchema),
          z.lazy(() => RuleUncheckedCreateWithoutActionInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RuleCreateOrConnectWithoutActionInputSchema),
          z.lazy(() => RuleCreateOrConnectWithoutActionInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => RuleCreateManyActionInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ExecutionUncheckedCreateNestedManyWithoutActionInputSchema: z.ZodType<Prisma.ExecutionUncheckedCreateNestedManyWithoutActionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ExecutionCreateWithoutActionInputSchema),
          z.lazy(() => ExecutionCreateWithoutActionInputSchema).array(),
          z.lazy(() => ExecutionUncheckedCreateWithoutActionInputSchema),
          z.lazy(() => ExecutionUncheckedCreateWithoutActionInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ExecutionCreateOrConnectWithoutActionInputSchema),
          z.lazy(() => ExecutionCreateOrConnectWithoutActionInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ExecutionCreateManyActionInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const RuleUpdateManyWithoutActionNestedInputSchema: z.ZodType<Prisma.RuleUpdateManyWithoutActionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleCreateWithoutActionInputSchema),
          z.lazy(() => RuleCreateWithoutActionInputSchema).array(),
          z.lazy(() => RuleUncheckedCreateWithoutActionInputSchema),
          z.lazy(() => RuleUncheckedCreateWithoutActionInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RuleCreateOrConnectWithoutActionInputSchema),
          z.lazy(() => RuleCreateOrConnectWithoutActionInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => RuleUpsertWithWhereUniqueWithoutActionInputSchema),
          z
            .lazy(() => RuleUpsertWithWhereUniqueWithoutActionInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => RuleCreateManyActionInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => RuleUpdateWithWhereUniqueWithoutActionInputSchema),
          z
            .lazy(() => RuleUpdateWithWhereUniqueWithoutActionInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => RuleUpdateManyWithWhereWithoutActionInputSchema),
          z.lazy(() => RuleUpdateManyWithWhereWithoutActionInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => RuleScalarWhereInputSchema),
          z.lazy(() => RuleScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ExecutionUpdateManyWithoutActionNestedInputSchema: z.ZodType<Prisma.ExecutionUpdateManyWithoutActionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ExecutionCreateWithoutActionInputSchema),
          z.lazy(() => ExecutionCreateWithoutActionInputSchema).array(),
          z.lazy(() => ExecutionUncheckedCreateWithoutActionInputSchema),
          z.lazy(() => ExecutionUncheckedCreateWithoutActionInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ExecutionCreateOrConnectWithoutActionInputSchema),
          z.lazy(() => ExecutionCreateOrConnectWithoutActionInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ExecutionUpsertWithWhereUniqueWithoutActionInputSchema),
          z
            .lazy(() => ExecutionUpsertWithWhereUniqueWithoutActionInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ExecutionCreateManyActionInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ExecutionUpdateWithWhereUniqueWithoutActionInputSchema),
          z
            .lazy(() => ExecutionUpdateWithWhereUniqueWithoutActionInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ExecutionUpdateManyWithWhereWithoutActionInputSchema),
          z
            .lazy(() => ExecutionUpdateManyWithWhereWithoutActionInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ExecutionScalarWhereInputSchema),
          z.lazy(() => ExecutionScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const RuleUncheckedUpdateManyWithoutActionNestedInputSchema: z.ZodType<Prisma.RuleUncheckedUpdateManyWithoutActionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleCreateWithoutActionInputSchema),
          z.lazy(() => RuleCreateWithoutActionInputSchema).array(),
          z.lazy(() => RuleUncheckedCreateWithoutActionInputSchema),
          z.lazy(() => RuleUncheckedCreateWithoutActionInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RuleCreateOrConnectWithoutActionInputSchema),
          z.lazy(() => RuleCreateOrConnectWithoutActionInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => RuleUpsertWithWhereUniqueWithoutActionInputSchema),
          z
            .lazy(() => RuleUpsertWithWhereUniqueWithoutActionInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => RuleCreateManyActionInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => RuleUpdateWithWhereUniqueWithoutActionInputSchema),
          z
            .lazy(() => RuleUpdateWithWhereUniqueWithoutActionInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => RuleUpdateManyWithWhereWithoutActionInputSchema),
          z.lazy(() => RuleUpdateManyWithWhereWithoutActionInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => RuleScalarWhereInputSchema),
          z.lazy(() => RuleScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ExecutionUncheckedUpdateManyWithoutActionNestedInputSchema: z.ZodType<Prisma.ExecutionUncheckedUpdateManyWithoutActionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ExecutionCreateWithoutActionInputSchema),
          z.lazy(() => ExecutionCreateWithoutActionInputSchema).array(),
          z.lazy(() => ExecutionUncheckedCreateWithoutActionInputSchema),
          z.lazy(() => ExecutionUncheckedCreateWithoutActionInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ExecutionCreateOrConnectWithoutActionInputSchema),
          z.lazy(() => ExecutionCreateOrConnectWithoutActionInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ExecutionUpsertWithWhereUniqueWithoutActionInputSchema),
          z
            .lazy(() => ExecutionUpsertWithWhereUniqueWithoutActionInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ExecutionCreateManyActionInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ExecutionUpdateWithWhereUniqueWithoutActionInputSchema),
          z
            .lazy(() => ExecutionUpdateWithWhereUniqueWithoutActionInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ExecutionUpdateManyWithWhereWithoutActionInputSchema),
          z
            .lazy(() => ExecutionUpdateManyWithWhereWithoutActionInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ExecutionScalarWhereInputSchema),
          z.lazy(() => ExecutionScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const RuleCreateNestedManyWithoutWorkflowInputSchema: z.ZodType<Prisma.RuleCreateNestedManyWithoutWorkflowInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleCreateWithoutWorkflowInputSchema),
          z.lazy(() => RuleCreateWithoutWorkflowInputSchema).array(),
          z.lazy(() => RuleUncheckedCreateWithoutWorkflowInputSchema),
          z.lazy(() => RuleUncheckedCreateWithoutWorkflowInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RuleCreateOrConnectWithoutWorkflowInputSchema),
          z.lazy(() => RuleCreateOrConnectWithoutWorkflowInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => RuleCreateManyWorkflowInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const WorkflowStateCreateNestedManyWithoutWorkflowInputSchema: z.ZodType<Prisma.WorkflowStateCreateNestedManyWithoutWorkflowInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => WorkflowStateCreateWithoutWorkflowInputSchema),
          z.lazy(() => WorkflowStateCreateWithoutWorkflowInputSchema).array(),
          z.lazy(() => WorkflowStateUncheckedCreateWithoutWorkflowInputSchema),
          z
            .lazy(() => WorkflowStateUncheckedCreateWithoutWorkflowInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => WorkflowStateCreateOrConnectWithoutWorkflowInputSchema),
          z
            .lazy(() => WorkflowStateCreateOrConnectWithoutWorkflowInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => WorkflowStateCreateManyWorkflowInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => WorkflowStateWhereUniqueInputSchema),
          z.lazy(() => WorkflowStateWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const RuleUncheckedCreateNestedManyWithoutWorkflowInputSchema: z.ZodType<Prisma.RuleUncheckedCreateNestedManyWithoutWorkflowInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleCreateWithoutWorkflowInputSchema),
          z.lazy(() => RuleCreateWithoutWorkflowInputSchema).array(),
          z.lazy(() => RuleUncheckedCreateWithoutWorkflowInputSchema),
          z.lazy(() => RuleUncheckedCreateWithoutWorkflowInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RuleCreateOrConnectWithoutWorkflowInputSchema),
          z.lazy(() => RuleCreateOrConnectWithoutWorkflowInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => RuleCreateManyWorkflowInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const WorkflowStateUncheckedCreateNestedManyWithoutWorkflowInputSchema: z.ZodType<Prisma.WorkflowStateUncheckedCreateNestedManyWithoutWorkflowInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => WorkflowStateCreateWithoutWorkflowInputSchema),
          z.lazy(() => WorkflowStateCreateWithoutWorkflowInputSchema).array(),
          z.lazy(() => WorkflowStateUncheckedCreateWithoutWorkflowInputSchema),
          z
            .lazy(() => WorkflowStateUncheckedCreateWithoutWorkflowInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => WorkflowStateCreateOrConnectWithoutWorkflowInputSchema),
          z
            .lazy(() => WorkflowStateCreateOrConnectWithoutWorkflowInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => WorkflowStateCreateManyWorkflowInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => WorkflowStateWhereUniqueInputSchema),
          z.lazy(() => WorkflowStateWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const RuleUpdateManyWithoutWorkflowNestedInputSchema: z.ZodType<Prisma.RuleUpdateManyWithoutWorkflowNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleCreateWithoutWorkflowInputSchema),
          z.lazy(() => RuleCreateWithoutWorkflowInputSchema).array(),
          z.lazy(() => RuleUncheckedCreateWithoutWorkflowInputSchema),
          z.lazy(() => RuleUncheckedCreateWithoutWorkflowInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RuleCreateOrConnectWithoutWorkflowInputSchema),
          z.lazy(() => RuleCreateOrConnectWithoutWorkflowInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => RuleUpsertWithWhereUniqueWithoutWorkflowInputSchema),
          z
            .lazy(() => RuleUpsertWithWhereUniqueWithoutWorkflowInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => RuleCreateManyWorkflowInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => RuleUpdateWithWhereUniqueWithoutWorkflowInputSchema),
          z
            .lazy(() => RuleUpdateWithWhereUniqueWithoutWorkflowInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => RuleUpdateManyWithWhereWithoutWorkflowInputSchema),
          z
            .lazy(() => RuleUpdateManyWithWhereWithoutWorkflowInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => RuleScalarWhereInputSchema),
          z.lazy(() => RuleScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const WorkflowStateUpdateManyWithoutWorkflowNestedInputSchema: z.ZodType<Prisma.WorkflowStateUpdateManyWithoutWorkflowNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => WorkflowStateCreateWithoutWorkflowInputSchema),
          z.lazy(() => WorkflowStateCreateWithoutWorkflowInputSchema).array(),
          z.lazy(() => WorkflowStateUncheckedCreateWithoutWorkflowInputSchema),
          z
            .lazy(() => WorkflowStateUncheckedCreateWithoutWorkflowInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => WorkflowStateCreateOrConnectWithoutWorkflowInputSchema),
          z
            .lazy(() => WorkflowStateCreateOrConnectWithoutWorkflowInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => WorkflowStateUpsertWithWhereUniqueWithoutWorkflowInputSchema
          ),
          z
            .lazy(
              () => WorkflowStateUpsertWithWhereUniqueWithoutWorkflowInputSchema
            )
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => WorkflowStateCreateManyWorkflowInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => WorkflowStateWhereUniqueInputSchema),
          z.lazy(() => WorkflowStateWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => WorkflowStateWhereUniqueInputSchema),
          z.lazy(() => WorkflowStateWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => WorkflowStateWhereUniqueInputSchema),
          z.lazy(() => WorkflowStateWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => WorkflowStateWhereUniqueInputSchema),
          z.lazy(() => WorkflowStateWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => WorkflowStateUpdateWithWhereUniqueWithoutWorkflowInputSchema
          ),
          z
            .lazy(
              () => WorkflowStateUpdateWithWhereUniqueWithoutWorkflowInputSchema
            )
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => WorkflowStateUpdateManyWithWhereWithoutWorkflowInputSchema
          ),
          z
            .lazy(
              () => WorkflowStateUpdateManyWithWhereWithoutWorkflowInputSchema
            )
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => WorkflowStateScalarWhereInputSchema),
          z.lazy(() => WorkflowStateScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const RuleUncheckedUpdateManyWithoutWorkflowNestedInputSchema: z.ZodType<Prisma.RuleUncheckedUpdateManyWithoutWorkflowNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleCreateWithoutWorkflowInputSchema),
          z.lazy(() => RuleCreateWithoutWorkflowInputSchema).array(),
          z.lazy(() => RuleUncheckedCreateWithoutWorkflowInputSchema),
          z.lazy(() => RuleUncheckedCreateWithoutWorkflowInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RuleCreateOrConnectWithoutWorkflowInputSchema),
          z.lazy(() => RuleCreateOrConnectWithoutWorkflowInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => RuleUpsertWithWhereUniqueWithoutWorkflowInputSchema),
          z
            .lazy(() => RuleUpsertWithWhereUniqueWithoutWorkflowInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => RuleCreateManyWorkflowInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => RuleUpdateWithWhereUniqueWithoutWorkflowInputSchema),
          z
            .lazy(() => RuleUpdateWithWhereUniqueWithoutWorkflowInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => RuleUpdateManyWithWhereWithoutWorkflowInputSchema),
          z
            .lazy(() => RuleUpdateManyWithWhereWithoutWorkflowInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => RuleScalarWhereInputSchema),
          z.lazy(() => RuleScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const WorkflowStateUncheckedUpdateManyWithoutWorkflowNestedInputSchema: z.ZodType<Prisma.WorkflowStateUncheckedUpdateManyWithoutWorkflowNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => WorkflowStateCreateWithoutWorkflowInputSchema),
          z.lazy(() => WorkflowStateCreateWithoutWorkflowInputSchema).array(),
          z.lazy(() => WorkflowStateUncheckedCreateWithoutWorkflowInputSchema),
          z
            .lazy(() => WorkflowStateUncheckedCreateWithoutWorkflowInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => WorkflowStateCreateOrConnectWithoutWorkflowInputSchema),
          z
            .lazy(() => WorkflowStateCreateOrConnectWithoutWorkflowInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => WorkflowStateUpsertWithWhereUniqueWithoutWorkflowInputSchema
          ),
          z
            .lazy(
              () => WorkflowStateUpsertWithWhereUniqueWithoutWorkflowInputSchema
            )
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => WorkflowStateCreateManyWorkflowInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => WorkflowStateWhereUniqueInputSchema),
          z.lazy(() => WorkflowStateWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => WorkflowStateWhereUniqueInputSchema),
          z.lazy(() => WorkflowStateWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => WorkflowStateWhereUniqueInputSchema),
          z.lazy(() => WorkflowStateWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => WorkflowStateWhereUniqueInputSchema),
          z.lazy(() => WorkflowStateWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => WorkflowStateUpdateWithWhereUniqueWithoutWorkflowInputSchema
          ),
          z
            .lazy(
              () => WorkflowStateUpdateWithWhereUniqueWithoutWorkflowInputSchema
            )
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => WorkflowStateUpdateManyWithWhereWithoutWorkflowInputSchema
          ),
          z
            .lazy(
              () => WorkflowStateUpdateManyWithWhereWithoutWorkflowInputSchema
            )
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => WorkflowStateScalarWhereInputSchema),
          z.lazy(() => WorkflowStateScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const RuleCreateNestedManyWithoutTriggerInputSchema: z.ZodType<Prisma.RuleCreateNestedManyWithoutTriggerInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleCreateWithoutTriggerInputSchema),
          z.lazy(() => RuleCreateWithoutTriggerInputSchema).array(),
          z.lazy(() => RuleUncheckedCreateWithoutTriggerInputSchema),
          z.lazy(() => RuleUncheckedCreateWithoutTriggerInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RuleCreateOrConnectWithoutTriggerInputSchema),
          z.lazy(() => RuleCreateOrConnectWithoutTriggerInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => RuleCreateManyTriggerInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const RuleUncheckedCreateNestedManyWithoutTriggerInputSchema: z.ZodType<Prisma.RuleUncheckedCreateNestedManyWithoutTriggerInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleCreateWithoutTriggerInputSchema),
          z.lazy(() => RuleCreateWithoutTriggerInputSchema).array(),
          z.lazy(() => RuleUncheckedCreateWithoutTriggerInputSchema),
          z.lazy(() => RuleUncheckedCreateWithoutTriggerInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RuleCreateOrConnectWithoutTriggerInputSchema),
          z.lazy(() => RuleCreateOrConnectWithoutTriggerInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => RuleCreateManyTriggerInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const RuleUpdateManyWithoutTriggerNestedInputSchema: z.ZodType<Prisma.RuleUpdateManyWithoutTriggerNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleCreateWithoutTriggerInputSchema),
          z.lazy(() => RuleCreateWithoutTriggerInputSchema).array(),
          z.lazy(() => RuleUncheckedCreateWithoutTriggerInputSchema),
          z.lazy(() => RuleUncheckedCreateWithoutTriggerInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RuleCreateOrConnectWithoutTriggerInputSchema),
          z.lazy(() => RuleCreateOrConnectWithoutTriggerInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => RuleUpsertWithWhereUniqueWithoutTriggerInputSchema),
          z
            .lazy(() => RuleUpsertWithWhereUniqueWithoutTriggerInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => RuleCreateManyTriggerInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => RuleUpdateWithWhereUniqueWithoutTriggerInputSchema),
          z
            .lazy(() => RuleUpdateWithWhereUniqueWithoutTriggerInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => RuleUpdateManyWithWhereWithoutTriggerInputSchema),
          z.lazy(() => RuleUpdateManyWithWhereWithoutTriggerInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => RuleScalarWhereInputSchema),
          z.lazy(() => RuleScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const RuleUncheckedUpdateManyWithoutTriggerNestedInputSchema: z.ZodType<Prisma.RuleUncheckedUpdateManyWithoutTriggerNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleCreateWithoutTriggerInputSchema),
          z.lazy(() => RuleCreateWithoutTriggerInputSchema).array(),
          z.lazy(() => RuleUncheckedCreateWithoutTriggerInputSchema),
          z.lazy(() => RuleUncheckedCreateWithoutTriggerInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RuleCreateOrConnectWithoutTriggerInputSchema),
          z.lazy(() => RuleCreateOrConnectWithoutTriggerInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => RuleUpsertWithWhereUniqueWithoutTriggerInputSchema),
          z
            .lazy(() => RuleUpsertWithWhereUniqueWithoutTriggerInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => RuleCreateManyTriggerInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => RuleWhereUniqueInputSchema),
          z.lazy(() => RuleWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => RuleUpdateWithWhereUniqueWithoutTriggerInputSchema),
          z
            .lazy(() => RuleUpdateWithWhereUniqueWithoutTriggerInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => RuleUpdateManyWithWhereWithoutTriggerInputSchema),
          z.lazy(() => RuleUpdateManyWithWhereWithoutTriggerInputSchema).array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => RuleScalarWhereInputSchema),
          z.lazy(() => RuleScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const RuleConditionCreateNestedManyWithoutRuleInputSchema: z.ZodType<Prisma.RuleConditionCreateNestedManyWithoutRuleInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleConditionCreateWithoutRuleInputSchema),
          z.lazy(() => RuleConditionCreateWithoutRuleInputSchema).array(),
          z.lazy(() => RuleConditionUncheckedCreateWithoutRuleInputSchema),
          z
            .lazy(() => RuleConditionUncheckedCreateWithoutRuleInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RuleConditionCreateOrConnectWithoutRuleInputSchema),
          z
            .lazy(() => RuleConditionCreateOrConnectWithoutRuleInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => RuleConditionCreateManyRuleInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => RuleConditionWhereUniqueInputSchema),
          z.lazy(() => RuleConditionWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const WorkflowCreateNestedOneWithoutRulesInputSchema: z.ZodType<Prisma.WorkflowCreateNestedOneWithoutRulesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => WorkflowCreateWithoutRulesInputSchema),
          z.lazy(() => WorkflowUncheckedCreateWithoutRulesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => WorkflowCreateOrConnectWithoutRulesInputSchema)
        .optional(),
      connect: z.lazy(() => WorkflowWhereUniqueInputSchema).optional()
    })
    .strict();

export const ActionCreateNestedOneWithoutRulesInputSchema: z.ZodType<Prisma.ActionCreateNestedOneWithoutRulesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ActionCreateWithoutRulesInputSchema),
          z.lazy(() => ActionUncheckedCreateWithoutRulesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ActionCreateOrConnectWithoutRulesInputSchema)
        .optional(),
      connect: z.lazy(() => ActionWhereUniqueInputSchema).optional()
    })
    .strict();

export const TriggerCreateNestedOneWithoutRulesInputSchema: z.ZodType<Prisma.TriggerCreateNestedOneWithoutRulesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TriggerCreateWithoutRulesInputSchema),
          z.lazy(() => TriggerUncheckedCreateWithoutRulesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => TriggerCreateOrConnectWithoutRulesInputSchema)
        .optional(),
      connect: z.lazy(() => TriggerWhereUniqueInputSchema).optional()
    })
    .strict();

export const ExecutionCreateNestedManyWithoutRuleInputSchema: z.ZodType<Prisma.ExecutionCreateNestedManyWithoutRuleInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ExecutionCreateWithoutRuleInputSchema),
          z.lazy(() => ExecutionCreateWithoutRuleInputSchema).array(),
          z.lazy(() => ExecutionUncheckedCreateWithoutRuleInputSchema),
          z.lazy(() => ExecutionUncheckedCreateWithoutRuleInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ExecutionCreateOrConnectWithoutRuleInputSchema),
          z.lazy(() => ExecutionCreateOrConnectWithoutRuleInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ExecutionCreateManyRuleInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const RuleConditionUncheckedCreateNestedManyWithoutRuleInputSchema: z.ZodType<Prisma.RuleConditionUncheckedCreateNestedManyWithoutRuleInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleConditionCreateWithoutRuleInputSchema),
          z.lazy(() => RuleConditionCreateWithoutRuleInputSchema).array(),
          z.lazy(() => RuleConditionUncheckedCreateWithoutRuleInputSchema),
          z
            .lazy(() => RuleConditionUncheckedCreateWithoutRuleInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RuleConditionCreateOrConnectWithoutRuleInputSchema),
          z
            .lazy(() => RuleConditionCreateOrConnectWithoutRuleInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => RuleConditionCreateManyRuleInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => RuleConditionWhereUniqueInputSchema),
          z.lazy(() => RuleConditionWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ExecutionUncheckedCreateNestedManyWithoutRuleInputSchema: z.ZodType<Prisma.ExecutionUncheckedCreateNestedManyWithoutRuleInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ExecutionCreateWithoutRuleInputSchema),
          z.lazy(() => ExecutionCreateWithoutRuleInputSchema).array(),
          z.lazy(() => ExecutionUncheckedCreateWithoutRuleInputSchema),
          z.lazy(() => ExecutionUncheckedCreateWithoutRuleInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ExecutionCreateOrConnectWithoutRuleInputSchema),
          z.lazy(() => ExecutionCreateOrConnectWithoutRuleInputSchema).array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ExecutionCreateManyRuleInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const RuleConditionUpdateManyWithoutRuleNestedInputSchema: z.ZodType<Prisma.RuleConditionUpdateManyWithoutRuleNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleConditionCreateWithoutRuleInputSchema),
          z.lazy(() => RuleConditionCreateWithoutRuleInputSchema).array(),
          z.lazy(() => RuleConditionUncheckedCreateWithoutRuleInputSchema),
          z
            .lazy(() => RuleConditionUncheckedCreateWithoutRuleInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RuleConditionCreateOrConnectWithoutRuleInputSchema),
          z
            .lazy(() => RuleConditionCreateOrConnectWithoutRuleInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => RuleConditionUpsertWithWhereUniqueWithoutRuleInputSchema
          ),
          z
            .lazy(
              () => RuleConditionUpsertWithWhereUniqueWithoutRuleInputSchema
            )
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => RuleConditionCreateManyRuleInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => RuleConditionWhereUniqueInputSchema),
          z.lazy(() => RuleConditionWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => RuleConditionWhereUniqueInputSchema),
          z.lazy(() => RuleConditionWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => RuleConditionWhereUniqueInputSchema),
          z.lazy(() => RuleConditionWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => RuleConditionWhereUniqueInputSchema),
          z.lazy(() => RuleConditionWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => RuleConditionUpdateWithWhereUniqueWithoutRuleInputSchema
          ),
          z
            .lazy(
              () => RuleConditionUpdateWithWhereUniqueWithoutRuleInputSchema
            )
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => RuleConditionUpdateManyWithWhereWithoutRuleInputSchema),
          z
            .lazy(() => RuleConditionUpdateManyWithWhereWithoutRuleInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => RuleConditionScalarWhereInputSchema),
          z.lazy(() => RuleConditionScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const WorkflowUpdateOneRequiredWithoutRulesNestedInputSchema: z.ZodType<Prisma.WorkflowUpdateOneRequiredWithoutRulesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => WorkflowCreateWithoutRulesInputSchema),
          z.lazy(() => WorkflowUncheckedCreateWithoutRulesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => WorkflowCreateOrConnectWithoutRulesInputSchema)
        .optional(),
      upsert: z.lazy(() => WorkflowUpsertWithoutRulesInputSchema).optional(),
      connect: z.lazy(() => WorkflowWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => WorkflowUpdateToOneWithWhereWithoutRulesInputSchema),
          z.lazy(() => WorkflowUpdateWithoutRulesInputSchema),
          z.lazy(() => WorkflowUncheckedUpdateWithoutRulesInputSchema)
        ])
        .optional()
    })
    .strict();

export const ActionUpdateOneRequiredWithoutRulesNestedInputSchema: z.ZodType<Prisma.ActionUpdateOneRequiredWithoutRulesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ActionCreateWithoutRulesInputSchema),
          z.lazy(() => ActionUncheckedCreateWithoutRulesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ActionCreateOrConnectWithoutRulesInputSchema)
        .optional(),
      upsert: z.lazy(() => ActionUpsertWithoutRulesInputSchema).optional(),
      connect: z.lazy(() => ActionWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ActionUpdateToOneWithWhereWithoutRulesInputSchema),
          z.lazy(() => ActionUpdateWithoutRulesInputSchema),
          z.lazy(() => ActionUncheckedUpdateWithoutRulesInputSchema)
        ])
        .optional()
    })
    .strict();

export const TriggerUpdateOneRequiredWithoutRulesNestedInputSchema: z.ZodType<Prisma.TriggerUpdateOneRequiredWithoutRulesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TriggerCreateWithoutRulesInputSchema),
          z.lazy(() => TriggerUncheckedCreateWithoutRulesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => TriggerCreateOrConnectWithoutRulesInputSchema)
        .optional(),
      upsert: z.lazy(() => TriggerUpsertWithoutRulesInputSchema).optional(),
      connect: z.lazy(() => TriggerWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => TriggerUpdateToOneWithWhereWithoutRulesInputSchema),
          z.lazy(() => TriggerUpdateWithoutRulesInputSchema),
          z.lazy(() => TriggerUncheckedUpdateWithoutRulesInputSchema)
        ])
        .optional()
    })
    .strict();

export const ExecutionUpdateManyWithoutRuleNestedInputSchema: z.ZodType<Prisma.ExecutionUpdateManyWithoutRuleNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ExecutionCreateWithoutRuleInputSchema),
          z.lazy(() => ExecutionCreateWithoutRuleInputSchema).array(),
          z.lazy(() => ExecutionUncheckedCreateWithoutRuleInputSchema),
          z.lazy(() => ExecutionUncheckedCreateWithoutRuleInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ExecutionCreateOrConnectWithoutRuleInputSchema),
          z.lazy(() => ExecutionCreateOrConnectWithoutRuleInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ExecutionUpsertWithWhereUniqueWithoutRuleInputSchema),
          z
            .lazy(() => ExecutionUpsertWithWhereUniqueWithoutRuleInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ExecutionCreateManyRuleInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ExecutionUpdateWithWhereUniqueWithoutRuleInputSchema),
          z
            .lazy(() => ExecutionUpdateWithWhereUniqueWithoutRuleInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ExecutionUpdateManyWithWhereWithoutRuleInputSchema),
          z
            .lazy(() => ExecutionUpdateManyWithWhereWithoutRuleInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ExecutionScalarWhereInputSchema),
          z.lazy(() => ExecutionScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const RuleConditionUncheckedUpdateManyWithoutRuleNestedInputSchema: z.ZodType<Prisma.RuleConditionUncheckedUpdateManyWithoutRuleNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleConditionCreateWithoutRuleInputSchema),
          z.lazy(() => RuleConditionCreateWithoutRuleInputSchema).array(),
          z.lazy(() => RuleConditionUncheckedCreateWithoutRuleInputSchema),
          z
            .lazy(() => RuleConditionUncheckedCreateWithoutRuleInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RuleConditionCreateOrConnectWithoutRuleInputSchema),
          z
            .lazy(() => RuleConditionCreateOrConnectWithoutRuleInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => RuleConditionUpsertWithWhereUniqueWithoutRuleInputSchema
          ),
          z
            .lazy(
              () => RuleConditionUpsertWithWhereUniqueWithoutRuleInputSchema
            )
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => RuleConditionCreateManyRuleInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => RuleConditionWhereUniqueInputSchema),
          z.lazy(() => RuleConditionWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => RuleConditionWhereUniqueInputSchema),
          z.lazy(() => RuleConditionWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => RuleConditionWhereUniqueInputSchema),
          z.lazy(() => RuleConditionWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => RuleConditionWhereUniqueInputSchema),
          z.lazy(() => RuleConditionWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => RuleConditionUpdateWithWhereUniqueWithoutRuleInputSchema
          ),
          z
            .lazy(
              () => RuleConditionUpdateWithWhereUniqueWithoutRuleInputSchema
            )
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => RuleConditionUpdateManyWithWhereWithoutRuleInputSchema),
          z
            .lazy(() => RuleConditionUpdateManyWithWhereWithoutRuleInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => RuleConditionScalarWhereInputSchema),
          z.lazy(() => RuleConditionScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const ExecutionUncheckedUpdateManyWithoutRuleNestedInputSchema: z.ZodType<Prisma.ExecutionUncheckedUpdateManyWithoutRuleNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ExecutionCreateWithoutRuleInputSchema),
          z.lazy(() => ExecutionCreateWithoutRuleInputSchema).array(),
          z.lazy(() => ExecutionUncheckedCreateWithoutRuleInputSchema),
          z.lazy(() => ExecutionUncheckedCreateWithoutRuleInputSchema).array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ExecutionCreateOrConnectWithoutRuleInputSchema),
          z.lazy(() => ExecutionCreateOrConnectWithoutRuleInputSchema).array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ExecutionUpsertWithWhereUniqueWithoutRuleInputSchema),
          z
            .lazy(() => ExecutionUpsertWithWhereUniqueWithoutRuleInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => ExecutionCreateManyRuleInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ExecutionWhereUniqueInputSchema),
          z.lazy(() => ExecutionWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ExecutionUpdateWithWhereUniqueWithoutRuleInputSchema),
          z
            .lazy(() => ExecutionUpdateWithWhereUniqueWithoutRuleInputSchema)
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ExecutionUpdateManyWithWhereWithoutRuleInputSchema),
          z
            .lazy(() => ExecutionUpdateManyWithWhereWithoutRuleInputSchema)
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ExecutionScalarWhereInputSchema),
          z.lazy(() => ExecutionScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const RuleConditionCreateNestedManyWithoutConditionInputSchema: z.ZodType<Prisma.RuleConditionCreateNestedManyWithoutConditionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleConditionCreateWithoutConditionInputSchema),
          z.lazy(() => RuleConditionCreateWithoutConditionInputSchema).array(),
          z.lazy(() => RuleConditionUncheckedCreateWithoutConditionInputSchema),
          z
            .lazy(() => RuleConditionUncheckedCreateWithoutConditionInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RuleConditionCreateOrConnectWithoutConditionInputSchema),
          z
            .lazy(() => RuleConditionCreateOrConnectWithoutConditionInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => RuleConditionCreateManyConditionInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => RuleConditionWhereUniqueInputSchema),
          z.lazy(() => RuleConditionWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const RuleConditionUncheckedCreateNestedManyWithoutConditionInputSchema: z.ZodType<Prisma.RuleConditionUncheckedCreateNestedManyWithoutConditionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleConditionCreateWithoutConditionInputSchema),
          z.lazy(() => RuleConditionCreateWithoutConditionInputSchema).array(),
          z.lazy(() => RuleConditionUncheckedCreateWithoutConditionInputSchema),
          z
            .lazy(() => RuleConditionUncheckedCreateWithoutConditionInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RuleConditionCreateOrConnectWithoutConditionInputSchema),
          z
            .lazy(() => RuleConditionCreateOrConnectWithoutConditionInputSchema)
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => RuleConditionCreateManyConditionInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => RuleConditionWhereUniqueInputSchema),
          z.lazy(() => RuleConditionWhereUniqueInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const EnumConditionTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumConditionTypeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => ConditionTypeSchema).optional()
    })
    .strict();

export const RuleConditionUpdateManyWithoutConditionNestedInputSchema: z.ZodType<Prisma.RuleConditionUpdateManyWithoutConditionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleConditionCreateWithoutConditionInputSchema),
          z.lazy(() => RuleConditionCreateWithoutConditionInputSchema).array(),
          z.lazy(() => RuleConditionUncheckedCreateWithoutConditionInputSchema),
          z
            .lazy(() => RuleConditionUncheckedCreateWithoutConditionInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RuleConditionCreateOrConnectWithoutConditionInputSchema),
          z
            .lazy(() => RuleConditionCreateOrConnectWithoutConditionInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => RuleConditionUpsertWithWhereUniqueWithoutConditionInputSchema
          ),
          z
            .lazy(
              () =>
                RuleConditionUpsertWithWhereUniqueWithoutConditionInputSchema
            )
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => RuleConditionCreateManyConditionInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => RuleConditionWhereUniqueInputSchema),
          z.lazy(() => RuleConditionWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => RuleConditionWhereUniqueInputSchema),
          z.lazy(() => RuleConditionWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => RuleConditionWhereUniqueInputSchema),
          z.lazy(() => RuleConditionWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => RuleConditionWhereUniqueInputSchema),
          z.lazy(() => RuleConditionWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => RuleConditionUpdateWithWhereUniqueWithoutConditionInputSchema
          ),
          z
            .lazy(
              () =>
                RuleConditionUpdateWithWhereUniqueWithoutConditionInputSchema
            )
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => RuleConditionUpdateManyWithWhereWithoutConditionInputSchema
          ),
          z
            .lazy(
              () => RuleConditionUpdateManyWithWhereWithoutConditionInputSchema
            )
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => RuleConditionScalarWhereInputSchema),
          z.lazy(() => RuleConditionScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const RuleConditionUncheckedUpdateManyWithoutConditionNestedInputSchema: z.ZodType<Prisma.RuleConditionUncheckedUpdateManyWithoutConditionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleConditionCreateWithoutConditionInputSchema),
          z.lazy(() => RuleConditionCreateWithoutConditionInputSchema).array(),
          z.lazy(() => RuleConditionUncheckedCreateWithoutConditionInputSchema),
          z
            .lazy(() => RuleConditionUncheckedCreateWithoutConditionInputSchema)
            .array()
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RuleConditionCreateOrConnectWithoutConditionInputSchema),
          z
            .lazy(() => RuleConditionCreateOrConnectWithoutConditionInputSchema)
            .array()
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => RuleConditionUpsertWithWhereUniqueWithoutConditionInputSchema
          ),
          z
            .lazy(
              () =>
                RuleConditionUpsertWithWhereUniqueWithoutConditionInputSchema
            )
            .array()
        ])
        .optional(),
      createMany: z
        .lazy(() => RuleConditionCreateManyConditionInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => RuleConditionWhereUniqueInputSchema),
          z.lazy(() => RuleConditionWhereUniqueInputSchema).array()
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => RuleConditionWhereUniqueInputSchema),
          z.lazy(() => RuleConditionWhereUniqueInputSchema).array()
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => RuleConditionWhereUniqueInputSchema),
          z.lazy(() => RuleConditionWhereUniqueInputSchema).array()
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => RuleConditionWhereUniqueInputSchema),
          z.lazy(() => RuleConditionWhereUniqueInputSchema).array()
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => RuleConditionUpdateWithWhereUniqueWithoutConditionInputSchema
          ),
          z
            .lazy(
              () =>
                RuleConditionUpdateWithWhereUniqueWithoutConditionInputSchema
            )
            .array()
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => RuleConditionUpdateManyWithWhereWithoutConditionInputSchema
          ),
          z
            .lazy(
              () => RuleConditionUpdateManyWithWhereWithoutConditionInputSchema
            )
            .array()
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => RuleConditionScalarWhereInputSchema),
          z.lazy(() => RuleConditionScalarWhereInputSchema).array()
        ])
        .optional()
    })
    .strict();

export const RuleCreateNestedOneWithoutRuleConditionsInputSchema: z.ZodType<Prisma.RuleCreateNestedOneWithoutRuleConditionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleCreateWithoutRuleConditionsInputSchema),
          z.lazy(() => RuleUncheckedCreateWithoutRuleConditionsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => RuleCreateOrConnectWithoutRuleConditionsInputSchema)
        .optional(),
      connect: z.lazy(() => RuleWhereUniqueInputSchema).optional()
    })
    .strict();

export const ConditionCreateNestedOneWithoutRulesInputSchema: z.ZodType<Prisma.ConditionCreateNestedOneWithoutRulesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ConditionCreateWithoutRulesInputSchema),
          z.lazy(() => ConditionUncheckedCreateWithoutRulesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ConditionCreateOrConnectWithoutRulesInputSchema)
        .optional(),
      connect: z.lazy(() => ConditionWhereUniqueInputSchema).optional()
    })
    .strict();

export const EnumOperatorFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumOperatorFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => OperatorSchema).optional()
    })
    .strict();

export const RuleUpdateOneRequiredWithoutRuleConditionsNestedInputSchema: z.ZodType<Prisma.RuleUpdateOneRequiredWithoutRuleConditionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleCreateWithoutRuleConditionsInputSchema),
          z.lazy(() => RuleUncheckedCreateWithoutRuleConditionsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => RuleCreateOrConnectWithoutRuleConditionsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => RuleUpsertWithoutRuleConditionsInputSchema)
        .optional(),
      connect: z.lazy(() => RuleWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => RuleUpdateToOneWithWhereWithoutRuleConditionsInputSchema
          ),
          z.lazy(() => RuleUpdateWithoutRuleConditionsInputSchema),
          z.lazy(() => RuleUncheckedUpdateWithoutRuleConditionsInputSchema)
        ])
        .optional()
    })
    .strict();

export const ConditionUpdateOneRequiredWithoutRulesNestedInputSchema: z.ZodType<Prisma.ConditionUpdateOneRequiredWithoutRulesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ConditionCreateWithoutRulesInputSchema),
          z.lazy(() => ConditionUncheckedCreateWithoutRulesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ConditionCreateOrConnectWithoutRulesInputSchema)
        .optional(),
      upsert: z.lazy(() => ConditionUpsertWithoutRulesInputSchema).optional(),
      connect: z.lazy(() => ConditionWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ConditionUpdateToOneWithWhereWithoutRulesInputSchema),
          z.lazy(() => ConditionUpdateWithoutRulesInputSchema),
          z.lazy(() => ConditionUncheckedUpdateWithoutRulesInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserCreateNestedOneWithoutEventsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutEventsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutEventsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutEventsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutEventsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const UserUpdateOneRequiredWithoutEventsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutEventsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutEventsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutEventsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutEventsInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutEventsInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutEventsInputSchema),
          z.lazy(() => UserUpdateWithoutEventsInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutEventsInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserCreateNestedOneWithoutWorkflowStatesInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutWorkflowStatesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutWorkflowStatesInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutWorkflowStatesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutWorkflowStatesInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const WorkflowCreateNestedOneWithoutStatesInputSchema: z.ZodType<Prisma.WorkflowCreateNestedOneWithoutStatesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => WorkflowCreateWithoutStatesInputSchema),
          z.lazy(() => WorkflowUncheckedCreateWithoutStatesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => WorkflowCreateOrConnectWithoutStatesInputSchema)
        .optional(),
      connect: z.lazy(() => WorkflowWhereUniqueInputSchema).optional()
    })
    .strict();

export const EnumWorkflowStateStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumWorkflowStateStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => WorkflowStateStatusSchema).optional()
    })
    .strict();

export const UserUpdateOneRequiredWithoutWorkflowStatesNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutWorkflowStatesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutWorkflowStatesInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutWorkflowStatesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutWorkflowStatesInputSchema)
        .optional(),
      upsert: z
        .lazy(() => UserUpsertWithoutWorkflowStatesInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => UserUpdateToOneWithWhereWithoutWorkflowStatesInputSchema
          ),
          z.lazy(() => UserUpdateWithoutWorkflowStatesInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutWorkflowStatesInputSchema)
        ])
        .optional()
    })
    .strict();

export const WorkflowUpdateOneRequiredWithoutStatesNestedInputSchema: z.ZodType<Prisma.WorkflowUpdateOneRequiredWithoutStatesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => WorkflowCreateWithoutStatesInputSchema),
          z.lazy(() => WorkflowUncheckedCreateWithoutStatesInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => WorkflowCreateOrConnectWithoutStatesInputSchema)
        .optional(),
      upsert: z.lazy(() => WorkflowUpsertWithoutStatesInputSchema).optional(),
      connect: z.lazy(() => WorkflowWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => WorkflowUpdateToOneWithWhereWithoutStatesInputSchema),
          z.lazy(() => WorkflowUpdateWithoutStatesInputSchema),
          z.lazy(() => WorkflowUncheckedUpdateWithoutStatesInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserCreateNestedOneWithoutExecutionsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutExecutionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutExecutionsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutExecutionsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutExecutionsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
    })
    .strict();

export const ActionCreateNestedOneWithoutExecutionsInputSchema: z.ZodType<Prisma.ActionCreateNestedOneWithoutExecutionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ActionCreateWithoutExecutionsInputSchema),
          z.lazy(() => ActionUncheckedCreateWithoutExecutionsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ActionCreateOrConnectWithoutExecutionsInputSchema)
        .optional(),
      connect: z.lazy(() => ActionWhereUniqueInputSchema).optional()
    })
    .strict();

export const RuleCreateNestedOneWithoutExecutionsInputSchema: z.ZodType<Prisma.RuleCreateNestedOneWithoutExecutionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleCreateWithoutExecutionsInputSchema),
          z.lazy(() => RuleUncheckedCreateWithoutExecutionsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => RuleCreateOrConnectWithoutExecutionsInputSchema)
        .optional(),
      connect: z.lazy(() => RuleWhereUniqueInputSchema).optional()
    })
    .strict();

export const EnumExecutionStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumExecutionStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => ExecutionStatusSchema).optional()
    })
    .strict();

export const UserUpdateOneRequiredWithoutExecutionsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutExecutionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutExecutionsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutExecutionsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutExecutionsInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutExecutionsInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutExecutionsInputSchema),
          z.lazy(() => UserUpdateWithoutExecutionsInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutExecutionsInputSchema)
        ])
        .optional()
    })
    .strict();

export const ActionUpdateOneRequiredWithoutExecutionsNestedInputSchema: z.ZodType<Prisma.ActionUpdateOneRequiredWithoutExecutionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ActionCreateWithoutExecutionsInputSchema),
          z.lazy(() => ActionUncheckedCreateWithoutExecutionsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ActionCreateOrConnectWithoutExecutionsInputSchema)
        .optional(),
      upsert: z.lazy(() => ActionUpsertWithoutExecutionsInputSchema).optional(),
      connect: z.lazy(() => ActionWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ActionUpdateToOneWithWhereWithoutExecutionsInputSchema),
          z.lazy(() => ActionUpdateWithoutExecutionsInputSchema),
          z.lazy(() => ActionUncheckedUpdateWithoutExecutionsInputSchema)
        ])
        .optional()
    })
    .strict();

export const RuleUpdateOneWithoutExecutionsNestedInputSchema: z.ZodType<Prisma.RuleUpdateOneWithoutExecutionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RuleCreateWithoutExecutionsInputSchema),
          z.lazy(() => RuleUncheckedCreateWithoutExecutionsInputSchema)
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => RuleCreateOrConnectWithoutExecutionsInputSchema)
        .optional(),
      upsert: z.lazy(() => RuleUpsertWithoutExecutionsInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => RuleWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => RuleWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => RuleWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => RuleUpdateToOneWithWhereWithoutExecutionsInputSchema),
          z.lazy(() => RuleUpdateWithoutExecutionsInputSchema),
          z.lazy(() => RuleUncheckedUpdateWithoutExecutionsInputSchema)
        ])
        .optional()
    })
    .strict();

export const NestedStringFilterSchema: z.ZodType<Prisma.NestedStringFilter> = z
  .object({
    equals: z.string().optional(),
    in: z.string().array().optional(),
    notIn: z.string().array().optional(),
    lt: z.string().optional(),
    lte: z.string().optional(),
    gt: z.string().optional(),
    gte: z.string().optional(),
    contains: z.string().optional(),
    startsWith: z.string().optional(),
    endsWith: z.string().optional(),
    not: z
      .union([z.string(), z.lazy(() => NestedStringFilterSchema)])
      .optional()
  })
  .strict();

export const NestedStringWithAggregatesFilterSchema: z.ZodType<Prisma.NestedStringWithAggregatesFilter> =
  z
    .object({
      equals: z.string().optional(),
      in: z.string().array().optional(),
      notIn: z.string().array().optional(),
      lt: z.string().optional(),
      lte: z.string().optional(),
      gt: z.string().optional(),
      gte: z.string().optional(),
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      not: z
        .union([
          z.string(),
          z.lazy(() => NestedStringWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedStringFilterSchema).optional(),
      _max: z.lazy(() => NestedStringFilterSchema).optional()
    })
    .strict();

export const NestedIntFilterSchema: z.ZodType<Prisma.NestedIntFilter> = z
  .object({
    equals: z.number().optional(),
    in: z.number().array().optional(),
    notIn: z.number().array().optional(),
    lt: z.number().optional(),
    lte: z.number().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    not: z.union([z.number(), z.lazy(() => NestedIntFilterSchema)]).optional()
  })
  .strict();

export const NestedStringNullableFilterSchema: z.ZodType<Prisma.NestedStringNullableFilter> =
  z
    .object({
      equals: z.string().optional().nullable(),
      in: z.string().array().optional().nullable(),
      notIn: z.string().array().optional().nullable(),
      lt: z.string().optional(),
      lte: z.string().optional(),
      gt: z.string().optional(),
      gte: z.string().optional(),
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      not: z
        .union([z.string(), z.lazy(() => NestedStringNullableFilterSchema)])
        .optional()
        .nullable()
    })
    .strict();

export const NestedIntNullableFilterSchema: z.ZodType<Prisma.NestedIntNullableFilter> =
  z
    .object({
      equals: z.number().optional().nullable(),
      in: z.number().array().optional().nullable(),
      notIn: z.number().array().optional().nullable(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([z.number(), z.lazy(() => NestedIntNullableFilterSchema)])
        .optional()
        .nullable()
    })
    .strict();

export const NestedDateTimeFilterSchema: z.ZodType<Prisma.NestedDateTimeFilter> =
  z
    .object({
      equals: z.coerce.date().optional(),
      in: z.coerce.date().array().optional(),
      notIn: z.coerce.date().array().optional(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([z.coerce.date(), z.lazy(() => NestedDateTimeFilterSchema)])
        .optional()
    })
    .strict();

export const NestedStringNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedStringNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.string().optional().nullable(),
      in: z.string().array().optional().nullable(),
      notIn: z.string().array().optional().nullable(),
      lt: z.string().optional(),
      lte: z.string().optional(),
      gt: z.string().optional(),
      gte: z.string().optional(),
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      not: z
        .union([
          z.string(),
          z.lazy(() => NestedStringNullableWithAggregatesFilterSchema)
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedStringNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedStringNullableFilterSchema).optional()
    })
    .strict();

export const NestedIntNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedIntNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional().nullable(),
      in: z.number().array().optional().nullable(),
      notIn: z.number().array().optional().nullable(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([
          z.number(),
          z.lazy(() => NestedIntNullableWithAggregatesFilterSchema)
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
      _sum: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedIntNullableFilterSchema).optional()
    })
    .strict();

export const NestedFloatNullableFilterSchema: z.ZodType<Prisma.NestedFloatNullableFilter> =
  z
    .object({
      equals: z.number().optional().nullable(),
      in: z.number().array().optional().nullable(),
      notIn: z.number().array().optional().nullable(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([z.number(), z.lazy(() => NestedFloatNullableFilterSchema)])
        .optional()
        .nullable()
    })
    .strict();

export const NestedDateTimeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedDateTimeWithAggregatesFilter> =
  z
    .object({
      equals: z.coerce.date().optional(),
      in: z.coerce.date().array().optional(),
      notIn: z.coerce.date().array().optional(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([
          z.coerce.date(),
          z.lazy(() => NestedDateTimeWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedDateTimeFilterSchema).optional(),
      _max: z.lazy(() => NestedDateTimeFilterSchema).optional()
    })
    .strict();

export const NestedBoolFilterSchema: z.ZodType<Prisma.NestedBoolFilter> = z
  .object({
    equals: z.boolean().optional(),
    not: z.union([z.boolean(), z.lazy(() => NestedBoolFilterSchema)]).optional()
  })
  .strict();

export const NestedIntWithAggregatesFilterSchema: z.ZodType<Prisma.NestedIntWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional(),
      in: z.number().array().optional(),
      notIn: z.number().array().optional(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([z.number(), z.lazy(() => NestedIntWithAggregatesFilterSchema)])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatFilterSchema).optional(),
      _sum: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedIntFilterSchema).optional(),
      _max: z.lazy(() => NestedIntFilterSchema).optional()
    })
    .strict();

export const NestedFloatFilterSchema: z.ZodType<Prisma.NestedFloatFilter> = z
  .object({
    equals: z.number().optional(),
    in: z.number().array().optional(),
    notIn: z.number().array().optional(),
    lt: z.number().optional(),
    lte: z.number().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    not: z.union([z.number(), z.lazy(() => NestedFloatFilterSchema)]).optional()
  })
  .strict();

export const NestedBoolWithAggregatesFilterSchema: z.ZodType<Prisma.NestedBoolWithAggregatesFilter> =
  z
    .object({
      equals: z.boolean().optional(),
      not: z
        .union([
          z.boolean(),
          z.lazy(() => NestedBoolWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedBoolFilterSchema).optional(),
      _max: z.lazy(() => NestedBoolFilterSchema).optional()
    })
    .strict();

export const NestedJsonFilterSchema: z.ZodType<Prisma.NestedJsonFilter> = z
  .object({
    equals: InputJsonValueSchema.optional(),
    path: z.string().array().optional(),
    mode: z.lazy(() => QueryModeSchema).optional(),
    string_contains: z.string().optional(),
    string_starts_with: z.string().optional(),
    string_ends_with: z.string().optional(),
    array_starts_with: InputJsonValueSchema.optional().nullable(),
    array_ends_with: InputJsonValueSchema.optional().nullable(),
    array_contains: InputJsonValueSchema.optional().nullable(),
    lt: InputJsonValueSchema.optional(),
    lte: InputJsonValueSchema.optional(),
    gt: InputJsonValueSchema.optional(),
    gte: InputJsonValueSchema.optional(),
    not: InputJsonValueSchema.optional()
  })
  .strict();

export const NestedEnumPricingTypeFilterSchema: z.ZodType<Prisma.NestedEnumPricingTypeFilter> =
  z
    .object({
      equals: z.lazy(() => PricingTypeSchema).optional(),
      in: z
        .lazy(() => PricingTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PricingTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PricingTypeSchema),
          z.lazy(() => NestedEnumPricingTypeFilterSchema)
        ])
        .optional()
    })
    .strict();

export const NestedEnumPricingPlanIntervalNullableFilterSchema: z.ZodType<Prisma.NestedEnumPricingPlanIntervalNullableFilter> =
  z
    .object({
      equals: z
        .lazy(() => PricingPlanIntervalSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => PricingPlanIntervalSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => PricingPlanIntervalSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => PricingPlanIntervalSchema),
          z.lazy(() => NestedEnumPricingPlanIntervalNullableFilterSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const NestedEnumPricingTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumPricingTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => PricingTypeSchema).optional(),
      in: z
        .lazy(() => PricingTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PricingTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PricingTypeSchema),
          z.lazy(() => NestedEnumPricingTypeWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumPricingTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumPricingTypeFilterSchema).optional()
    })
    .strict();

export const NestedEnumPricingPlanIntervalNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumPricingPlanIntervalNullableWithAggregatesFilter> =
  z
    .object({
      equals: z
        .lazy(() => PricingPlanIntervalSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => PricingPlanIntervalSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => PricingPlanIntervalSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => PricingPlanIntervalSchema),
          z.lazy(
            () =>
              NestedEnumPricingPlanIntervalNullableWithAggregatesFilterSchema
          )
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z
        .lazy(() => NestedEnumPricingPlanIntervalNullableFilterSchema)
        .optional(),
      _max: z
        .lazy(() => NestedEnumPricingPlanIntervalNullableFilterSchema)
        .optional()
    })
    .strict();

export const NestedEnumSubscriptionStatusFilterSchema: z.ZodType<Prisma.NestedEnumSubscriptionStatusFilter> =
  z
    .object({
      equals: z.lazy(() => SubscriptionStatusSchema).optional(),
      in: z
        .lazy(() => SubscriptionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => SubscriptionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => NestedEnumSubscriptionStatusFilterSchema)
        ])
        .optional()
    })
    .strict();

export const NestedDateTimeNullableFilterSchema: z.ZodType<Prisma.NestedDateTimeNullableFilter> =
  z
    .object({
      equals: z.coerce.date().optional().nullable(),
      in: z.coerce.date().array().optional().nullable(),
      notIn: z.coerce.date().array().optional().nullable(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([
          z.coerce.date(),
          z.lazy(() => NestedDateTimeNullableFilterSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const NestedEnumSubscriptionStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumSubscriptionStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => SubscriptionStatusSchema).optional(),
      in: z
        .lazy(() => SubscriptionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => SubscriptionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => NestedEnumSubscriptionStatusWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumSubscriptionStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumSubscriptionStatusFilterSchema).optional()
    })
    .strict();

export const NestedDateTimeNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedDateTimeNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.coerce.date().optional().nullable(),
      in: z.coerce.date().array().optional().nullable(),
      notIn: z.coerce.date().array().optional().nullable(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([
          z.coerce.date(),
          z.lazy(() => NestedDateTimeNullableWithAggregatesFilterSchema)
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedDateTimeNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedDateTimeNullableFilterSchema).optional()
    })
    .strict();

export const NestedEnumFeedTypeFilterSchema: z.ZodType<Prisma.NestedEnumFeedTypeFilter> =
  z
    .object({
      equals: z.lazy(() => FeedTypeSchema).optional(),
      in: z
        .lazy(() => FeedTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => FeedTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => FeedTypeSchema),
          z.lazy(() => NestedEnumFeedTypeFilterSchema)
        ])
        .optional()
    })
    .strict();

export const NestedEnumFeedTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumFeedTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => FeedTypeSchema).optional(),
      in: z
        .lazy(() => FeedTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => FeedTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => FeedTypeSchema),
          z.lazy(() => NestedEnumFeedTypeWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumFeedTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumFeedTypeFilterSchema).optional()
    })
    .strict();

export const NestedFloatNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedFloatNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional().nullable(),
      in: z.number().array().optional().nullable(),
      notIn: z.number().array().optional().nullable(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([
          z.number(),
          z.lazy(() => NestedFloatNullableWithAggregatesFilterSchema)
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
      _sum: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedFloatNullableFilterSchema).optional()
    })
    .strict();

export const NestedJsonNullableFilterSchema: z.ZodType<Prisma.NestedJsonNullableFilter> =
  z
    .object({
      equals: InputJsonValueSchema.optional(),
      path: z.string().array().optional(),
      mode: z.lazy(() => QueryModeSchema).optional(),
      string_contains: z.string().optional(),
      string_starts_with: z.string().optional(),
      string_ends_with: z.string().optional(),
      array_starts_with: InputJsonValueSchema.optional().nullable(),
      array_ends_with: InputJsonValueSchema.optional().nullable(),
      array_contains: InputJsonValueSchema.optional().nullable(),
      lt: InputJsonValueSchema.optional(),
      lte: InputJsonValueSchema.optional(),
      gt: InputJsonValueSchema.optional(),
      gte: InputJsonValueSchema.optional(),
      not: InputJsonValueSchema.optional()
    })
    .strict();

export const NestedEnumCampaignTypeFilterSchema: z.ZodType<Prisma.NestedEnumCampaignTypeFilter> =
  z
    .object({
      equals: z.lazy(() => CampaignTypeSchema).optional(),
      in: z
        .lazy(() => CampaignTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CampaignTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CampaignTypeSchema),
          z.lazy(() => NestedEnumCampaignTypeFilterSchema)
        ])
        .optional()
    })
    .strict();

export const NestedEnumCampaignTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumCampaignTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => CampaignTypeSchema).optional(),
      in: z
        .lazy(() => CampaignTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CampaignTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CampaignTypeSchema),
          z.lazy(() => NestedEnumCampaignTypeWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumCampaignTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumCampaignTypeFilterSchema).optional()
    })
    .strict();

export const NestedEnumEntityTypeFilterSchema: z.ZodType<Prisma.NestedEnumEntityTypeFilter> =
  z
    .object({
      equals: z.lazy(() => EntityTypeSchema).optional(),
      in: z
        .lazy(() => EntityTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => EntityTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => EntityTypeSchema),
          z.lazy(() => NestedEnumEntityTypeFilterSchema)
        ])
        .optional()
    })
    .strict();

export const NestedEnumMediaTypeFilterSchema: z.ZodType<Prisma.NestedEnumMediaTypeFilter> =
  z
    .object({
      equals: z.lazy(() => MediaTypeSchema).optional(),
      in: z
        .lazy(() => MediaTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => MediaTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => MediaTypeSchema),
          z.lazy(() => NestedEnumMediaTypeFilterSchema)
        ])
        .optional()
    })
    .strict();

export const NestedEnumEntityTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumEntityTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => EntityTypeSchema).optional(),
      in: z
        .lazy(() => EntityTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => EntityTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => EntityTypeSchema),
          z.lazy(() => NestedEnumEntityTypeWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumEntityTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumEntityTypeFilterSchema).optional()
    })
    .strict();

export const NestedEnumMediaTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumMediaTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => MediaTypeSchema).optional(),
      in: z
        .lazy(() => MediaTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => MediaTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => MediaTypeSchema),
          z.lazy(() => NestedEnumMediaTypeWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumMediaTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumMediaTypeFilterSchema).optional()
    })
    .strict();

export const NestedFloatWithAggregatesFilterSchema: z.ZodType<Prisma.NestedFloatWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional(),
      in: z.number().array().optional(),
      notIn: z.number().array().optional(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([
          z.number(),
          z.lazy(() => NestedFloatWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatFilterSchema).optional(),
      _sum: z.lazy(() => NestedFloatFilterSchema).optional(),
      _min: z.lazy(() => NestedFloatFilterSchema).optional(),
      _max: z.lazy(() => NestedFloatFilterSchema).optional()
    })
    .strict();

export const NestedEnumVariantTypeFilterSchema: z.ZodType<Prisma.NestedEnumVariantTypeFilter> =
  z
    .object({
      equals: z.lazy(() => VariantTypeSchema).optional(),
      in: z
        .lazy(() => VariantTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => VariantTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => VariantTypeSchema),
          z.lazy(() => NestedEnumVariantTypeFilterSchema)
        ])
        .optional()
    })
    .strict();

export const NestedDecimalNullableFilterSchema: z.ZodType<Prisma.NestedDecimalNullableFilter> =
  z
    .object({
      equals: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional()
        .nullable(),
      in: z
        .union([
          z.number().array(),
          z.string().array(),
          z.instanceof(Decimal).array(),
          z.instanceof(Prisma.Decimal).array(),
          DecimalJsLikeSchema.array()
        ])
        .refine(
          v =>
            Array.isArray(v) && (v as any[]).every(v => isValidDecimalInput(v)),
          { message: 'Must be a Decimal' }
        )
        .optional()
        .nullable(),
      notIn: z
        .union([
          z.number().array(),
          z.string().array(),
          z.instanceof(Decimal).array(),
          z.instanceof(Prisma.Decimal).array(),
          DecimalJsLikeSchema.array()
        ])
        .refine(
          v =>
            Array.isArray(v) && (v as any[]).every(v => isValidDecimalInput(v)),
          { message: 'Must be a Decimal' }
        )
        .optional()
        .nullable(),
      lt: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      lte: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      gt: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      gte: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      not: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema
            ])
            .refine(v => isValidDecimalInput(v), {
              message: 'Must be a Decimal'
            }),
          z.lazy(() => NestedDecimalNullableFilterSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const NestedEnumVariantTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumVariantTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => VariantTypeSchema).optional(),
      in: z
        .lazy(() => VariantTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => VariantTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => VariantTypeSchema),
          z.lazy(() => NestedEnumVariantTypeWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumVariantTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumVariantTypeFilterSchema).optional()
    })
    .strict();

export const NestedDecimalNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedDecimalNullableWithAggregatesFilter> =
  z
    .object({
      equals: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional()
        .nullable(),
      in: z
        .union([
          z.number().array(),
          z.string().array(),
          z.instanceof(Decimal).array(),
          z.instanceof(Prisma.Decimal).array(),
          DecimalJsLikeSchema.array()
        ])
        .refine(
          v =>
            Array.isArray(v) && (v as any[]).every(v => isValidDecimalInput(v)),
          { message: 'Must be a Decimal' }
        )
        .optional()
        .nullable(),
      notIn: z
        .union([
          z.number().array(),
          z.string().array(),
          z.instanceof(Decimal).array(),
          z.instanceof(Prisma.Decimal).array(),
          DecimalJsLikeSchema.array()
        ])
        .refine(
          v =>
            Array.isArray(v) && (v as any[]).every(v => isValidDecimalInput(v)),
          { message: 'Must be a Decimal' }
        )
        .optional()
        .nullable(),
      lt: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      lte: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      gt: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      gte: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      not: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema
            ])
            .refine(v => isValidDecimalInput(v), {
              message: 'Must be a Decimal'
            }),
          z.lazy(() => NestedDecimalNullableWithAggregatesFilterSchema)
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _avg: z.lazy(() => NestedDecimalNullableFilterSchema).optional(),
      _sum: z.lazy(() => NestedDecimalNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedDecimalNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedDecimalNullableFilterSchema).optional()
    })
    .strict();

export const NestedBoolNullableFilterSchema: z.ZodType<Prisma.NestedBoolNullableFilter> =
  z
    .object({
      equals: z.boolean().optional().nullable(),
      not: z
        .union([z.boolean(), z.lazy(() => NestedBoolNullableFilterSchema)])
        .optional()
        .nullable()
    })
    .strict();

export const NestedEnumUserRoleFilterSchema: z.ZodType<Prisma.NestedEnumUserRoleFilter> =
  z
    .object({
      equals: z.lazy(() => UserRoleSchema).optional(),
      in: z
        .lazy(() => UserRoleSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => UserRoleSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => NestedEnumUserRoleFilterSchema)
        ])
        .optional()
    })
    .strict();

export const NestedBoolNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedBoolNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.boolean().optional().nullable(),
      not: z
        .union([
          z.boolean(),
          z.lazy(() => NestedBoolNullableWithAggregatesFilterSchema)
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedBoolNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedBoolNullableFilterSchema).optional()
    })
    .strict();

export const NestedEnumUserRoleWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumUserRoleWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => UserRoleSchema).optional(),
      in: z
        .lazy(() => UserRoleSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => UserRoleSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => NestedEnumUserRoleWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumUserRoleFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumUserRoleFilterSchema).optional()
    })
    .strict();

export const NestedEnumConditionTypeFilterSchema: z.ZodType<Prisma.NestedEnumConditionTypeFilter> =
  z
    .object({
      equals: z.lazy(() => ConditionTypeSchema).optional(),
      in: z
        .lazy(() => ConditionTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ConditionTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ConditionTypeSchema),
          z.lazy(() => NestedEnumConditionTypeFilterSchema)
        ])
        .optional()
    })
    .strict();

export const NestedEnumConditionTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumConditionTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => ConditionTypeSchema).optional(),
      in: z
        .lazy(() => ConditionTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ConditionTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ConditionTypeSchema),
          z.lazy(() => NestedEnumConditionTypeWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumConditionTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumConditionTypeFilterSchema).optional()
    })
    .strict();

export const NestedEnumOperatorFilterSchema: z.ZodType<Prisma.NestedEnumOperatorFilter> =
  z
    .object({
      equals: z.lazy(() => OperatorSchema).optional(),
      in: z
        .lazy(() => OperatorSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => OperatorSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => OperatorSchema),
          z.lazy(() => NestedEnumOperatorFilterSchema)
        ])
        .optional()
    })
    .strict();

export const NestedEnumOperatorWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumOperatorWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => OperatorSchema).optional(),
      in: z
        .lazy(() => OperatorSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => OperatorSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => OperatorSchema),
          z.lazy(() => NestedEnumOperatorWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumOperatorFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumOperatorFilterSchema).optional()
    })
    .strict();

export const NestedEnumWorkflowStateStatusFilterSchema: z.ZodType<Prisma.NestedEnumWorkflowStateStatusFilter> =
  z
    .object({
      equals: z.lazy(() => WorkflowStateStatusSchema).optional(),
      in: z
        .lazy(() => WorkflowStateStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => WorkflowStateStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => WorkflowStateStatusSchema),
          z.lazy(() => NestedEnumWorkflowStateStatusFilterSchema)
        ])
        .optional()
    })
    .strict();

export const NestedEnumWorkflowStateStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumWorkflowStateStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => WorkflowStateStatusSchema).optional(),
      in: z
        .lazy(() => WorkflowStateStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => WorkflowStateStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => WorkflowStateStatusSchema),
          z.lazy(() => NestedEnumWorkflowStateStatusWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumWorkflowStateStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumWorkflowStateStatusFilterSchema).optional()
    })
    .strict();

export const NestedEnumExecutionStatusFilterSchema: z.ZodType<Prisma.NestedEnumExecutionStatusFilter> =
  z
    .object({
      equals: z.lazy(() => ExecutionStatusSchema).optional(),
      in: z
        .lazy(() => ExecutionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ExecutionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ExecutionStatusSchema),
          z.lazy(() => NestedEnumExecutionStatusFilterSchema)
        ])
        .optional()
    })
    .strict();

export const NestedEnumExecutionStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumExecutionStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => ExecutionStatusSchema).optional(),
      in: z
        .lazy(() => ExecutionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ExecutionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ExecutionStatusSchema),
          z.lazy(() => NestedEnumExecutionStatusWithAggregatesFilterSchema)
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumExecutionStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumExecutionStatusFilterSchema).optional()
    })
    .strict();

export const UserCreateWithoutTwoFactorConfirmationInputSchema: z.ZodType<Prisma.UserCreateWithoutTwoFactorConfirmationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutTwoFactorConfirmationInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutTwoFactorConfirmationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutTwoFactorConfirmationInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutTwoFactorConfirmationInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutTwoFactorConfirmationInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutTwoFactorConfirmationInputSchema)
      ])
    })
    .strict();

export const UserUpsertWithoutTwoFactorConfirmationInputSchema: z.ZodType<Prisma.UserUpsertWithoutTwoFactorConfirmationInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutTwoFactorConfirmationInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutTwoFactorConfirmationInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutTwoFactorConfirmationInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutTwoFactorConfirmationInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutTwoFactorConfirmationInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutTwoFactorConfirmationInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutTwoFactorConfirmationInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutTwoFactorConfirmationInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutTwoFactorConfirmationInputSchema: z.ZodType<Prisma.UserUpdateWithoutTwoFactorConfirmationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutTwoFactorConfirmationInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutTwoFactorConfirmationInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserCreateWithoutAccountsInputSchema: z.ZodType<Prisma.UserCreateWithoutAccountsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutAccountsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutAccountsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutAccountsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutAccountsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutAccountsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutAccountsInputSchema)
      ])
    })
    .strict();

export const UserUpsertWithoutAccountsInputSchema: z.ZodType<Prisma.UserUpsertWithoutAccountsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutAccountsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutAccountsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutAccountsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutAccountsInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutAccountsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutAccountsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutAccountsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutAccountsInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutAccountsInputSchema: z.ZodType<Prisma.UserUpdateWithoutAccountsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutAccountsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutAccountsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserCreateWithoutSessionsInputSchema: z.ZodType<Prisma.UserCreateWithoutSessionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutSessionsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutSessionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutSessionsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutSessionsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutSessionsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutSessionsInputSchema)
      ])
    })
    .strict();

export const UserUpsertWithoutSessionsInputSchema: z.ZodType<Prisma.UserUpsertWithoutSessionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutSessionsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutSessionsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutSessionsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutSessionsInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutSessionsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutSessionsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutSessionsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutSessionsInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutSessionsInputSchema: z.ZodType<Prisma.UserUpdateWithoutSessionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutSessionsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutSessionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserCreateWithoutAuthenticatorInputSchema: z.ZodType<Prisma.UserCreateWithoutAuthenticatorInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutAuthenticatorInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutAuthenticatorInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutAuthenticatorInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutAuthenticatorInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutAuthenticatorInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutAuthenticatorInputSchema)
      ])
    })
    .strict();

export const UserUpsertWithoutAuthenticatorInputSchema: z.ZodType<Prisma.UserUpsertWithoutAuthenticatorInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutAuthenticatorInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutAuthenticatorInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutAuthenticatorInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutAuthenticatorInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutAuthenticatorInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutAuthenticatorInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutAuthenticatorInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutAuthenticatorInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutAuthenticatorInputSchema: z.ZodType<Prisma.UserUpdateWithoutAuthenticatorInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutAuthenticatorInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutAuthenticatorInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserCreateWithoutCustomerInputSchema: z.ZodType<Prisma.UserCreateWithoutCustomerInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutCustomerInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutCustomerInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutCustomerInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutCustomerInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutCustomerInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutCustomerInputSchema)
      ])
    })
    .strict();

export const UserUpsertWithoutCustomerInputSchema: z.ZodType<Prisma.UserUpsertWithoutCustomerInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutCustomerInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutCustomerInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutCustomerInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutCustomerInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutCustomerInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutCustomerInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutCustomerInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutCustomerInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutCustomerInputSchema: z.ZodType<Prisma.UserUpdateWithoutCustomerInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutCustomerInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutCustomerInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const PriceCreateWithoutProductInputSchema: z.ZodType<Prisma.PriceCreateWithoutProductInput> =
  z
    .object({
      id: z.string(),
      active: z.boolean(),
      description: z.string(),
      unit_amount: z.number().int().optional().nullable(),
      currency: z.string(),
      type: z.lazy(() => PricingTypeSchema),
      interval: z
        .lazy(() => PricingPlanIntervalSchema)
        .optional()
        .nullable(),
      interval_count: z.number().int().optional().nullable(),
      trial_period_days: z.number().int().optional().nullable(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutPriceInputSchema)
        .optional()
    })
    .strict();

export const PriceUncheckedCreateWithoutProductInputSchema: z.ZodType<Prisma.PriceUncheckedCreateWithoutProductInput> =
  z
    .object({
      id: z.string(),
      active: z.boolean(),
      description: z.string(),
      unit_amount: z.number().int().optional().nullable(),
      currency: z.string(),
      type: z.lazy(() => PricingTypeSchema),
      interval: z
        .lazy(() => PricingPlanIntervalSchema)
        .optional()
        .nullable(),
      interval_count: z.number().int().optional().nullable(),
      trial_period_days: z.number().int().optional().nullable(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      subscriptions: z
        .lazy(
          () => SubscriptionUncheckedCreateNestedManyWithoutPriceInputSchema
        )
        .optional()
    })
    .strict();

export const PriceCreateOrConnectWithoutProductInputSchema: z.ZodType<Prisma.PriceCreateOrConnectWithoutProductInput> =
  z
    .object({
      where: z.lazy(() => PriceWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => PriceCreateWithoutProductInputSchema),
        z.lazy(() => PriceUncheckedCreateWithoutProductInputSchema)
      ])
    })
    .strict();

export const PriceCreateManyProductInputEnvelopeSchema: z.ZodType<Prisma.PriceCreateManyProductInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => PriceCreateManyProductInputSchema),
        z.lazy(() => PriceCreateManyProductInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const PriceUpsertWithWhereUniqueWithoutProductInputSchema: z.ZodType<Prisma.PriceUpsertWithWhereUniqueWithoutProductInput> =
  z
    .object({
      where: z.lazy(() => PriceWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => PriceUpdateWithoutProductInputSchema),
        z.lazy(() => PriceUncheckedUpdateWithoutProductInputSchema)
      ]),
      create: z.union([
        z.lazy(() => PriceCreateWithoutProductInputSchema),
        z.lazy(() => PriceUncheckedCreateWithoutProductInputSchema)
      ])
    })
    .strict();

export const PriceUpdateWithWhereUniqueWithoutProductInputSchema: z.ZodType<Prisma.PriceUpdateWithWhereUniqueWithoutProductInput> =
  z
    .object({
      where: z.lazy(() => PriceWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => PriceUpdateWithoutProductInputSchema),
        z.lazy(() => PriceUncheckedUpdateWithoutProductInputSchema)
      ])
    })
    .strict();

export const PriceUpdateManyWithWhereWithoutProductInputSchema: z.ZodType<Prisma.PriceUpdateManyWithWhereWithoutProductInput> =
  z
    .object({
      where: z.lazy(() => PriceScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => PriceUpdateManyMutationInputSchema),
        z.lazy(() => PriceUncheckedUpdateManyWithoutProductInputSchema)
      ])
    })
    .strict();

export const PriceScalarWhereInputSchema: z.ZodType<Prisma.PriceScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => PriceScalarWhereInputSchema),
          z.lazy(() => PriceScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => PriceScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => PriceScalarWhereInputSchema),
          z.lazy(() => PriceScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      active: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      description: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      unit_amount: z
        .union([z.lazy(() => IntNullableFilterSchema), z.number()])
        .optional()
        .nullable(),
      currency: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      type: z
        .union([
          z.lazy(() => EnumPricingTypeFilterSchema),
          z.lazy(() => PricingTypeSchema)
        ])
        .optional(),
      interval: z
        .union([
          z.lazy(() => EnumPricingPlanIntervalNullableFilterSchema),
          z.lazy(() => PricingPlanIntervalSchema)
        ])
        .optional()
        .nullable(),
      interval_count: z
        .union([z.lazy(() => IntNullableFilterSchema), z.number()])
        .optional()
        .nullable(),
      trial_period_days: z
        .union([z.lazy(() => IntNullableFilterSchema), z.number()])
        .optional()
        .nullable(),
      metadata: z.lazy(() => JsonFilterSchema).optional(),
      productId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const SubscriptionCreateWithoutPriceInputSchema: z.ZodType<Prisma.SubscriptionCreateWithoutPriceInput> =
  z
    .object({
      id: z.string(),
      status: z.lazy(() => SubscriptionStatusSchema),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      quantity: z.number().int(),
      cancel_at_period_end: z.boolean(),
      created: z.coerce.date().optional(),
      current_period_start: z.coerce.date().optional(),
      current_period_end: z.coerce.date().optional(),
      ended_at: z.coerce.date().optional().nullable(),
      cancel_at: z.coerce.date().optional().nullable(),
      canceled_at: z.coerce.date().optional().nullable(),
      trial_start: z.coerce.date().optional().nullable(),
      trial_end: z.coerce.date().optional().nullable(),
      user: z.lazy(() => UserCreateNestedOneWithoutSubscriptionsInputSchema)
    })
    .strict();

export const SubscriptionUncheckedCreateWithoutPriceInputSchema: z.ZodType<Prisma.SubscriptionUncheckedCreateWithoutPriceInput> =
  z
    .object({
      id: z.string(),
      status: z.lazy(() => SubscriptionStatusSchema),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      quantity: z.number().int(),
      cancel_at_period_end: z.boolean(),
      created: z.coerce.date().optional(),
      current_period_start: z.coerce.date().optional(),
      current_period_end: z.coerce.date().optional(),
      ended_at: z.coerce.date().optional().nullable(),
      cancel_at: z.coerce.date().optional().nullable(),
      canceled_at: z.coerce.date().optional().nullable(),
      trial_start: z.coerce.date().optional().nullable(),
      trial_end: z.coerce.date().optional().nullable(),
      userId: z.string()
    })
    .strict();

export const SubscriptionCreateOrConnectWithoutPriceInputSchema: z.ZodType<Prisma.SubscriptionCreateOrConnectWithoutPriceInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => SubscriptionCreateWithoutPriceInputSchema),
        z.lazy(() => SubscriptionUncheckedCreateWithoutPriceInputSchema)
      ])
    })
    .strict();

export const SubscriptionCreateManyPriceInputEnvelopeSchema: z.ZodType<Prisma.SubscriptionCreateManyPriceInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => SubscriptionCreateManyPriceInputSchema),
        z.lazy(() => SubscriptionCreateManyPriceInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ProductCreateWithoutPricesInputSchema: z.ZodType<Prisma.ProductCreateWithoutPricesInput> =
  z
    .object({
      id: z.string(),
      active: z.boolean(),
      name: z.string(),
      description: z.string(),
      image: z.string(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional()
    })
    .strict();

export const ProductUncheckedCreateWithoutPricesInputSchema: z.ZodType<Prisma.ProductUncheckedCreateWithoutPricesInput> =
  z
    .object({
      id: z.string(),
      active: z.boolean(),
      name: z.string(),
      description: z.string(),
      image: z.string(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional()
    })
    .strict();

export const ProductCreateOrConnectWithoutPricesInputSchema: z.ZodType<Prisma.ProductCreateOrConnectWithoutPricesInput> =
  z
    .object({
      where: z.lazy(() => ProductWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ProductCreateWithoutPricesInputSchema),
        z.lazy(() => ProductUncheckedCreateWithoutPricesInputSchema)
      ])
    })
    .strict();

export const SubscriptionUpsertWithWhereUniqueWithoutPriceInputSchema: z.ZodType<Prisma.SubscriptionUpsertWithWhereUniqueWithoutPriceInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => SubscriptionUpdateWithoutPriceInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateWithoutPriceInputSchema)
      ]),
      create: z.union([
        z.lazy(() => SubscriptionCreateWithoutPriceInputSchema),
        z.lazy(() => SubscriptionUncheckedCreateWithoutPriceInputSchema)
      ])
    })
    .strict();

export const SubscriptionUpdateWithWhereUniqueWithoutPriceInputSchema: z.ZodType<Prisma.SubscriptionUpdateWithWhereUniqueWithoutPriceInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => SubscriptionUpdateWithoutPriceInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateWithoutPriceInputSchema)
      ])
    })
    .strict();

export const SubscriptionUpdateManyWithWhereWithoutPriceInputSchema: z.ZodType<Prisma.SubscriptionUpdateManyWithWhereWithoutPriceInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => SubscriptionUpdateManyMutationInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateManyWithoutPriceInputSchema)
      ])
    })
    .strict();

export const SubscriptionScalarWhereInputSchema: z.ZodType<Prisma.SubscriptionScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => SubscriptionScalarWhereInputSchema),
          z.lazy(() => SubscriptionScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => SubscriptionScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => SubscriptionScalarWhereInputSchema),
          z.lazy(() => SubscriptionScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      status: z
        .union([
          z.lazy(() => EnumSubscriptionStatusFilterSchema),
          z.lazy(() => SubscriptionStatusSchema)
        ])
        .optional(),
      metadata: z.lazy(() => JsonFilterSchema).optional(),
      quantity: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      cancel_at_period_end: z
        .union([z.lazy(() => BoolFilterSchema), z.boolean()])
        .optional(),
      created: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      current_period_start: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      current_period_end: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      ended_at: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      cancel_at: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      canceled_at: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      trial_start: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      trial_end: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      priceId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional()
    })
    .strict();

export const ProductUpsertWithoutPricesInputSchema: z.ZodType<Prisma.ProductUpsertWithoutPricesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ProductUpdateWithoutPricesInputSchema),
        z.lazy(() => ProductUncheckedUpdateWithoutPricesInputSchema)
      ]),
      create: z.union([
        z.lazy(() => ProductCreateWithoutPricesInputSchema),
        z.lazy(() => ProductUncheckedCreateWithoutPricesInputSchema)
      ]),
      where: z.lazy(() => ProductWhereInputSchema).optional()
    })
    .strict();

export const ProductUpdateToOneWithWhereWithoutPricesInputSchema: z.ZodType<Prisma.ProductUpdateToOneWithWhereWithoutPricesInput> =
  z
    .object({
      where: z.lazy(() => ProductWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ProductUpdateWithoutPricesInputSchema),
        z.lazy(() => ProductUncheckedUpdateWithoutPricesInputSchema)
      ])
    })
    .strict();

export const ProductUpdateWithoutPricesInputSchema: z.ZodType<Prisma.ProductUpdateWithoutPricesInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional()
    })
    .strict();

export const ProductUncheckedUpdateWithoutPricesInputSchema: z.ZodType<Prisma.ProductUncheckedUpdateWithoutPricesInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional()
    })
    .strict();

export const PriceCreateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.PriceCreateWithoutSubscriptionsInput> =
  z
    .object({
      id: z.string(),
      active: z.boolean(),
      description: z.string(),
      unit_amount: z.number().int().optional().nullable(),
      currency: z.string(),
      type: z.lazy(() => PricingTypeSchema),
      interval: z
        .lazy(() => PricingPlanIntervalSchema)
        .optional()
        .nullable(),
      interval_count: z.number().int().optional().nullable(),
      trial_period_days: z.number().int().optional().nullable(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      product: z.lazy(() => ProductCreateNestedOneWithoutPricesInputSchema)
    })
    .strict();

export const PriceUncheckedCreateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.PriceUncheckedCreateWithoutSubscriptionsInput> =
  z
    .object({
      id: z.string(),
      active: z.boolean(),
      description: z.string(),
      unit_amount: z.number().int().optional().nullable(),
      currency: z.string(),
      type: z.lazy(() => PricingTypeSchema),
      interval: z
        .lazy(() => PricingPlanIntervalSchema)
        .optional()
        .nullable(),
      interval_count: z.number().int().optional().nullable(),
      trial_period_days: z.number().int().optional().nullable(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      productId: z.string()
    })
    .strict();

export const PriceCreateOrConnectWithoutSubscriptionsInputSchema: z.ZodType<Prisma.PriceCreateOrConnectWithoutSubscriptionsInput> =
  z
    .object({
      where: z.lazy(() => PriceWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => PriceCreateWithoutSubscriptionsInputSchema),
        z.lazy(() => PriceUncheckedCreateWithoutSubscriptionsInputSchema)
      ])
    })
    .strict();

export const UserCreateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.UserCreateWithoutSubscriptionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutSubscriptionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutSubscriptionsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutSubscriptionsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutSubscriptionsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutSubscriptionsInputSchema)
      ])
    })
    .strict();

export const PriceUpsertWithoutSubscriptionsInputSchema: z.ZodType<Prisma.PriceUpsertWithoutSubscriptionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => PriceUpdateWithoutSubscriptionsInputSchema),
        z.lazy(() => PriceUncheckedUpdateWithoutSubscriptionsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => PriceCreateWithoutSubscriptionsInputSchema),
        z.lazy(() => PriceUncheckedCreateWithoutSubscriptionsInputSchema)
      ]),
      where: z.lazy(() => PriceWhereInputSchema).optional()
    })
    .strict();

export const PriceUpdateToOneWithWhereWithoutSubscriptionsInputSchema: z.ZodType<Prisma.PriceUpdateToOneWithWhereWithoutSubscriptionsInput> =
  z
    .object({
      where: z.lazy(() => PriceWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => PriceUpdateWithoutSubscriptionsInputSchema),
        z.lazy(() => PriceUncheckedUpdateWithoutSubscriptionsInputSchema)
      ])
    })
    .strict();

export const PriceUpdateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.PriceUpdateWithoutSubscriptionsInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      unit_amount: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => PricingTypeSchema),
          z.lazy(() => EnumPricingTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      interval: z
        .union([
          z.lazy(() => PricingPlanIntervalSchema),
          z.lazy(
            () =>
              NullableEnumPricingPlanIntervalFieldUpdateOperationsInputSchema
          )
        ])
        .optional()
        .nullable(),
      interval_count: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_period_days: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      product: z
        .lazy(() => ProductUpdateOneRequiredWithoutPricesNestedInputSchema)
        .optional()
    })
    .strict();

export const PriceUncheckedUpdateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.PriceUncheckedUpdateWithoutSubscriptionsInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      unit_amount: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => PricingTypeSchema),
          z.lazy(() => EnumPricingTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      interval: z
        .union([
          z.lazy(() => PricingPlanIntervalSchema),
          z.lazy(
            () =>
              NullableEnumPricingPlanIntervalFieldUpdateOperationsInputSchema
          )
        ])
        .optional()
        .nullable(),
      interval_count: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_period_days: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      productId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserUpsertWithoutSubscriptionsInputSchema: z.ZodType<Prisma.UserUpsertWithoutSubscriptionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutSubscriptionsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutSubscriptionsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutSubscriptionsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutSubscriptionsInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutSubscriptionsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutSubscriptionsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutSubscriptionsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutSubscriptionsInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.UserUpdateWithoutSubscriptionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutSubscriptionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const SiteCreateWithoutFeedInputSchema: z.ZodType<Prisma.SiteCreateWithoutFeedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      display_name: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      font: z.string().optional(),
      image: z.string().optional().nullable(),
      imageBlurhash: z.string().optional().nullable(),
      subdomain: z.string().optional().nullable(),
      customDomain: z.string().optional().nullable(),
      message404: z.string().optional().nullable(),
      background: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutSitesInputSchema),
      blocks: z
        .lazy(() => BlockCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      subscribers: z
        .lazy(() => SubscriberCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      likes: z.lazy(() => LikeCreateNestedManyWithoutSiteInputSchema).optional()
    })
    .strict();

export const SiteUncheckedCreateWithoutFeedInputSchema: z.ZodType<Prisma.SiteUncheckedCreateWithoutFeedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      display_name: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      font: z.string().optional(),
      image: z.string().optional().nullable(),
      imageBlurhash: z.string().optional().nullable(),
      subdomain: z.string().optional().nullable(),
      customDomain: z.string().optional().nullable(),
      message404: z.string().optional().nullable(),
      background: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string(),
      blocks: z
        .lazy(() => BlockUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      subscribers: z
        .lazy(() => SubscriberUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional()
    })
    .strict();

export const SiteCreateOrConnectWithoutFeedInputSchema: z.ZodType<Prisma.SiteCreateOrConnectWithoutFeedInput> =
  z
    .object({
      where: z.lazy(() => SiteWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => SiteCreateWithoutFeedInputSchema),
        z.lazy(() => SiteUncheckedCreateWithoutFeedInputSchema)
      ])
    })
    .strict();

export const UserCreateWithoutFeedInputSchema: z.ZodType<Prisma.UserCreateWithoutFeedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutFeedInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutFeedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutFeedInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutFeedInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutFeedInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutFeedInputSchema)
      ])
    })
    .strict();

export const CommentCreateWithoutFeedInputSchema: z.ZodType<Prisma.CommentCreateWithoutFeedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      content: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutCommentsInputSchema)
    })
    .strict();

export const CommentUncheckedCreateWithoutFeedInputSchema: z.ZodType<Prisma.CommentUncheckedCreateWithoutFeedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      content: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string()
    })
    .strict();

export const CommentCreateOrConnectWithoutFeedInputSchema: z.ZodType<Prisma.CommentCreateOrConnectWithoutFeedInput> =
  z
    .object({
      where: z.lazy(() => CommentWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CommentCreateWithoutFeedInputSchema),
        z.lazy(() => CommentUncheckedCreateWithoutFeedInputSchema)
      ])
    })
    .strict();

export const CommentCreateManyFeedInputEnvelopeSchema: z.ZodType<Prisma.CommentCreateManyFeedInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => CommentCreateManyFeedInputSchema),
        z.lazy(() => CommentCreateManyFeedInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const LikeCreateWithoutFeedInputSchema: z.ZodType<Prisma.LikeCreateWithoutFeedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      ip: z.string(),
      createdAt: z.coerce.date().optional(),
      site: z.lazy(() => SiteCreateNestedOneWithoutLikesInputSchema),
      user: z.lazy(() => UserCreateNestedOneWithoutLikesInputSchema).optional()
    })
    .strict();

export const LikeUncheckedCreateWithoutFeedInputSchema: z.ZodType<Prisma.LikeUncheckedCreateWithoutFeedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      ip: z.string(),
      createdAt: z.coerce.date().optional(),
      siteId: z.string(),
      userId: z.string().optional().nullable()
    })
    .strict();

export const LikeCreateOrConnectWithoutFeedInputSchema: z.ZodType<Prisma.LikeCreateOrConnectWithoutFeedInput> =
  z
    .object({
      where: z.lazy(() => LikeWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => LikeCreateWithoutFeedInputSchema),
        z.lazy(() => LikeUncheckedCreateWithoutFeedInputSchema)
      ])
    })
    .strict();

export const LikeCreateManyFeedInputEnvelopeSchema: z.ZodType<Prisma.LikeCreateManyFeedInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => LikeCreateManyFeedInputSchema),
        z.lazy(() => LikeCreateManyFeedInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const SiteUpsertWithoutFeedInputSchema: z.ZodType<Prisma.SiteUpsertWithoutFeedInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => SiteUpdateWithoutFeedInputSchema),
        z.lazy(() => SiteUncheckedUpdateWithoutFeedInputSchema)
      ]),
      create: z.union([
        z.lazy(() => SiteCreateWithoutFeedInputSchema),
        z.lazy(() => SiteUncheckedCreateWithoutFeedInputSchema)
      ]),
      where: z.lazy(() => SiteWhereInputSchema).optional()
    })
    .strict();

export const SiteUpdateToOneWithWhereWithoutFeedInputSchema: z.ZodType<Prisma.SiteUpdateToOneWithWhereWithoutFeedInput> =
  z
    .object({
      where: z.lazy(() => SiteWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => SiteUpdateWithoutFeedInputSchema),
        z.lazy(() => SiteUncheckedUpdateWithoutFeedInputSchema)
      ])
    })
    .strict();

export const SiteUpdateWithoutFeedInputSchema: z.ZodType<Prisma.SiteUpdateWithoutFeedInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      display_name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      font: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      imageBlurhash: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subdomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      customDomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      message404: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      background: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutSitesNestedInputSchema)
        .optional(),
      blocks: z
        .lazy(() => BlockUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      subscribers: z
        .lazy(() => SubscriberUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      likes: z.lazy(() => LikeUpdateManyWithoutSiteNestedInputSchema).optional()
    })
    .strict();

export const SiteUncheckedUpdateWithoutFeedInputSchema: z.ZodType<Prisma.SiteUncheckedUpdateWithoutFeedInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      display_name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      font: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      imageBlurhash: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subdomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      customDomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      message404: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      background: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blocks: z
        .lazy(() => BlockUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      subscribers: z
        .lazy(() => SubscriberUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUpsertWithoutFeedInputSchema: z.ZodType<Prisma.UserUpsertWithoutFeedInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutFeedInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutFeedInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutFeedInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutFeedInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutFeedInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutFeedInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutFeedInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutFeedInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutFeedInputSchema: z.ZodType<Prisma.UserUpdateWithoutFeedInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutFeedInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutFeedInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const CommentUpsertWithWhereUniqueWithoutFeedInputSchema: z.ZodType<Prisma.CommentUpsertWithWhereUniqueWithoutFeedInput> =
  z
    .object({
      where: z.lazy(() => CommentWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => CommentUpdateWithoutFeedInputSchema),
        z.lazy(() => CommentUncheckedUpdateWithoutFeedInputSchema)
      ]),
      create: z.union([
        z.lazy(() => CommentCreateWithoutFeedInputSchema),
        z.lazy(() => CommentUncheckedCreateWithoutFeedInputSchema)
      ])
    })
    .strict();

export const CommentUpdateWithWhereUniqueWithoutFeedInputSchema: z.ZodType<Prisma.CommentUpdateWithWhereUniqueWithoutFeedInput> =
  z
    .object({
      where: z.lazy(() => CommentWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => CommentUpdateWithoutFeedInputSchema),
        z.lazy(() => CommentUncheckedUpdateWithoutFeedInputSchema)
      ])
    })
    .strict();

export const CommentUpdateManyWithWhereWithoutFeedInputSchema: z.ZodType<Prisma.CommentUpdateManyWithWhereWithoutFeedInput> =
  z
    .object({
      where: z.lazy(() => CommentScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => CommentUpdateManyMutationInputSchema),
        z.lazy(() => CommentUncheckedUpdateManyWithoutFeedInputSchema)
      ])
    })
    .strict();

export const CommentScalarWhereInputSchema: z.ZodType<Prisma.CommentScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CommentScalarWhereInputSchema),
          z.lazy(() => CommentScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => CommentScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CommentScalarWhereInputSchema),
          z.lazy(() => CommentScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      content: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      feedId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional()
    })
    .strict();

export const LikeUpsertWithWhereUniqueWithoutFeedInputSchema: z.ZodType<Prisma.LikeUpsertWithWhereUniqueWithoutFeedInput> =
  z
    .object({
      where: z.lazy(() => LikeWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => LikeUpdateWithoutFeedInputSchema),
        z.lazy(() => LikeUncheckedUpdateWithoutFeedInputSchema)
      ]),
      create: z.union([
        z.lazy(() => LikeCreateWithoutFeedInputSchema),
        z.lazy(() => LikeUncheckedCreateWithoutFeedInputSchema)
      ])
    })
    .strict();

export const LikeUpdateWithWhereUniqueWithoutFeedInputSchema: z.ZodType<Prisma.LikeUpdateWithWhereUniqueWithoutFeedInput> =
  z
    .object({
      where: z.lazy(() => LikeWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => LikeUpdateWithoutFeedInputSchema),
        z.lazy(() => LikeUncheckedUpdateWithoutFeedInputSchema)
      ])
    })
    .strict();

export const LikeUpdateManyWithWhereWithoutFeedInputSchema: z.ZodType<Prisma.LikeUpdateManyWithWhereWithoutFeedInput> =
  z
    .object({
      where: z.lazy(() => LikeScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => LikeUpdateManyMutationInputSchema),
        z.lazy(() => LikeUncheckedUpdateManyWithoutFeedInputSchema)
      ])
    })
    .strict();

export const LikeScalarWhereInputSchema: z.ZodType<Prisma.LikeScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => LikeScalarWhereInputSchema),
          z.lazy(() => LikeScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => LikeScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => LikeScalarWhereInputSchema),
          z.lazy(() => LikeScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      ip: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      siteId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      userId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      feedId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable()
    })
    .strict();

export const FeedCreateWithoutCommentsInputSchema: z.ZodType<Prisma.FeedCreateWithoutCommentsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => FeedTypeSchema).optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      site: z.lazy(() => SiteCreateNestedOneWithoutFeedInputSchema),
      user: z.lazy(() => UserCreateNestedOneWithoutFeedInputSchema),
      likes: z.lazy(() => LikeCreateNestedManyWithoutFeedInputSchema).optional()
    })
    .strict();

export const FeedUncheckedCreateWithoutCommentsInputSchema: z.ZodType<Prisma.FeedUncheckedCreateWithoutCommentsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => FeedTypeSchema).optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      siteId: z.string(),
      userId: z.string(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutFeedInputSchema)
        .optional()
    })
    .strict();

export const FeedCreateOrConnectWithoutCommentsInputSchema: z.ZodType<Prisma.FeedCreateOrConnectWithoutCommentsInput> =
  z
    .object({
      where: z.lazy(() => FeedWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => FeedCreateWithoutCommentsInputSchema),
        z.lazy(() => FeedUncheckedCreateWithoutCommentsInputSchema)
      ])
    })
    .strict();

export const UserCreateWithoutCommentsInputSchema: z.ZodType<Prisma.UserCreateWithoutCommentsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutCommentsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutCommentsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutCommentsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutCommentsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutCommentsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutCommentsInputSchema)
      ])
    })
    .strict();

export const FeedUpsertWithoutCommentsInputSchema: z.ZodType<Prisma.FeedUpsertWithoutCommentsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => FeedUpdateWithoutCommentsInputSchema),
        z.lazy(() => FeedUncheckedUpdateWithoutCommentsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => FeedCreateWithoutCommentsInputSchema),
        z.lazy(() => FeedUncheckedCreateWithoutCommentsInputSchema)
      ]),
      where: z.lazy(() => FeedWhereInputSchema).optional()
    })
    .strict();

export const FeedUpdateToOneWithWhereWithoutCommentsInputSchema: z.ZodType<Prisma.FeedUpdateToOneWithWhereWithoutCommentsInput> =
  z
    .object({
      where: z.lazy(() => FeedWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => FeedUpdateWithoutCommentsInputSchema),
        z.lazy(() => FeedUncheckedUpdateWithoutCommentsInputSchema)
      ])
    })
    .strict();

export const FeedUpdateWithoutCommentsInputSchema: z.ZodType<Prisma.FeedUpdateWithoutCommentsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => FeedTypeSchema),
          z.lazy(() => EnumFeedTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      site: z
        .lazy(() => SiteUpdateOneRequiredWithoutFeedNestedInputSchema)
        .optional(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutFeedNestedInputSchema)
        .optional(),
      likes: z.lazy(() => LikeUpdateManyWithoutFeedNestedInputSchema).optional()
    })
    .strict();

export const FeedUncheckedUpdateWithoutCommentsInputSchema: z.ZodType<Prisma.FeedUncheckedUpdateWithoutCommentsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => FeedTypeSchema),
          z.lazy(() => EnumFeedTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutFeedNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUpsertWithoutCommentsInputSchema: z.ZodType<Prisma.UserUpsertWithoutCommentsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutCommentsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutCommentsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutCommentsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutCommentsInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutCommentsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutCommentsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutCommentsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutCommentsInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutCommentsInputSchema: z.ZodType<Prisma.UserUpdateWithoutCommentsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutCommentsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutCommentsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const NafDivisionCreateWithoutSectionInputSchema: z.ZodType<Prisma.NafDivisionCreateWithoutSectionInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      groups: z
        .lazy(() => NafGroupCreateNestedManyWithoutDivisionInputSchema)
        .optional()
    })
    .strict();

export const NafDivisionUncheckedCreateWithoutSectionInputSchema: z.ZodType<Prisma.NafDivisionUncheckedCreateWithoutSectionInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      groups: z
        .lazy(() => NafGroupUncheckedCreateNestedManyWithoutDivisionInputSchema)
        .optional()
    })
    .strict();

export const NafDivisionCreateOrConnectWithoutSectionInputSchema: z.ZodType<Prisma.NafDivisionCreateOrConnectWithoutSectionInput> =
  z
    .object({
      where: z.lazy(() => NafDivisionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => NafDivisionCreateWithoutSectionInputSchema),
        z.lazy(() => NafDivisionUncheckedCreateWithoutSectionInputSchema)
      ])
    })
    .strict();

export const NafDivisionCreateManySectionInputEnvelopeSchema: z.ZodType<Prisma.NafDivisionCreateManySectionInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => NafDivisionCreateManySectionInputSchema),
        z.lazy(() => NafDivisionCreateManySectionInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const NafDivisionUpsertWithWhereUniqueWithoutSectionInputSchema: z.ZodType<Prisma.NafDivisionUpsertWithWhereUniqueWithoutSectionInput> =
  z
    .object({
      where: z.lazy(() => NafDivisionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => NafDivisionUpdateWithoutSectionInputSchema),
        z.lazy(() => NafDivisionUncheckedUpdateWithoutSectionInputSchema)
      ]),
      create: z.union([
        z.lazy(() => NafDivisionCreateWithoutSectionInputSchema),
        z.lazy(() => NafDivisionUncheckedCreateWithoutSectionInputSchema)
      ])
    })
    .strict();

export const NafDivisionUpdateWithWhereUniqueWithoutSectionInputSchema: z.ZodType<Prisma.NafDivisionUpdateWithWhereUniqueWithoutSectionInput> =
  z
    .object({
      where: z.lazy(() => NafDivisionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => NafDivisionUpdateWithoutSectionInputSchema),
        z.lazy(() => NafDivisionUncheckedUpdateWithoutSectionInputSchema)
      ])
    })
    .strict();

export const NafDivisionUpdateManyWithWhereWithoutSectionInputSchema: z.ZodType<Prisma.NafDivisionUpdateManyWithWhereWithoutSectionInput> =
  z
    .object({
      where: z.lazy(() => NafDivisionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => NafDivisionUpdateManyMutationInputSchema),
        z.lazy(() => NafDivisionUncheckedUpdateManyWithoutSectionInputSchema)
      ])
    })
    .strict();

export const NafDivisionScalarWhereInputSchema: z.ZodType<Prisma.NafDivisionScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => NafDivisionScalarWhereInputSchema),
          z.lazy(() => NafDivisionScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => NafDivisionScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => NafDivisionScalarWhereInputSchema),
          z.lazy(() => NafDivisionScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      title: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      sectionId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const NafGroupCreateWithoutDivisionInputSchema: z.ZodType<Prisma.NafGroupCreateWithoutDivisionInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      classes: z
        .lazy(() => NafClassCreateNestedManyWithoutGroupInputSchema)
        .optional()
    })
    .strict();

export const NafGroupUncheckedCreateWithoutDivisionInputSchema: z.ZodType<Prisma.NafGroupUncheckedCreateWithoutDivisionInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      classes: z
        .lazy(() => NafClassUncheckedCreateNestedManyWithoutGroupInputSchema)
        .optional()
    })
    .strict();

export const NafGroupCreateOrConnectWithoutDivisionInputSchema: z.ZodType<Prisma.NafGroupCreateOrConnectWithoutDivisionInput> =
  z
    .object({
      where: z.lazy(() => NafGroupWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => NafGroupCreateWithoutDivisionInputSchema),
        z.lazy(() => NafGroupUncheckedCreateWithoutDivisionInputSchema)
      ])
    })
    .strict();

export const NafGroupCreateManyDivisionInputEnvelopeSchema: z.ZodType<Prisma.NafGroupCreateManyDivisionInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => NafGroupCreateManyDivisionInputSchema),
        z.lazy(() => NafGroupCreateManyDivisionInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const NafSectionCreateWithoutDivisionsInputSchema: z.ZodType<Prisma.NafSectionCreateWithoutDivisionsInput> =
  z
    .object({
      id: z.string(),
      title: z.string()
    })
    .strict();

export const NafSectionUncheckedCreateWithoutDivisionsInputSchema: z.ZodType<Prisma.NafSectionUncheckedCreateWithoutDivisionsInput> =
  z
    .object({
      id: z.string(),
      title: z.string()
    })
    .strict();

export const NafSectionCreateOrConnectWithoutDivisionsInputSchema: z.ZodType<Prisma.NafSectionCreateOrConnectWithoutDivisionsInput> =
  z
    .object({
      where: z.lazy(() => NafSectionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => NafSectionCreateWithoutDivisionsInputSchema),
        z.lazy(() => NafSectionUncheckedCreateWithoutDivisionsInputSchema)
      ])
    })
    .strict();

export const NafGroupUpsertWithWhereUniqueWithoutDivisionInputSchema: z.ZodType<Prisma.NafGroupUpsertWithWhereUniqueWithoutDivisionInput> =
  z
    .object({
      where: z.lazy(() => NafGroupWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => NafGroupUpdateWithoutDivisionInputSchema),
        z.lazy(() => NafGroupUncheckedUpdateWithoutDivisionInputSchema)
      ]),
      create: z.union([
        z.lazy(() => NafGroupCreateWithoutDivisionInputSchema),
        z.lazy(() => NafGroupUncheckedCreateWithoutDivisionInputSchema)
      ])
    })
    .strict();

export const NafGroupUpdateWithWhereUniqueWithoutDivisionInputSchema: z.ZodType<Prisma.NafGroupUpdateWithWhereUniqueWithoutDivisionInput> =
  z
    .object({
      where: z.lazy(() => NafGroupWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => NafGroupUpdateWithoutDivisionInputSchema),
        z.lazy(() => NafGroupUncheckedUpdateWithoutDivisionInputSchema)
      ])
    })
    .strict();

export const NafGroupUpdateManyWithWhereWithoutDivisionInputSchema: z.ZodType<Prisma.NafGroupUpdateManyWithWhereWithoutDivisionInput> =
  z
    .object({
      where: z.lazy(() => NafGroupScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => NafGroupUpdateManyMutationInputSchema),
        z.lazy(() => NafGroupUncheckedUpdateManyWithoutDivisionInputSchema)
      ])
    })
    .strict();

export const NafGroupScalarWhereInputSchema: z.ZodType<Prisma.NafGroupScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => NafGroupScalarWhereInputSchema),
          z.lazy(() => NafGroupScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => NafGroupScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => NafGroupScalarWhereInputSchema),
          z.lazy(() => NafGroupScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      title: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      divisionId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const NafSectionUpsertWithoutDivisionsInputSchema: z.ZodType<Prisma.NafSectionUpsertWithoutDivisionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => NafSectionUpdateWithoutDivisionsInputSchema),
        z.lazy(() => NafSectionUncheckedUpdateWithoutDivisionsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => NafSectionCreateWithoutDivisionsInputSchema),
        z.lazy(() => NafSectionUncheckedCreateWithoutDivisionsInputSchema)
      ]),
      where: z.lazy(() => NafSectionWhereInputSchema).optional()
    })
    .strict();

export const NafSectionUpdateToOneWithWhereWithoutDivisionsInputSchema: z.ZodType<Prisma.NafSectionUpdateToOneWithWhereWithoutDivisionsInput> =
  z
    .object({
      where: z.lazy(() => NafSectionWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => NafSectionUpdateWithoutDivisionsInputSchema),
        z.lazy(() => NafSectionUncheckedUpdateWithoutDivisionsInputSchema)
      ])
    })
    .strict();

export const NafSectionUpdateWithoutDivisionsInputSchema: z.ZodType<Prisma.NafSectionUpdateWithoutDivisionsInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const NafSectionUncheckedUpdateWithoutDivisionsInputSchema: z.ZodType<Prisma.NafSectionUncheckedUpdateWithoutDivisionsInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const NafClassCreateWithoutGroupInputSchema: z.ZodType<Prisma.NafClassCreateWithoutGroupInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      codes: z
        .lazy(() => NafCodeCreateNestedManyWithoutClassInputSchema)
        .optional()
    })
    .strict();

export const NafClassUncheckedCreateWithoutGroupInputSchema: z.ZodType<Prisma.NafClassUncheckedCreateWithoutGroupInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      codes: z
        .lazy(() => NafCodeUncheckedCreateNestedManyWithoutClassInputSchema)
        .optional()
    })
    .strict();

export const NafClassCreateOrConnectWithoutGroupInputSchema: z.ZodType<Prisma.NafClassCreateOrConnectWithoutGroupInput> =
  z
    .object({
      where: z.lazy(() => NafClassWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => NafClassCreateWithoutGroupInputSchema),
        z.lazy(() => NafClassUncheckedCreateWithoutGroupInputSchema)
      ])
    })
    .strict();

export const NafClassCreateManyGroupInputEnvelopeSchema: z.ZodType<Prisma.NafClassCreateManyGroupInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => NafClassCreateManyGroupInputSchema),
        z.lazy(() => NafClassCreateManyGroupInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const NafDivisionCreateWithoutGroupsInputSchema: z.ZodType<Prisma.NafDivisionCreateWithoutGroupsInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      section: z.lazy(
        () => NafSectionCreateNestedOneWithoutDivisionsInputSchema
      )
    })
    .strict();

export const NafDivisionUncheckedCreateWithoutGroupsInputSchema: z.ZodType<Prisma.NafDivisionUncheckedCreateWithoutGroupsInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      sectionId: z.string()
    })
    .strict();

export const NafDivisionCreateOrConnectWithoutGroupsInputSchema: z.ZodType<Prisma.NafDivisionCreateOrConnectWithoutGroupsInput> =
  z
    .object({
      where: z.lazy(() => NafDivisionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => NafDivisionCreateWithoutGroupsInputSchema),
        z.lazy(() => NafDivisionUncheckedCreateWithoutGroupsInputSchema)
      ])
    })
    .strict();

export const NafClassUpsertWithWhereUniqueWithoutGroupInputSchema: z.ZodType<Prisma.NafClassUpsertWithWhereUniqueWithoutGroupInput> =
  z
    .object({
      where: z.lazy(() => NafClassWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => NafClassUpdateWithoutGroupInputSchema),
        z.lazy(() => NafClassUncheckedUpdateWithoutGroupInputSchema)
      ]),
      create: z.union([
        z.lazy(() => NafClassCreateWithoutGroupInputSchema),
        z.lazy(() => NafClassUncheckedCreateWithoutGroupInputSchema)
      ])
    })
    .strict();

export const NafClassUpdateWithWhereUniqueWithoutGroupInputSchema: z.ZodType<Prisma.NafClassUpdateWithWhereUniqueWithoutGroupInput> =
  z
    .object({
      where: z.lazy(() => NafClassWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => NafClassUpdateWithoutGroupInputSchema),
        z.lazy(() => NafClassUncheckedUpdateWithoutGroupInputSchema)
      ])
    })
    .strict();

export const NafClassUpdateManyWithWhereWithoutGroupInputSchema: z.ZodType<Prisma.NafClassUpdateManyWithWhereWithoutGroupInput> =
  z
    .object({
      where: z.lazy(() => NafClassScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => NafClassUpdateManyMutationInputSchema),
        z.lazy(() => NafClassUncheckedUpdateManyWithoutGroupInputSchema)
      ])
    })
    .strict();

export const NafClassScalarWhereInputSchema: z.ZodType<Prisma.NafClassScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => NafClassScalarWhereInputSchema),
          z.lazy(() => NafClassScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => NafClassScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => NafClassScalarWhereInputSchema),
          z.lazy(() => NafClassScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      title: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      groupId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const NafDivisionUpsertWithoutGroupsInputSchema: z.ZodType<Prisma.NafDivisionUpsertWithoutGroupsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => NafDivisionUpdateWithoutGroupsInputSchema),
        z.lazy(() => NafDivisionUncheckedUpdateWithoutGroupsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => NafDivisionCreateWithoutGroupsInputSchema),
        z.lazy(() => NafDivisionUncheckedCreateWithoutGroupsInputSchema)
      ]),
      where: z.lazy(() => NafDivisionWhereInputSchema).optional()
    })
    .strict();

export const NafDivisionUpdateToOneWithWhereWithoutGroupsInputSchema: z.ZodType<Prisma.NafDivisionUpdateToOneWithWhereWithoutGroupsInput> =
  z
    .object({
      where: z.lazy(() => NafDivisionWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => NafDivisionUpdateWithoutGroupsInputSchema),
        z.lazy(() => NafDivisionUncheckedUpdateWithoutGroupsInputSchema)
      ])
    })
    .strict();

export const NafDivisionUpdateWithoutGroupsInputSchema: z.ZodType<Prisma.NafDivisionUpdateWithoutGroupsInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      section: z
        .lazy(
          () => NafSectionUpdateOneRequiredWithoutDivisionsNestedInputSchema
        )
        .optional()
    })
    .strict();

export const NafDivisionUncheckedUpdateWithoutGroupsInputSchema: z.ZodType<Prisma.NafDivisionUncheckedUpdateWithoutGroupsInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sectionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const NafCodeCreateWithoutClassInputSchema: z.ZodType<Prisma.NafCodeCreateWithoutClassInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      users: z.lazy(() => UserCreateNestedManyWithoutNafInputSchema).optional()
    })
    .strict();

export const NafCodeUncheckedCreateWithoutClassInputSchema: z.ZodType<Prisma.NafCodeUncheckedCreateWithoutClassInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      users: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutNafInputSchema)
        .optional()
    })
    .strict();

export const NafCodeCreateOrConnectWithoutClassInputSchema: z.ZodType<Prisma.NafCodeCreateOrConnectWithoutClassInput> =
  z
    .object({
      where: z.lazy(() => NafCodeWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => NafCodeCreateWithoutClassInputSchema),
        z.lazy(() => NafCodeUncheckedCreateWithoutClassInputSchema)
      ])
    })
    .strict();

export const NafCodeCreateManyClassInputEnvelopeSchema: z.ZodType<Prisma.NafCodeCreateManyClassInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => NafCodeCreateManyClassInputSchema),
        z.lazy(() => NafCodeCreateManyClassInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const NafGroupCreateWithoutClassesInputSchema: z.ZodType<Prisma.NafGroupCreateWithoutClassesInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      division: z.lazy(() => NafDivisionCreateNestedOneWithoutGroupsInputSchema)
    })
    .strict();

export const NafGroupUncheckedCreateWithoutClassesInputSchema: z.ZodType<Prisma.NafGroupUncheckedCreateWithoutClassesInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      divisionId: z.string()
    })
    .strict();

export const NafGroupCreateOrConnectWithoutClassesInputSchema: z.ZodType<Prisma.NafGroupCreateOrConnectWithoutClassesInput> =
  z
    .object({
      where: z.lazy(() => NafGroupWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => NafGroupCreateWithoutClassesInputSchema),
        z.lazy(() => NafGroupUncheckedCreateWithoutClassesInputSchema)
      ])
    })
    .strict();

export const NafCodeUpsertWithWhereUniqueWithoutClassInputSchema: z.ZodType<Prisma.NafCodeUpsertWithWhereUniqueWithoutClassInput> =
  z
    .object({
      where: z.lazy(() => NafCodeWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => NafCodeUpdateWithoutClassInputSchema),
        z.lazy(() => NafCodeUncheckedUpdateWithoutClassInputSchema)
      ]),
      create: z.union([
        z.lazy(() => NafCodeCreateWithoutClassInputSchema),
        z.lazy(() => NafCodeUncheckedCreateWithoutClassInputSchema)
      ])
    })
    .strict();

export const NafCodeUpdateWithWhereUniqueWithoutClassInputSchema: z.ZodType<Prisma.NafCodeUpdateWithWhereUniqueWithoutClassInput> =
  z
    .object({
      where: z.lazy(() => NafCodeWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => NafCodeUpdateWithoutClassInputSchema),
        z.lazy(() => NafCodeUncheckedUpdateWithoutClassInputSchema)
      ])
    })
    .strict();

export const NafCodeUpdateManyWithWhereWithoutClassInputSchema: z.ZodType<Prisma.NafCodeUpdateManyWithWhereWithoutClassInput> =
  z
    .object({
      where: z.lazy(() => NafCodeScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => NafCodeUpdateManyMutationInputSchema),
        z.lazy(() => NafCodeUncheckedUpdateManyWithoutClassInputSchema)
      ])
    })
    .strict();

export const NafCodeScalarWhereInputSchema: z.ZodType<Prisma.NafCodeScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => NafCodeScalarWhereInputSchema),
          z.lazy(() => NafCodeScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => NafCodeScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => NafCodeScalarWhereInputSchema),
          z.lazy(() => NafCodeScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      title: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      classId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const NafGroupUpsertWithoutClassesInputSchema: z.ZodType<Prisma.NafGroupUpsertWithoutClassesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => NafGroupUpdateWithoutClassesInputSchema),
        z.lazy(() => NafGroupUncheckedUpdateWithoutClassesInputSchema)
      ]),
      create: z.union([
        z.lazy(() => NafGroupCreateWithoutClassesInputSchema),
        z.lazy(() => NafGroupUncheckedCreateWithoutClassesInputSchema)
      ]),
      where: z.lazy(() => NafGroupWhereInputSchema).optional()
    })
    .strict();

export const NafGroupUpdateToOneWithWhereWithoutClassesInputSchema: z.ZodType<Prisma.NafGroupUpdateToOneWithWhereWithoutClassesInput> =
  z
    .object({
      where: z.lazy(() => NafGroupWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => NafGroupUpdateWithoutClassesInputSchema),
        z.lazy(() => NafGroupUncheckedUpdateWithoutClassesInputSchema)
      ])
    })
    .strict();

export const NafGroupUpdateWithoutClassesInputSchema: z.ZodType<Prisma.NafGroupUpdateWithoutClassesInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      division: z
        .lazy(() => NafDivisionUpdateOneRequiredWithoutGroupsNestedInputSchema)
        .optional()
    })
    .strict();

export const NafGroupUncheckedUpdateWithoutClassesInputSchema: z.ZodType<Prisma.NafGroupUncheckedUpdateWithoutClassesInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      divisionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const NafClassCreateWithoutCodesInputSchema: z.ZodType<Prisma.NafClassCreateWithoutCodesInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      group: z.lazy(() => NafGroupCreateNestedOneWithoutClassesInputSchema)
    })
    .strict();

export const NafClassUncheckedCreateWithoutCodesInputSchema: z.ZodType<Prisma.NafClassUncheckedCreateWithoutCodesInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      groupId: z.string()
    })
    .strict();

export const NafClassCreateOrConnectWithoutCodesInputSchema: z.ZodType<Prisma.NafClassCreateOrConnectWithoutCodesInput> =
  z
    .object({
      where: z.lazy(() => NafClassWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => NafClassCreateWithoutCodesInputSchema),
        z.lazy(() => NafClassUncheckedCreateWithoutCodesInputSchema)
      ])
    })
    .strict();

export const UserCreateWithoutNafInputSchema: z.ZodType<Prisma.UserCreateWithoutNafInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutNafInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutNafInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutNafInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutNafInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutNafInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutNafInputSchema)
      ])
    })
    .strict();

export const UserCreateManyNafInputEnvelopeSchema: z.ZodType<Prisma.UserCreateManyNafInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => UserCreateManyNafInputSchema),
        z.lazy(() => UserCreateManyNafInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const NafClassUpsertWithoutCodesInputSchema: z.ZodType<Prisma.NafClassUpsertWithoutCodesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => NafClassUpdateWithoutCodesInputSchema),
        z.lazy(() => NafClassUncheckedUpdateWithoutCodesInputSchema)
      ]),
      create: z.union([
        z.lazy(() => NafClassCreateWithoutCodesInputSchema),
        z.lazy(() => NafClassUncheckedCreateWithoutCodesInputSchema)
      ]),
      where: z.lazy(() => NafClassWhereInputSchema).optional()
    })
    .strict();

export const NafClassUpdateToOneWithWhereWithoutCodesInputSchema: z.ZodType<Prisma.NafClassUpdateToOneWithWhereWithoutCodesInput> =
  z
    .object({
      where: z.lazy(() => NafClassWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => NafClassUpdateWithoutCodesInputSchema),
        z.lazy(() => NafClassUncheckedUpdateWithoutCodesInputSchema)
      ])
    })
    .strict();

export const NafClassUpdateWithoutCodesInputSchema: z.ZodType<Prisma.NafClassUpdateWithoutCodesInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      group: z
        .lazy(() => NafGroupUpdateOneRequiredWithoutClassesNestedInputSchema)
        .optional()
    })
    .strict();

export const NafClassUncheckedUpdateWithoutCodesInputSchema: z.ZodType<Prisma.NafClassUncheckedUpdateWithoutCodesInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      groupId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserUpsertWithWhereUniqueWithoutNafInputSchema: z.ZodType<Prisma.UserUpsertWithWhereUniqueWithoutNafInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => UserUpdateWithoutNafInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutNafInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutNafInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutNafInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithWhereUniqueWithoutNafInputSchema: z.ZodType<Prisma.UserUpdateWithWhereUniqueWithoutNafInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => UserUpdateWithoutNafInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutNafInputSchema)
      ])
    })
    .strict();

export const UserUpdateManyWithWhereWithoutNafInputSchema: z.ZodType<Prisma.UserUpdateManyWithWhereWithoutNafInput> =
  z
    .object({
      where: z.lazy(() => UserScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => UserUpdateManyMutationInputSchema),
        z.lazy(() => UserUncheckedUpdateManyWithoutNafInputSchema)
      ])
    })
    .strict();

export const UserScalarWhereInputSchema: z.ZodType<Prisma.UserScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => UserScalarWhereInputSchema),
          z.lazy(() => UserScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => UserScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => UserScalarWhereInputSchema),
          z.lazy(() => UserScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      name: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      email: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      emailVerified: z
        .union([z.lazy(() => BoolFilterSchema), z.boolean()])
        .optional(),
      image: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([z.lazy(() => BoolFilterSchema), z.boolean()])
        .optional(),
      billing_address: z.lazy(() => JsonFilterSchema).optional(),
      payment_method: z.lazy(() => JsonFilterSchema).optional(),
      company: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      address: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      location: z.lazy(() => JsonNullableFilterSchema).optional(),
      postcode: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      city: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      phone: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      activity: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      bounced: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      affiliateRate: z
        .union([z.lazy(() => FloatNullableFilterSchema), z.number()])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([z.lazy(() => BoolNullableFilterSchema), z.boolean()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      role: z
        .union([
          z.lazy(() => EnumUserRoleFilterSchema),
          z.lazy(() => UserRoleSchema)
        ])
        .optional(),
      refererId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      codeNaf: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable()
    })
    .strict();

export const CampaignCreateWithoutOutboxesInputSchema: z.ZodType<Prisma.CampaignCreateWithoutOutboxesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => CampaignTypeSchema).optional(),
      smart: z.boolean().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      active: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      list: z
        .lazy(() => ListCreateNestedOneWithoutCampaignsInputSchema)
        .optional(),
      email: z.lazy(() => EmailCreateNestedOneWithoutCampaignsInputSchema)
    })
    .strict();

export const CampaignUncheckedCreateWithoutOutboxesInputSchema: z.ZodType<Prisma.CampaignUncheckedCreateWithoutOutboxesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => CampaignTypeSchema).optional(),
      smart: z.boolean().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      active: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      listId: z.string().optional().nullable(),
      emailId: z.string()
    })
    .strict();

export const CampaignCreateOrConnectWithoutOutboxesInputSchema: z.ZodType<Prisma.CampaignCreateOrConnectWithoutOutboxesInput> =
  z
    .object({
      where: z.lazy(() => CampaignWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CampaignCreateWithoutOutboxesInputSchema),
        z.lazy(() => CampaignUncheckedCreateWithoutOutboxesInputSchema)
      ])
    })
    .strict();

export const UserCreateWithoutOutboxInputSchema: z.ZodType<Prisma.UserCreateWithoutOutboxInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutOutboxInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutOutboxInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutOutboxInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutOutboxInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutOutboxInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutOutboxInputSchema)
      ])
    })
    .strict();

export const CampaignUpsertWithoutOutboxesInputSchema: z.ZodType<Prisma.CampaignUpsertWithoutOutboxesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => CampaignUpdateWithoutOutboxesInputSchema),
        z.lazy(() => CampaignUncheckedUpdateWithoutOutboxesInputSchema)
      ]),
      create: z.union([
        z.lazy(() => CampaignCreateWithoutOutboxesInputSchema),
        z.lazy(() => CampaignUncheckedCreateWithoutOutboxesInputSchema)
      ]),
      where: z.lazy(() => CampaignWhereInputSchema).optional()
    })
    .strict();

export const CampaignUpdateToOneWithWhereWithoutOutboxesInputSchema: z.ZodType<Prisma.CampaignUpdateToOneWithWhereWithoutOutboxesInput> =
  z
    .object({
      where: z.lazy(() => CampaignWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => CampaignUpdateWithoutOutboxesInputSchema),
        z.lazy(() => CampaignUncheckedUpdateWithoutOutboxesInputSchema)
      ])
    })
    .strict();

export const CampaignUpdateWithoutOutboxesInputSchema: z.ZodType<Prisma.CampaignUpdateWithoutOutboxesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => CampaignTypeSchema),
          z.lazy(() => EnumCampaignTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      smart: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      list: z
        .lazy(() => ListUpdateOneWithoutCampaignsNestedInputSchema)
        .optional(),
      email: z
        .lazy(() => EmailUpdateOneRequiredWithoutCampaignsNestedInputSchema)
        .optional()
    })
    .strict();

export const CampaignUncheckedUpdateWithoutOutboxesInputSchema: z.ZodType<Prisma.CampaignUncheckedUpdateWithoutOutboxesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => CampaignTypeSchema),
          z.lazy(() => EnumCampaignTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      smart: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      listId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      emailId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserUpsertWithoutOutboxInputSchema: z.ZodType<Prisma.UserUpsertWithoutOutboxInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutOutboxInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutOutboxInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutOutboxInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutOutboxInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutOutboxInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutOutboxInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutOutboxInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutOutboxInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutOutboxInputSchema: z.ZodType<Prisma.UserUpdateWithoutOutboxInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutOutboxInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutOutboxInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserCreateWithoutListsManageInputSchema: z.ZodType<Prisma.UserCreateWithoutListsManageInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutListsManageInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutListsManageInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutListsManageInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutListsManageInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutListsManageInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutListsManageInputSchema)
      ])
    })
    .strict();

export const UserCreateWithoutListsInputSchema: z.ZodType<Prisma.UserCreateWithoutListsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutListsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutListsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutListsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutListsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutListsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutListsInputSchema)
      ])
    })
    .strict();

export const CampaignCreateWithoutListInputSchema: z.ZodType<Prisma.CampaignCreateWithoutListInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => CampaignTypeSchema).optional(),
      smart: z.boolean().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      active: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      email: z.lazy(() => EmailCreateNestedOneWithoutCampaignsInputSchema),
      outboxes: z
        .lazy(() => OutboxCreateNestedManyWithoutCampaignInputSchema)
        .optional()
    })
    .strict();

export const CampaignUncheckedCreateWithoutListInputSchema: z.ZodType<Prisma.CampaignUncheckedCreateWithoutListInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => CampaignTypeSchema).optional(),
      smart: z.boolean().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      active: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      emailId: z.string(),
      outboxes: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutCampaignInputSchema)
        .optional()
    })
    .strict();

export const CampaignCreateOrConnectWithoutListInputSchema: z.ZodType<Prisma.CampaignCreateOrConnectWithoutListInput> =
  z
    .object({
      where: z.lazy(() => CampaignWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CampaignCreateWithoutListInputSchema),
        z.lazy(() => CampaignUncheckedCreateWithoutListInputSchema)
      ])
    })
    .strict();

export const CampaignCreateManyListInputEnvelopeSchema: z.ZodType<Prisma.CampaignCreateManyListInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => CampaignCreateManyListInputSchema),
        z.lazy(() => CampaignCreateManyListInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const UserUpsertWithWhereUniqueWithoutListsManageInputSchema: z.ZodType<Prisma.UserUpsertWithWhereUniqueWithoutListsManageInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => UserUpdateWithoutListsManageInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutListsManageInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutListsManageInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutListsManageInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithWhereUniqueWithoutListsManageInputSchema: z.ZodType<Prisma.UserUpdateWithWhereUniqueWithoutListsManageInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => UserUpdateWithoutListsManageInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutListsManageInputSchema)
      ])
    })
    .strict();

export const UserUpdateManyWithWhereWithoutListsManageInputSchema: z.ZodType<Prisma.UserUpdateManyWithWhereWithoutListsManageInput> =
  z
    .object({
      where: z.lazy(() => UserScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => UserUpdateManyMutationInputSchema),
        z.lazy(() => UserUncheckedUpdateManyWithoutListsManageInputSchema)
      ])
    })
    .strict();

export const UserUpsertWithWhereUniqueWithoutListsInputSchema: z.ZodType<Prisma.UserUpsertWithWhereUniqueWithoutListsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => UserUpdateWithoutListsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutListsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutListsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutListsInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithWhereUniqueWithoutListsInputSchema: z.ZodType<Prisma.UserUpdateWithWhereUniqueWithoutListsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => UserUpdateWithoutListsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutListsInputSchema)
      ])
    })
    .strict();

export const UserUpdateManyWithWhereWithoutListsInputSchema: z.ZodType<Prisma.UserUpdateManyWithWhereWithoutListsInput> =
  z
    .object({
      where: z.lazy(() => UserScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => UserUpdateManyMutationInputSchema),
        z.lazy(() => UserUncheckedUpdateManyWithoutListsInputSchema)
      ])
    })
    .strict();

export const CampaignUpsertWithWhereUniqueWithoutListInputSchema: z.ZodType<Prisma.CampaignUpsertWithWhereUniqueWithoutListInput> =
  z
    .object({
      where: z.lazy(() => CampaignWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => CampaignUpdateWithoutListInputSchema),
        z.lazy(() => CampaignUncheckedUpdateWithoutListInputSchema)
      ]),
      create: z.union([
        z.lazy(() => CampaignCreateWithoutListInputSchema),
        z.lazy(() => CampaignUncheckedCreateWithoutListInputSchema)
      ])
    })
    .strict();

export const CampaignUpdateWithWhereUniqueWithoutListInputSchema: z.ZodType<Prisma.CampaignUpdateWithWhereUniqueWithoutListInput> =
  z
    .object({
      where: z.lazy(() => CampaignWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => CampaignUpdateWithoutListInputSchema),
        z.lazy(() => CampaignUncheckedUpdateWithoutListInputSchema)
      ])
    })
    .strict();

export const CampaignUpdateManyWithWhereWithoutListInputSchema: z.ZodType<Prisma.CampaignUpdateManyWithWhereWithoutListInput> =
  z
    .object({
      where: z.lazy(() => CampaignScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => CampaignUpdateManyMutationInputSchema),
        z.lazy(() => CampaignUncheckedUpdateManyWithoutListInputSchema)
      ])
    })
    .strict();

export const CampaignScalarWhereInputSchema: z.ZodType<Prisma.CampaignScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CampaignScalarWhereInputSchema),
          z.lazy(() => CampaignScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => CampaignScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CampaignScalarWhereInputSchema),
          z.lazy(() => CampaignScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      type: z
        .union([
          z.lazy(() => EnumCampaignTypeFilterSchema),
          z.lazy(() => CampaignTypeSchema)
        ])
        .optional(),
      smart: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      title: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      active: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      listId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      emailId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const ListCreateWithoutCampaignsInputSchema: z.ZodType<Prisma.ListCreateWithoutCampaignsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      owners: z
        .lazy(() => UserCreateNestedManyWithoutListsManageInputSchema)
        .optional(),
      contacts: z
        .lazy(() => UserCreateNestedManyWithoutListsInputSchema)
        .optional()
    })
    .strict();

export const ListUncheckedCreateWithoutCampaignsInputSchema: z.ZodType<Prisma.ListUncheckedCreateWithoutCampaignsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      owners: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutListsManageInputSchema)
        .optional(),
      contacts: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutListsInputSchema)
        .optional()
    })
    .strict();

export const ListCreateOrConnectWithoutCampaignsInputSchema: z.ZodType<Prisma.ListCreateOrConnectWithoutCampaignsInput> =
  z
    .object({
      where: z.lazy(() => ListWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ListCreateWithoutCampaignsInputSchema),
        z.lazy(() => ListUncheckedCreateWithoutCampaignsInputSchema)
      ])
    })
    .strict();

export const EmailCreateWithoutCampaignsInputSchema: z.ZodType<Prisma.EmailCreateWithoutCampaignsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      subject: z.string(),
      content: z.string(),
      design: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutEmailsInputSchema)
    })
    .strict();

export const EmailUncheckedCreateWithoutCampaignsInputSchema: z.ZodType<Prisma.EmailUncheckedCreateWithoutCampaignsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      subject: z.string(),
      content: z.string(),
      design: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string()
    })
    .strict();

export const EmailCreateOrConnectWithoutCampaignsInputSchema: z.ZodType<Prisma.EmailCreateOrConnectWithoutCampaignsInput> =
  z
    .object({
      where: z.lazy(() => EmailWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => EmailCreateWithoutCampaignsInputSchema),
        z.lazy(() => EmailUncheckedCreateWithoutCampaignsInputSchema)
      ])
    })
    .strict();

export const OutboxCreateWithoutCampaignInputSchema: z.ZodType<Prisma.OutboxCreateWithoutCampaignInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      subject: z.string(),
      body: z.string(),
      status: z.string().optional(),
      metadata: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutOutboxInputSchema).optional()
    })
    .strict();

export const OutboxUncheckedCreateWithoutCampaignInputSchema: z.ZodType<Prisma.OutboxUncheckedCreateWithoutCampaignInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.string(),
      subject: z.string(),
      body: z.string(),
      status: z.string().optional(),
      metadata: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional()
    })
    .strict();

export const OutboxCreateOrConnectWithoutCampaignInputSchema: z.ZodType<Prisma.OutboxCreateOrConnectWithoutCampaignInput> =
  z
    .object({
      where: z.lazy(() => OutboxWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OutboxCreateWithoutCampaignInputSchema),
        z.lazy(() => OutboxUncheckedCreateWithoutCampaignInputSchema)
      ])
    })
    .strict();

export const OutboxCreateManyCampaignInputEnvelopeSchema: z.ZodType<Prisma.OutboxCreateManyCampaignInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => OutboxCreateManyCampaignInputSchema),
        z.lazy(() => OutboxCreateManyCampaignInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ListUpsertWithoutCampaignsInputSchema: z.ZodType<Prisma.ListUpsertWithoutCampaignsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ListUpdateWithoutCampaignsInputSchema),
        z.lazy(() => ListUncheckedUpdateWithoutCampaignsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => ListCreateWithoutCampaignsInputSchema),
        z.lazy(() => ListUncheckedCreateWithoutCampaignsInputSchema)
      ]),
      where: z.lazy(() => ListWhereInputSchema).optional()
    })
    .strict();

export const ListUpdateToOneWithWhereWithoutCampaignsInputSchema: z.ZodType<Prisma.ListUpdateToOneWithWhereWithoutCampaignsInput> =
  z
    .object({
      where: z.lazy(() => ListWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ListUpdateWithoutCampaignsInputSchema),
        z.lazy(() => ListUncheckedUpdateWithoutCampaignsInputSchema)
      ])
    })
    .strict();

export const ListUpdateWithoutCampaignsInputSchema: z.ZodType<Prisma.ListUpdateWithoutCampaignsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      owners: z
        .lazy(() => UserUpdateManyWithoutListsManageNestedInputSchema)
        .optional(),
      contacts: z
        .lazy(() => UserUpdateManyWithoutListsNestedInputSchema)
        .optional()
    })
    .strict();

export const ListUncheckedUpdateWithoutCampaignsInputSchema: z.ZodType<Prisma.ListUncheckedUpdateWithoutCampaignsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      owners: z
        .lazy(() => UserUncheckedUpdateManyWithoutListsManageNestedInputSchema)
        .optional(),
      contacts: z
        .lazy(() => UserUncheckedUpdateManyWithoutListsNestedInputSchema)
        .optional()
    })
    .strict();

export const EmailUpsertWithoutCampaignsInputSchema: z.ZodType<Prisma.EmailUpsertWithoutCampaignsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => EmailUpdateWithoutCampaignsInputSchema),
        z.lazy(() => EmailUncheckedUpdateWithoutCampaignsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => EmailCreateWithoutCampaignsInputSchema),
        z.lazy(() => EmailUncheckedCreateWithoutCampaignsInputSchema)
      ]),
      where: z.lazy(() => EmailWhereInputSchema).optional()
    })
    .strict();

export const EmailUpdateToOneWithWhereWithoutCampaignsInputSchema: z.ZodType<Prisma.EmailUpdateToOneWithWhereWithoutCampaignsInput> =
  z
    .object({
      where: z.lazy(() => EmailWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => EmailUpdateWithoutCampaignsInputSchema),
        z.lazy(() => EmailUncheckedUpdateWithoutCampaignsInputSchema)
      ])
    })
    .strict();

export const EmailUpdateWithoutCampaignsInputSchema: z.ZodType<Prisma.EmailUpdateWithoutCampaignsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subject: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      design: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutEmailsNestedInputSchema)
        .optional()
    })
    .strict();

export const EmailUncheckedUpdateWithoutCampaignsInputSchema: z.ZodType<Prisma.EmailUncheckedUpdateWithoutCampaignsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subject: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      design: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const OutboxUpsertWithWhereUniqueWithoutCampaignInputSchema: z.ZodType<Prisma.OutboxUpsertWithWhereUniqueWithoutCampaignInput> =
  z
    .object({
      where: z.lazy(() => OutboxWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => OutboxUpdateWithoutCampaignInputSchema),
        z.lazy(() => OutboxUncheckedUpdateWithoutCampaignInputSchema)
      ]),
      create: z.union([
        z.lazy(() => OutboxCreateWithoutCampaignInputSchema),
        z.lazy(() => OutboxUncheckedCreateWithoutCampaignInputSchema)
      ])
    })
    .strict();

export const OutboxUpdateWithWhereUniqueWithoutCampaignInputSchema: z.ZodType<Prisma.OutboxUpdateWithWhereUniqueWithoutCampaignInput> =
  z
    .object({
      where: z.lazy(() => OutboxWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => OutboxUpdateWithoutCampaignInputSchema),
        z.lazy(() => OutboxUncheckedUpdateWithoutCampaignInputSchema)
      ])
    })
    .strict();

export const OutboxUpdateManyWithWhereWithoutCampaignInputSchema: z.ZodType<Prisma.OutboxUpdateManyWithWhereWithoutCampaignInput> =
  z
    .object({
      where: z.lazy(() => OutboxScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => OutboxUpdateManyMutationInputSchema),
        z.lazy(() => OutboxUncheckedUpdateManyWithoutCampaignInputSchema)
      ])
    })
    .strict();

export const OutboxScalarWhereInputSchema: z.ZodType<Prisma.OutboxScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OutboxScalarWhereInputSchema),
          z.lazy(() => OutboxScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => OutboxScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OutboxScalarWhereInputSchema),
          z.lazy(() => OutboxScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      email: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      subject: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      body: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      status: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      metadata: z.lazy(() => JsonNullableFilterSchema).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      campaignId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable()
    })
    .strict();

export const UserCreateWithoutEmailsInputSchema: z.ZodType<Prisma.UserCreateWithoutEmailsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutEmailsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutEmailsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutEmailsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutEmailsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutEmailsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutEmailsInputSchema)
      ])
    })
    .strict();

export const CampaignCreateWithoutEmailInputSchema: z.ZodType<Prisma.CampaignCreateWithoutEmailInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => CampaignTypeSchema).optional(),
      smart: z.boolean().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      active: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      list: z
        .lazy(() => ListCreateNestedOneWithoutCampaignsInputSchema)
        .optional(),
      outboxes: z
        .lazy(() => OutboxCreateNestedManyWithoutCampaignInputSchema)
        .optional()
    })
    .strict();

export const CampaignUncheckedCreateWithoutEmailInputSchema: z.ZodType<Prisma.CampaignUncheckedCreateWithoutEmailInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => CampaignTypeSchema).optional(),
      smart: z.boolean().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      active: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      listId: z.string().optional().nullable(),
      outboxes: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutCampaignInputSchema)
        .optional()
    })
    .strict();

export const CampaignCreateOrConnectWithoutEmailInputSchema: z.ZodType<Prisma.CampaignCreateOrConnectWithoutEmailInput> =
  z
    .object({
      where: z.lazy(() => CampaignWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CampaignCreateWithoutEmailInputSchema),
        z.lazy(() => CampaignUncheckedCreateWithoutEmailInputSchema)
      ])
    })
    .strict();

export const CampaignCreateManyEmailInputEnvelopeSchema: z.ZodType<Prisma.CampaignCreateManyEmailInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => CampaignCreateManyEmailInputSchema),
        z.lazy(() => CampaignCreateManyEmailInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const UserUpsertWithoutEmailsInputSchema: z.ZodType<Prisma.UserUpsertWithoutEmailsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutEmailsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutEmailsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutEmailsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutEmailsInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutEmailsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutEmailsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutEmailsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutEmailsInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutEmailsInputSchema: z.ZodType<Prisma.UserUpdateWithoutEmailsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutEmailsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutEmailsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const CampaignUpsertWithWhereUniqueWithoutEmailInputSchema: z.ZodType<Prisma.CampaignUpsertWithWhereUniqueWithoutEmailInput> =
  z
    .object({
      where: z.lazy(() => CampaignWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => CampaignUpdateWithoutEmailInputSchema),
        z.lazy(() => CampaignUncheckedUpdateWithoutEmailInputSchema)
      ]),
      create: z.union([
        z.lazy(() => CampaignCreateWithoutEmailInputSchema),
        z.lazy(() => CampaignUncheckedCreateWithoutEmailInputSchema)
      ])
    })
    .strict();

export const CampaignUpdateWithWhereUniqueWithoutEmailInputSchema: z.ZodType<Prisma.CampaignUpdateWithWhereUniqueWithoutEmailInput> =
  z
    .object({
      where: z.lazy(() => CampaignWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => CampaignUpdateWithoutEmailInputSchema),
        z.lazy(() => CampaignUncheckedUpdateWithoutEmailInputSchema)
      ])
    })
    .strict();

export const CampaignUpdateManyWithWhereWithoutEmailInputSchema: z.ZodType<Prisma.CampaignUpdateManyWithWhereWithoutEmailInput> =
  z
    .object({
      where: z.lazy(() => CampaignScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => CampaignUpdateManyMutationInputSchema),
        z.lazy(() => CampaignUncheckedUpdateManyWithoutEmailInputSchema)
      ])
    })
    .strict();

export const BlockCreateWithoutClicksInputSchema: z.ZodType<Prisma.BlockCreateWithoutClicksInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string(),
      position: z.number().int().optional(),
      label: z.string().optional().nullable(),
      href: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      site: z.lazy(() => SiteCreateNestedOneWithoutBlocksInputSchema),
      categories: z
        .lazy(() => CategoryCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      inventories: z
        .lazy(() => InventoryCreateNestedManyWithoutBlockInputSchema)
        .optional()
    })
    .strict();

export const BlockUncheckedCreateWithoutClicksInputSchema: z.ZodType<Prisma.BlockUncheckedCreateWithoutClicksInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string(),
      position: z.number().int().optional(),
      label: z.string().optional().nullable(),
      href: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      siteId: z.string(),
      reservations: z
        .lazy(() => ReservationUncheckedCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      categories: z
        .lazy(() => CategoryUncheckedCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      inventories: z
        .lazy(() => InventoryUncheckedCreateNestedManyWithoutBlockInputSchema)
        .optional()
    })
    .strict();

export const BlockCreateOrConnectWithoutClicksInputSchema: z.ZodType<Prisma.BlockCreateOrConnectWithoutClicksInput> =
  z
    .object({
      where: z.lazy(() => BlockWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => BlockCreateWithoutClicksInputSchema),
        z.lazy(() => BlockUncheckedCreateWithoutClicksInputSchema)
      ])
    })
    .strict();

export const SiteCreateWithoutClicksInputSchema: z.ZodType<Prisma.SiteCreateWithoutClicksInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      display_name: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      font: z.string().optional(),
      image: z.string().optional().nullable(),
      imageBlurhash: z.string().optional().nullable(),
      subdomain: z.string().optional().nullable(),
      customDomain: z.string().optional().nullable(),
      message404: z.string().optional().nullable(),
      background: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutSitesInputSchema),
      blocks: z
        .lazy(() => BlockCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      subscribers: z
        .lazy(() => SubscriberCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutSiteInputSchema).optional()
    })
    .strict();

export const SiteUncheckedCreateWithoutClicksInputSchema: z.ZodType<Prisma.SiteUncheckedCreateWithoutClicksInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      display_name: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      font: z.string().optional(),
      image: z.string().optional().nullable(),
      imageBlurhash: z.string().optional().nullable(),
      subdomain: z.string().optional().nullable(),
      customDomain: z.string().optional().nullable(),
      message404: z.string().optional().nullable(),
      background: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string(),
      blocks: z
        .lazy(() => BlockUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      subscribers: z
        .lazy(() => SubscriberUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional()
    })
    .strict();

export const SiteCreateOrConnectWithoutClicksInputSchema: z.ZodType<Prisma.SiteCreateOrConnectWithoutClicksInput> =
  z
    .object({
      where: z.lazy(() => SiteWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => SiteCreateWithoutClicksInputSchema),
        z.lazy(() => SiteUncheckedCreateWithoutClicksInputSchema)
      ])
    })
    .strict();

export const LinkCreateWithoutClicksInputSchema: z.ZodType<Prisma.LinkCreateWithoutClicksInput> =
  z
    .object({
      id: z.string(),
      url: z.string(),
      name: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutLinksInputSchema).optional()
    })
    .strict();

export const LinkUncheckedCreateWithoutClicksInputSchema: z.ZodType<Prisma.LinkUncheckedCreateWithoutClicksInput> =
  z
    .object({
      id: z.string(),
      url: z.string(),
      name: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string().optional().nullable()
    })
    .strict();

export const LinkCreateOrConnectWithoutClicksInputSchema: z.ZodType<Prisma.LinkCreateOrConnectWithoutClicksInput> =
  z
    .object({
      where: z.lazy(() => LinkWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => LinkCreateWithoutClicksInputSchema),
        z.lazy(() => LinkUncheckedCreateWithoutClicksInputSchema)
      ])
    })
    .strict();

export const UserCreateWithoutClicksInputSchema: z.ZodType<Prisma.UserCreateWithoutClicksInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutClicksInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutClicksInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutClicksInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutClicksInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutClicksInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutClicksInputSchema)
      ])
    })
    .strict();

export const UserCreateWithoutReferralsInputSchema: z.ZodType<Prisma.UserCreateWithoutReferralsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutReferralsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutReferralsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutReferralsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutReferralsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutReferralsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutReferralsInputSchema)
      ])
    })
    .strict();

export const BlockUpsertWithoutClicksInputSchema: z.ZodType<Prisma.BlockUpsertWithoutClicksInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => BlockUpdateWithoutClicksInputSchema),
        z.lazy(() => BlockUncheckedUpdateWithoutClicksInputSchema)
      ]),
      create: z.union([
        z.lazy(() => BlockCreateWithoutClicksInputSchema),
        z.lazy(() => BlockUncheckedCreateWithoutClicksInputSchema)
      ]),
      where: z.lazy(() => BlockWhereInputSchema).optional()
    })
    .strict();

export const BlockUpdateToOneWithWhereWithoutClicksInputSchema: z.ZodType<Prisma.BlockUpdateToOneWithWhereWithoutClicksInput> =
  z
    .object({
      where: z.lazy(() => BlockWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => BlockUpdateWithoutClicksInputSchema),
        z.lazy(() => BlockUncheckedUpdateWithoutClicksInputSchema)
      ])
    })
    .strict();

export const BlockUpdateWithoutClicksInputSchema: z.ZodType<Prisma.BlockUpdateWithoutClicksInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      label: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      href: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      site: z
        .lazy(() => SiteUpdateOneRequiredWithoutBlocksNestedInputSchema)
        .optional(),
      categories: z
        .lazy(() => CategoryUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      inventories: z
        .lazy(() => InventoryUpdateManyWithoutBlockNestedInputSchema)
        .optional()
    })
    .strict();

export const BlockUncheckedUpdateWithoutClicksInputSchema: z.ZodType<Prisma.BlockUncheckedUpdateWithoutClicksInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      label: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      href: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      reservations: z
        .lazy(() => ReservationUncheckedUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      categories: z
        .lazy(() => CategoryUncheckedUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      inventories: z
        .lazy(() => InventoryUncheckedUpdateManyWithoutBlockNestedInputSchema)
        .optional()
    })
    .strict();

export const SiteUpsertWithoutClicksInputSchema: z.ZodType<Prisma.SiteUpsertWithoutClicksInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => SiteUpdateWithoutClicksInputSchema),
        z.lazy(() => SiteUncheckedUpdateWithoutClicksInputSchema)
      ]),
      create: z.union([
        z.lazy(() => SiteCreateWithoutClicksInputSchema),
        z.lazy(() => SiteUncheckedCreateWithoutClicksInputSchema)
      ]),
      where: z.lazy(() => SiteWhereInputSchema).optional()
    })
    .strict();

export const SiteUpdateToOneWithWhereWithoutClicksInputSchema: z.ZodType<Prisma.SiteUpdateToOneWithWhereWithoutClicksInput> =
  z
    .object({
      where: z.lazy(() => SiteWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => SiteUpdateWithoutClicksInputSchema),
        z.lazy(() => SiteUncheckedUpdateWithoutClicksInputSchema)
      ])
    })
    .strict();

export const SiteUpdateWithoutClicksInputSchema: z.ZodType<Prisma.SiteUpdateWithoutClicksInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      display_name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      font: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      imageBlurhash: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subdomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      customDomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      message404: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      background: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutSitesNestedInputSchema)
        .optional(),
      blocks: z
        .lazy(() => BlockUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      subscribers: z
        .lazy(() => SubscriberUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutSiteNestedInputSchema).optional()
    })
    .strict();

export const SiteUncheckedUpdateWithoutClicksInputSchema: z.ZodType<Prisma.SiteUncheckedUpdateWithoutClicksInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      display_name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      font: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      imageBlurhash: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subdomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      customDomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      message404: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      background: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blocks: z
        .lazy(() => BlockUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      subscribers: z
        .lazy(() => SubscriberUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional()
    })
    .strict();

export const LinkUpsertWithoutClicksInputSchema: z.ZodType<Prisma.LinkUpsertWithoutClicksInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => LinkUpdateWithoutClicksInputSchema),
        z.lazy(() => LinkUncheckedUpdateWithoutClicksInputSchema)
      ]),
      create: z.union([
        z.lazy(() => LinkCreateWithoutClicksInputSchema),
        z.lazy(() => LinkUncheckedCreateWithoutClicksInputSchema)
      ]),
      where: z.lazy(() => LinkWhereInputSchema).optional()
    })
    .strict();

export const LinkUpdateToOneWithWhereWithoutClicksInputSchema: z.ZodType<Prisma.LinkUpdateToOneWithWhereWithoutClicksInput> =
  z
    .object({
      where: z.lazy(() => LinkWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => LinkUpdateWithoutClicksInputSchema),
        z.lazy(() => LinkUncheckedUpdateWithoutClicksInputSchema)
      ])
    })
    .strict();

export const LinkUpdateWithoutClicksInputSchema: z.ZodType<Prisma.LinkUpdateWithoutClicksInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      url: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      user: z.lazy(() => UserUpdateOneWithoutLinksNestedInputSchema).optional()
    })
    .strict();

export const LinkUncheckedUpdateWithoutClicksInputSchema: z.ZodType<Prisma.LinkUncheckedUpdateWithoutClicksInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      url: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const UserUpsertWithoutClicksInputSchema: z.ZodType<Prisma.UserUpsertWithoutClicksInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutClicksInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutClicksInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutClicksInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutClicksInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutClicksInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutClicksInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutClicksInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutClicksInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutClicksInputSchema: z.ZodType<Prisma.UserUpdateWithoutClicksInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutClicksInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutClicksInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUpsertWithoutReferralsInputSchema: z.ZodType<Prisma.UserUpsertWithoutReferralsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutReferralsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutReferralsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutReferralsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutReferralsInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutReferralsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutReferralsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutReferralsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutReferralsInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutReferralsInputSchema: z.ZodType<Prisma.UserUpdateWithoutReferralsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutReferralsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutReferralsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional()
    })
    .strict();

export const ClickCreateWithoutLinkInputSchema: z.ZodType<Prisma.ClickCreateWithoutLinkInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      part: z.string().optional().nullable(),
      path: z.string().optional().nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      block: z
        .lazy(() => BlockCreateNestedOneWithoutClicksInputSchema)
        .optional(),
      site: z
        .lazy(() => SiteCreateNestedOneWithoutClicksInputSchema)
        .optional(),
      user: z
        .lazy(() => UserCreateNestedOneWithoutClicksInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutReferralsInputSchema)
        .optional()
    })
    .strict();

export const ClickUncheckedCreateWithoutLinkInputSchema: z.ZodType<Prisma.ClickUncheckedCreateWithoutLinkInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      part: z.string().optional().nullable(),
      path: z.string().optional().nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      blockId: z.string().optional().nullable(),
      siteId: z.string().optional().nullable(),
      userId: z.string().optional().nullable(),
      refererId: z.string().optional().nullable()
    })
    .strict();

export const ClickCreateOrConnectWithoutLinkInputSchema: z.ZodType<Prisma.ClickCreateOrConnectWithoutLinkInput> =
  z
    .object({
      where: z.lazy(() => ClickWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ClickCreateWithoutLinkInputSchema),
        z.lazy(() => ClickUncheckedCreateWithoutLinkInputSchema)
      ])
    })
    .strict();

export const ClickCreateManyLinkInputEnvelopeSchema: z.ZodType<Prisma.ClickCreateManyLinkInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ClickCreateManyLinkInputSchema),
        z.lazy(() => ClickCreateManyLinkInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const UserCreateWithoutLinksInputSchema: z.ZodType<Prisma.UserCreateWithoutLinksInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutLinksInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutLinksInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutLinksInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutLinksInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutLinksInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutLinksInputSchema)
      ])
    })
    .strict();

export const ClickUpsertWithWhereUniqueWithoutLinkInputSchema: z.ZodType<Prisma.ClickUpsertWithWhereUniqueWithoutLinkInput> =
  z
    .object({
      where: z.lazy(() => ClickWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ClickUpdateWithoutLinkInputSchema),
        z.lazy(() => ClickUncheckedUpdateWithoutLinkInputSchema)
      ]),
      create: z.union([
        z.lazy(() => ClickCreateWithoutLinkInputSchema),
        z.lazy(() => ClickUncheckedCreateWithoutLinkInputSchema)
      ])
    })
    .strict();

export const ClickUpdateWithWhereUniqueWithoutLinkInputSchema: z.ZodType<Prisma.ClickUpdateWithWhereUniqueWithoutLinkInput> =
  z
    .object({
      where: z.lazy(() => ClickWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ClickUpdateWithoutLinkInputSchema),
        z.lazy(() => ClickUncheckedUpdateWithoutLinkInputSchema)
      ])
    })
    .strict();

export const ClickUpdateManyWithWhereWithoutLinkInputSchema: z.ZodType<Prisma.ClickUpdateManyWithWhereWithoutLinkInput> =
  z
    .object({
      where: z.lazy(() => ClickScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ClickUpdateManyMutationInputSchema),
        z.lazy(() => ClickUncheckedUpdateManyWithoutLinkInputSchema)
      ])
    })
    .strict();

export const ClickScalarWhereInputSchema: z.ZodType<Prisma.ClickScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ClickScalarWhereInputSchema),
          z.lazy(() => ClickScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => ClickScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ClickScalarWhereInputSchema),
          z.lazy(() => ClickScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      part: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      path: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      request: z.lazy(() => JsonNullableFilterSchema).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      blockId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      siteId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      linkId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      userId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      refererId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable()
    })
    .strict();

export const UserUpsertWithoutLinksInputSchema: z.ZodType<Prisma.UserUpsertWithoutLinksInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutLinksInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutLinksInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutLinksInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutLinksInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutLinksInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutLinksInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutLinksInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutLinksInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutLinksInputSchema: z.ZodType<Prisma.UserUpdateWithoutLinksInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutLinksInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutLinksInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const ClickCreateWithoutBlockInputSchema: z.ZodType<Prisma.ClickCreateWithoutBlockInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      part: z.string().optional().nullable(),
      path: z.string().optional().nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      site: z
        .lazy(() => SiteCreateNestedOneWithoutClicksInputSchema)
        .optional(),
      link: z
        .lazy(() => LinkCreateNestedOneWithoutClicksInputSchema)
        .optional(),
      user: z
        .lazy(() => UserCreateNestedOneWithoutClicksInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutReferralsInputSchema)
        .optional()
    })
    .strict();

export const ClickUncheckedCreateWithoutBlockInputSchema: z.ZodType<Prisma.ClickUncheckedCreateWithoutBlockInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      part: z.string().optional().nullable(),
      path: z.string().optional().nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      siteId: z.string().optional().nullable(),
      linkId: z.string().optional().nullable(),
      userId: z.string().optional().nullable(),
      refererId: z.string().optional().nullable()
    })
    .strict();

export const ClickCreateOrConnectWithoutBlockInputSchema: z.ZodType<Prisma.ClickCreateOrConnectWithoutBlockInput> =
  z
    .object({
      where: z.lazy(() => ClickWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ClickCreateWithoutBlockInputSchema),
        z.lazy(() => ClickUncheckedCreateWithoutBlockInputSchema)
      ])
    })
    .strict();

export const ClickCreateManyBlockInputEnvelopeSchema: z.ZodType<Prisma.ClickCreateManyBlockInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ClickCreateManyBlockInputSchema),
        z.lazy(() => ClickCreateManyBlockInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ReservationCreateWithoutBlockInputSchema: z.ZodType<Prisma.ReservationCreateWithoutBlockInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string().optional().nullable(),
      name: z.string().optional().nullable(),
      email: z.string(),
      dateStart: z.coerce.date(),
      dateEnd: z.coerce.date().optional().nullable(),
      comment: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      affiliate: z
        .lazy(() => UserCreateNestedOneWithoutReservationsInputSchema)
        .optional()
    })
    .strict();

export const ReservationUncheckedCreateWithoutBlockInputSchema: z.ZodType<Prisma.ReservationUncheckedCreateWithoutBlockInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string().optional().nullable(),
      name: z.string().optional().nullable(),
      email: z.string(),
      dateStart: z.coerce.date(),
      dateEnd: z.coerce.date().optional().nullable(),
      comment: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      affiliateId: z.string().optional().nullable()
    })
    .strict();

export const ReservationCreateOrConnectWithoutBlockInputSchema: z.ZodType<Prisma.ReservationCreateOrConnectWithoutBlockInput> =
  z
    .object({
      where: z.lazy(() => ReservationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ReservationCreateWithoutBlockInputSchema),
        z.lazy(() => ReservationUncheckedCreateWithoutBlockInputSchema)
      ])
    })
    .strict();

export const ReservationCreateManyBlockInputEnvelopeSchema: z.ZodType<Prisma.ReservationCreateManyBlockInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ReservationCreateManyBlockInputSchema),
        z.lazy(() => ReservationCreateManyBlockInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const SiteCreateWithoutBlocksInputSchema: z.ZodType<Prisma.SiteCreateWithoutBlocksInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      display_name: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      font: z.string().optional(),
      image: z.string().optional().nullable(),
      imageBlurhash: z.string().optional().nullable(),
      subdomain: z.string().optional().nullable(),
      customDomain: z.string().optional().nullable(),
      message404: z.string().optional().nullable(),
      background: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutSitesInputSchema),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      subscribers: z
        .lazy(() => SubscriberCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutSiteInputSchema).optional()
    })
    .strict();

export const SiteUncheckedCreateWithoutBlocksInputSchema: z.ZodType<Prisma.SiteUncheckedCreateWithoutBlocksInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      display_name: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      font: z.string().optional(),
      image: z.string().optional().nullable(),
      imageBlurhash: z.string().optional().nullable(),
      subdomain: z.string().optional().nullable(),
      customDomain: z.string().optional().nullable(),
      message404: z.string().optional().nullable(),
      background: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      subscribers: z
        .lazy(() => SubscriberUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional()
    })
    .strict();

export const SiteCreateOrConnectWithoutBlocksInputSchema: z.ZodType<Prisma.SiteCreateOrConnectWithoutBlocksInput> =
  z
    .object({
      where: z.lazy(() => SiteWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => SiteCreateWithoutBlocksInputSchema),
        z.lazy(() => SiteUncheckedCreateWithoutBlocksInputSchema)
      ])
    })
    .strict();

export const CategoryCreateWithoutBlockInputSchema: z.ZodType<Prisma.CategoryCreateWithoutBlockInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      active: z.boolean().optional(),
      position: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      inventories: z
        .lazy(() => InventoryCreateNestedManyWithoutCategoryInputSchema)
        .optional(),
      categories: z
        .lazy(() => CategoryCreateNestedManyWithoutCategoryInputSchema)
        .optional(),
      category: z
        .lazy(() => CategoryCreateNestedOneWithoutCategoriesInputSchema)
        .optional()
    })
    .strict();

export const CategoryUncheckedCreateWithoutBlockInputSchema: z.ZodType<Prisma.CategoryUncheckedCreateWithoutBlockInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      active: z.boolean().optional(),
      position: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      categoryId: z.string().optional().nullable(),
      inventories: z
        .lazy(
          () => InventoryUncheckedCreateNestedManyWithoutCategoryInputSchema
        )
        .optional(),
      categories: z
        .lazy(() => CategoryUncheckedCreateNestedManyWithoutCategoryInputSchema)
        .optional()
    })
    .strict();

export const CategoryCreateOrConnectWithoutBlockInputSchema: z.ZodType<Prisma.CategoryCreateOrConnectWithoutBlockInput> =
  z
    .object({
      where: z.lazy(() => CategoryWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CategoryCreateWithoutBlockInputSchema),
        z.lazy(() => CategoryUncheckedCreateWithoutBlockInputSchema)
      ])
    })
    .strict();

export const CategoryCreateManyBlockInputEnvelopeSchema: z.ZodType<Prisma.CategoryCreateManyBlockInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => CategoryCreateManyBlockInputSchema),
        z.lazy(() => CategoryCreateManyBlockInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const InventoryCreateWithoutBlockInputSchema: z.ZodType<Prisma.InventoryCreateWithoutBlockInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      sku: z.string().optional().nullable(),
      basePrice: z.number(),
      active: z.boolean().optional(),
      isFeatured: z.boolean().optional(),
      metaTitle: z.string().optional().nullable(),
      metaDescription: z.string().optional().nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryCreatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      category: z
        .lazy(() => CategoryCreateNestedOneWithoutInventoriesInputSchema)
        .optional(),
      variants: z
        .lazy(() => InventoryVariantCreateNestedManyWithoutInventoryInputSchema)
        .optional()
    })
    .strict();

export const InventoryUncheckedCreateWithoutBlockInputSchema: z.ZodType<Prisma.InventoryUncheckedCreateWithoutBlockInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      sku: z.string().optional().nullable(),
      basePrice: z.number(),
      active: z.boolean().optional(),
      isFeatured: z.boolean().optional(),
      metaTitle: z.string().optional().nullable(),
      metaDescription: z.string().optional().nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryCreatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      categoryId: z.string().optional().nullable(),
      variants: z
        .lazy(
          () =>
            InventoryVariantUncheckedCreateNestedManyWithoutInventoryInputSchema
        )
        .optional()
    })
    .strict();

export const InventoryCreateOrConnectWithoutBlockInputSchema: z.ZodType<Prisma.InventoryCreateOrConnectWithoutBlockInput> =
  z
    .object({
      where: z.lazy(() => InventoryWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => InventoryCreateWithoutBlockInputSchema),
        z.lazy(() => InventoryUncheckedCreateWithoutBlockInputSchema)
      ])
    })
    .strict();

export const InventoryCreateManyBlockInputEnvelopeSchema: z.ZodType<Prisma.InventoryCreateManyBlockInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => InventoryCreateManyBlockInputSchema),
        z.lazy(() => InventoryCreateManyBlockInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ClickUpsertWithWhereUniqueWithoutBlockInputSchema: z.ZodType<Prisma.ClickUpsertWithWhereUniqueWithoutBlockInput> =
  z
    .object({
      where: z.lazy(() => ClickWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ClickUpdateWithoutBlockInputSchema),
        z.lazy(() => ClickUncheckedUpdateWithoutBlockInputSchema)
      ]),
      create: z.union([
        z.lazy(() => ClickCreateWithoutBlockInputSchema),
        z.lazy(() => ClickUncheckedCreateWithoutBlockInputSchema)
      ])
    })
    .strict();

export const ClickUpdateWithWhereUniqueWithoutBlockInputSchema: z.ZodType<Prisma.ClickUpdateWithWhereUniqueWithoutBlockInput> =
  z
    .object({
      where: z.lazy(() => ClickWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ClickUpdateWithoutBlockInputSchema),
        z.lazy(() => ClickUncheckedUpdateWithoutBlockInputSchema)
      ])
    })
    .strict();

export const ClickUpdateManyWithWhereWithoutBlockInputSchema: z.ZodType<Prisma.ClickUpdateManyWithWhereWithoutBlockInput> =
  z
    .object({
      where: z.lazy(() => ClickScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ClickUpdateManyMutationInputSchema),
        z.lazy(() => ClickUncheckedUpdateManyWithoutBlockInputSchema)
      ])
    })
    .strict();

export const ReservationUpsertWithWhereUniqueWithoutBlockInputSchema: z.ZodType<Prisma.ReservationUpsertWithWhereUniqueWithoutBlockInput> =
  z
    .object({
      where: z.lazy(() => ReservationWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ReservationUpdateWithoutBlockInputSchema),
        z.lazy(() => ReservationUncheckedUpdateWithoutBlockInputSchema)
      ]),
      create: z.union([
        z.lazy(() => ReservationCreateWithoutBlockInputSchema),
        z.lazy(() => ReservationUncheckedCreateWithoutBlockInputSchema)
      ])
    })
    .strict();

export const ReservationUpdateWithWhereUniqueWithoutBlockInputSchema: z.ZodType<Prisma.ReservationUpdateWithWhereUniqueWithoutBlockInput> =
  z
    .object({
      where: z.lazy(() => ReservationWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ReservationUpdateWithoutBlockInputSchema),
        z.lazy(() => ReservationUncheckedUpdateWithoutBlockInputSchema)
      ])
    })
    .strict();

export const ReservationUpdateManyWithWhereWithoutBlockInputSchema: z.ZodType<Prisma.ReservationUpdateManyWithWhereWithoutBlockInput> =
  z
    .object({
      where: z.lazy(() => ReservationScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ReservationUpdateManyMutationInputSchema),
        z.lazy(() => ReservationUncheckedUpdateManyWithoutBlockInputSchema)
      ])
    })
    .strict();

export const ReservationScalarWhereInputSchema: z.ZodType<Prisma.ReservationScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ReservationScalarWhereInputSchema),
          z.lazy(() => ReservationScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => ReservationScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ReservationScalarWhereInputSchema),
          z.lazy(() => ReservationScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      type: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      name: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      email: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      dateStart: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      dateEnd: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      comment: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      blockId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      affiliateId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable()
    })
    .strict();

export const SiteUpsertWithoutBlocksInputSchema: z.ZodType<Prisma.SiteUpsertWithoutBlocksInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => SiteUpdateWithoutBlocksInputSchema),
        z.lazy(() => SiteUncheckedUpdateWithoutBlocksInputSchema)
      ]),
      create: z.union([
        z.lazy(() => SiteCreateWithoutBlocksInputSchema),
        z.lazy(() => SiteUncheckedCreateWithoutBlocksInputSchema)
      ]),
      where: z.lazy(() => SiteWhereInputSchema).optional()
    })
    .strict();

export const SiteUpdateToOneWithWhereWithoutBlocksInputSchema: z.ZodType<Prisma.SiteUpdateToOneWithWhereWithoutBlocksInput> =
  z
    .object({
      where: z.lazy(() => SiteWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => SiteUpdateWithoutBlocksInputSchema),
        z.lazy(() => SiteUncheckedUpdateWithoutBlocksInputSchema)
      ])
    })
    .strict();

export const SiteUpdateWithoutBlocksInputSchema: z.ZodType<Prisma.SiteUpdateWithoutBlocksInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      display_name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      font: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      imageBlurhash: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subdomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      customDomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      message404: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      background: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutSitesNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      subscribers: z
        .lazy(() => SubscriberUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutSiteNestedInputSchema).optional()
    })
    .strict();

export const SiteUncheckedUpdateWithoutBlocksInputSchema: z.ZodType<Prisma.SiteUncheckedUpdateWithoutBlocksInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      display_name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      font: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      imageBlurhash: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subdomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      customDomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      message404: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      background: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      subscribers: z
        .lazy(() => SubscriberUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional()
    })
    .strict();

export const CategoryUpsertWithWhereUniqueWithoutBlockInputSchema: z.ZodType<Prisma.CategoryUpsertWithWhereUniqueWithoutBlockInput> =
  z
    .object({
      where: z.lazy(() => CategoryWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => CategoryUpdateWithoutBlockInputSchema),
        z.lazy(() => CategoryUncheckedUpdateWithoutBlockInputSchema)
      ]),
      create: z.union([
        z.lazy(() => CategoryCreateWithoutBlockInputSchema),
        z.lazy(() => CategoryUncheckedCreateWithoutBlockInputSchema)
      ])
    })
    .strict();

export const CategoryUpdateWithWhereUniqueWithoutBlockInputSchema: z.ZodType<Prisma.CategoryUpdateWithWhereUniqueWithoutBlockInput> =
  z
    .object({
      where: z.lazy(() => CategoryWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => CategoryUpdateWithoutBlockInputSchema),
        z.lazy(() => CategoryUncheckedUpdateWithoutBlockInputSchema)
      ])
    })
    .strict();

export const CategoryUpdateManyWithWhereWithoutBlockInputSchema: z.ZodType<Prisma.CategoryUpdateManyWithWhereWithoutBlockInput> =
  z
    .object({
      where: z.lazy(() => CategoryScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => CategoryUpdateManyMutationInputSchema),
        z.lazy(() => CategoryUncheckedUpdateManyWithoutBlockInputSchema)
      ])
    })
    .strict();

export const CategoryScalarWhereInputSchema: z.ZodType<Prisma.CategoryScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CategoryScalarWhereInputSchema),
          z.lazy(() => CategoryScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => CategoryScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CategoryScalarWhereInputSchema),
          z.lazy(() => CategoryScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      slug: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      active: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      position: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      categoryId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      blockId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const InventoryUpsertWithWhereUniqueWithoutBlockInputSchema: z.ZodType<Prisma.InventoryUpsertWithWhereUniqueWithoutBlockInput> =
  z
    .object({
      where: z.lazy(() => InventoryWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => InventoryUpdateWithoutBlockInputSchema),
        z.lazy(() => InventoryUncheckedUpdateWithoutBlockInputSchema)
      ]),
      create: z.union([
        z.lazy(() => InventoryCreateWithoutBlockInputSchema),
        z.lazy(() => InventoryUncheckedCreateWithoutBlockInputSchema)
      ])
    })
    .strict();

export const InventoryUpdateWithWhereUniqueWithoutBlockInputSchema: z.ZodType<Prisma.InventoryUpdateWithWhereUniqueWithoutBlockInput> =
  z
    .object({
      where: z.lazy(() => InventoryWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => InventoryUpdateWithoutBlockInputSchema),
        z.lazy(() => InventoryUncheckedUpdateWithoutBlockInputSchema)
      ])
    })
    .strict();

export const InventoryUpdateManyWithWhereWithoutBlockInputSchema: z.ZodType<Prisma.InventoryUpdateManyWithWhereWithoutBlockInput> =
  z
    .object({
      where: z.lazy(() => InventoryScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => InventoryUpdateManyMutationInputSchema),
        z.lazy(() => InventoryUncheckedUpdateManyWithoutBlockInputSchema)
      ])
    })
    .strict();

export const InventoryScalarWhereInputSchema: z.ZodType<Prisma.InventoryScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => InventoryScalarWhereInputSchema),
          z.lazy(() => InventoryScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => InventoryScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => InventoryScalarWhereInputSchema),
          z.lazy(() => InventoryScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      slug: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      sku: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      basePrice: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      active: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      isFeatured: z
        .union([z.lazy(() => BoolFilterSchema), z.boolean()])
        .optional(),
      metaTitle: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      metaDescription: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      tags: z.lazy(() => StringNullableListFilterSchema).optional(),
      stock: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      categoryId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      blockId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const SiteCreateWithoutLikesInputSchema: z.ZodType<Prisma.SiteCreateWithoutLikesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      display_name: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      font: z.string().optional(),
      image: z.string().optional().nullable(),
      imageBlurhash: z.string().optional().nullable(),
      subdomain: z.string().optional().nullable(),
      customDomain: z.string().optional().nullable(),
      message404: z.string().optional().nullable(),
      background: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutSitesInputSchema),
      blocks: z
        .lazy(() => BlockCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      subscribers: z
        .lazy(() => SubscriberCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutSiteInputSchema).optional()
    })
    .strict();

export const SiteUncheckedCreateWithoutLikesInputSchema: z.ZodType<Prisma.SiteUncheckedCreateWithoutLikesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      display_name: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      font: z.string().optional(),
      image: z.string().optional().nullable(),
      imageBlurhash: z.string().optional().nullable(),
      subdomain: z.string().optional().nullable(),
      customDomain: z.string().optional().nullable(),
      message404: z.string().optional().nullable(),
      background: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string(),
      blocks: z
        .lazy(() => BlockUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      subscribers: z
        .lazy(() => SubscriberUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional()
    })
    .strict();

export const SiteCreateOrConnectWithoutLikesInputSchema: z.ZodType<Prisma.SiteCreateOrConnectWithoutLikesInput> =
  z
    .object({
      where: z.lazy(() => SiteWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => SiteCreateWithoutLikesInputSchema),
        z.lazy(() => SiteUncheckedCreateWithoutLikesInputSchema)
      ])
    })
    .strict();

export const UserCreateWithoutLikesInputSchema: z.ZodType<Prisma.UserCreateWithoutLikesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutLikesInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutLikesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutLikesInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutLikesInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutLikesInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutLikesInputSchema)
      ])
    })
    .strict();

export const FeedCreateWithoutLikesInputSchema: z.ZodType<Prisma.FeedCreateWithoutLikesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => FeedTypeSchema).optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      site: z.lazy(() => SiteCreateNestedOneWithoutFeedInputSchema),
      user: z.lazy(() => UserCreateNestedOneWithoutFeedInputSchema),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutFeedInputSchema)
        .optional()
    })
    .strict();

export const FeedUncheckedCreateWithoutLikesInputSchema: z.ZodType<Prisma.FeedUncheckedCreateWithoutLikesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => FeedTypeSchema).optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      siteId: z.string(),
      userId: z.string(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutFeedInputSchema)
        .optional()
    })
    .strict();

export const FeedCreateOrConnectWithoutLikesInputSchema: z.ZodType<Prisma.FeedCreateOrConnectWithoutLikesInput> =
  z
    .object({
      where: z.lazy(() => FeedWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => FeedCreateWithoutLikesInputSchema),
        z.lazy(() => FeedUncheckedCreateWithoutLikesInputSchema)
      ])
    })
    .strict();

export const SiteUpsertWithoutLikesInputSchema: z.ZodType<Prisma.SiteUpsertWithoutLikesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => SiteUpdateWithoutLikesInputSchema),
        z.lazy(() => SiteUncheckedUpdateWithoutLikesInputSchema)
      ]),
      create: z.union([
        z.lazy(() => SiteCreateWithoutLikesInputSchema),
        z.lazy(() => SiteUncheckedCreateWithoutLikesInputSchema)
      ]),
      where: z.lazy(() => SiteWhereInputSchema).optional()
    })
    .strict();

export const SiteUpdateToOneWithWhereWithoutLikesInputSchema: z.ZodType<Prisma.SiteUpdateToOneWithWhereWithoutLikesInput> =
  z
    .object({
      where: z.lazy(() => SiteWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => SiteUpdateWithoutLikesInputSchema),
        z.lazy(() => SiteUncheckedUpdateWithoutLikesInputSchema)
      ])
    })
    .strict();

export const SiteUpdateWithoutLikesInputSchema: z.ZodType<Prisma.SiteUpdateWithoutLikesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      display_name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      font: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      imageBlurhash: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subdomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      customDomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      message404: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      background: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutSitesNestedInputSchema)
        .optional(),
      blocks: z
        .lazy(() => BlockUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      subscribers: z
        .lazy(() => SubscriberUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutSiteNestedInputSchema).optional()
    })
    .strict();

export const SiteUncheckedUpdateWithoutLikesInputSchema: z.ZodType<Prisma.SiteUncheckedUpdateWithoutLikesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      display_name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      font: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      imageBlurhash: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subdomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      customDomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      message404: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      background: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blocks: z
        .lazy(() => BlockUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      subscribers: z
        .lazy(() => SubscriberUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUpsertWithoutLikesInputSchema: z.ZodType<Prisma.UserUpsertWithoutLikesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutLikesInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutLikesInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutLikesInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutLikesInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutLikesInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutLikesInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutLikesInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutLikesInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutLikesInputSchema: z.ZodType<Prisma.UserUpdateWithoutLikesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutLikesInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutLikesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const FeedUpsertWithoutLikesInputSchema: z.ZodType<Prisma.FeedUpsertWithoutLikesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => FeedUpdateWithoutLikesInputSchema),
        z.lazy(() => FeedUncheckedUpdateWithoutLikesInputSchema)
      ]),
      create: z.union([
        z.lazy(() => FeedCreateWithoutLikesInputSchema),
        z.lazy(() => FeedUncheckedCreateWithoutLikesInputSchema)
      ]),
      where: z.lazy(() => FeedWhereInputSchema).optional()
    })
    .strict();

export const FeedUpdateToOneWithWhereWithoutLikesInputSchema: z.ZodType<Prisma.FeedUpdateToOneWithWhereWithoutLikesInput> =
  z
    .object({
      where: z.lazy(() => FeedWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => FeedUpdateWithoutLikesInputSchema),
        z.lazy(() => FeedUncheckedUpdateWithoutLikesInputSchema)
      ])
    })
    .strict();

export const FeedUpdateWithoutLikesInputSchema: z.ZodType<Prisma.FeedUpdateWithoutLikesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => FeedTypeSchema),
          z.lazy(() => EnumFeedTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      site: z
        .lazy(() => SiteUpdateOneRequiredWithoutFeedNestedInputSchema)
        .optional(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutFeedNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutFeedNestedInputSchema)
        .optional()
    })
    .strict();

export const FeedUncheckedUpdateWithoutLikesInputSchema: z.ZodType<Prisma.FeedUncheckedUpdateWithoutLikesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => FeedTypeSchema),
          z.lazy(() => EnumFeedTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutFeedNestedInputSchema)
        .optional()
    })
    .strict();

export const UserCreateWithoutSitesInputSchema: z.ZodType<Prisma.UserCreateWithoutSitesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutSitesInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutSitesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutSitesInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutSitesInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutSitesInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutSitesInputSchema)
      ])
    })
    .strict();

export const BlockCreateWithoutSiteInputSchema: z.ZodType<Prisma.BlockCreateWithoutSiteInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string(),
      position: z.number().int().optional(),
      label: z.string().optional().nullable(),
      href: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      categories: z
        .lazy(() => CategoryCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      inventories: z
        .lazy(() => InventoryCreateNestedManyWithoutBlockInputSchema)
        .optional()
    })
    .strict();

export const BlockUncheckedCreateWithoutSiteInputSchema: z.ZodType<Prisma.BlockUncheckedCreateWithoutSiteInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string(),
      position: z.number().int().optional(),
      label: z.string().optional().nullable(),
      href: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUncheckedCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      categories: z
        .lazy(() => CategoryUncheckedCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      inventories: z
        .lazy(() => InventoryUncheckedCreateNestedManyWithoutBlockInputSchema)
        .optional()
    })
    .strict();

export const BlockCreateOrConnectWithoutSiteInputSchema: z.ZodType<Prisma.BlockCreateOrConnectWithoutSiteInput> =
  z
    .object({
      where: z.lazy(() => BlockWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => BlockCreateWithoutSiteInputSchema),
        z.lazy(() => BlockUncheckedCreateWithoutSiteInputSchema)
      ])
    })
    .strict();

export const BlockCreateManySiteInputEnvelopeSchema: z.ZodType<Prisma.BlockCreateManySiteInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => BlockCreateManySiteInputSchema),
        z.lazy(() => BlockCreateManySiteInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ClickCreateWithoutSiteInputSchema: z.ZodType<Prisma.ClickCreateWithoutSiteInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      part: z.string().optional().nullable(),
      path: z.string().optional().nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      block: z
        .lazy(() => BlockCreateNestedOneWithoutClicksInputSchema)
        .optional(),
      link: z
        .lazy(() => LinkCreateNestedOneWithoutClicksInputSchema)
        .optional(),
      user: z
        .lazy(() => UserCreateNestedOneWithoutClicksInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutReferralsInputSchema)
        .optional()
    })
    .strict();

export const ClickUncheckedCreateWithoutSiteInputSchema: z.ZodType<Prisma.ClickUncheckedCreateWithoutSiteInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      part: z.string().optional().nullable(),
      path: z.string().optional().nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      blockId: z.string().optional().nullable(),
      linkId: z.string().optional().nullable(),
      userId: z.string().optional().nullable(),
      refererId: z.string().optional().nullable()
    })
    .strict();

export const ClickCreateOrConnectWithoutSiteInputSchema: z.ZodType<Prisma.ClickCreateOrConnectWithoutSiteInput> =
  z
    .object({
      where: z.lazy(() => ClickWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ClickCreateWithoutSiteInputSchema),
        z.lazy(() => ClickUncheckedCreateWithoutSiteInputSchema)
      ])
    })
    .strict();

export const ClickCreateManySiteInputEnvelopeSchema: z.ZodType<Prisma.ClickCreateManySiteInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ClickCreateManySiteInputSchema),
        z.lazy(() => ClickCreateManySiteInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const SubscriberCreateWithoutSiteInputSchema: z.ZodType<Prisma.SubscriberCreateWithoutSiteInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const SubscriberUncheckedCreateWithoutSiteInputSchema: z.ZodType<Prisma.SubscriberUncheckedCreateWithoutSiteInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const SubscriberCreateOrConnectWithoutSiteInputSchema: z.ZodType<Prisma.SubscriberCreateOrConnectWithoutSiteInput> =
  z
    .object({
      where: z.lazy(() => SubscriberWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => SubscriberCreateWithoutSiteInputSchema),
        z.lazy(() => SubscriberUncheckedCreateWithoutSiteInputSchema)
      ])
    })
    .strict();

export const SubscriberCreateManySiteInputEnvelopeSchema: z.ZodType<Prisma.SubscriberCreateManySiteInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => SubscriberCreateManySiteInputSchema),
        z.lazy(() => SubscriberCreateManySiteInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const LikeCreateWithoutSiteInputSchema: z.ZodType<Prisma.LikeCreateWithoutSiteInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      ip: z.string(),
      createdAt: z.coerce.date().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutLikesInputSchema).optional(),
      feed: z.lazy(() => FeedCreateNestedOneWithoutLikesInputSchema).optional()
    })
    .strict();

export const LikeUncheckedCreateWithoutSiteInputSchema: z.ZodType<Prisma.LikeUncheckedCreateWithoutSiteInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      ip: z.string(),
      createdAt: z.coerce.date().optional(),
      userId: z.string().optional().nullable(),
      feedId: z.string().optional().nullable()
    })
    .strict();

export const LikeCreateOrConnectWithoutSiteInputSchema: z.ZodType<Prisma.LikeCreateOrConnectWithoutSiteInput> =
  z
    .object({
      where: z.lazy(() => LikeWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => LikeCreateWithoutSiteInputSchema),
        z.lazy(() => LikeUncheckedCreateWithoutSiteInputSchema)
      ])
    })
    .strict();

export const LikeCreateManySiteInputEnvelopeSchema: z.ZodType<Prisma.LikeCreateManySiteInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => LikeCreateManySiteInputSchema),
        z.lazy(() => LikeCreateManySiteInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const FeedCreateWithoutSiteInputSchema: z.ZodType<Prisma.FeedCreateWithoutSiteInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => FeedTypeSchema).optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutFeedInputSchema),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutFeedInputSchema)
        .optional(),
      likes: z.lazy(() => LikeCreateNestedManyWithoutFeedInputSchema).optional()
    })
    .strict();

export const FeedUncheckedCreateWithoutSiteInputSchema: z.ZodType<Prisma.FeedUncheckedCreateWithoutSiteInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => FeedTypeSchema).optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutFeedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutFeedInputSchema)
        .optional()
    })
    .strict();

export const FeedCreateOrConnectWithoutSiteInputSchema: z.ZodType<Prisma.FeedCreateOrConnectWithoutSiteInput> =
  z
    .object({
      where: z.lazy(() => FeedWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => FeedCreateWithoutSiteInputSchema),
        z.lazy(() => FeedUncheckedCreateWithoutSiteInputSchema)
      ])
    })
    .strict();

export const FeedCreateManySiteInputEnvelopeSchema: z.ZodType<Prisma.FeedCreateManySiteInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => FeedCreateManySiteInputSchema),
        z.lazy(() => FeedCreateManySiteInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const UserUpsertWithoutSitesInputSchema: z.ZodType<Prisma.UserUpsertWithoutSitesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutSitesInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutSitesInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutSitesInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutSitesInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutSitesInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutSitesInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutSitesInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutSitesInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutSitesInputSchema: z.ZodType<Prisma.UserUpdateWithoutSitesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutSitesInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutSitesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const BlockUpsertWithWhereUniqueWithoutSiteInputSchema: z.ZodType<Prisma.BlockUpsertWithWhereUniqueWithoutSiteInput> =
  z
    .object({
      where: z.lazy(() => BlockWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => BlockUpdateWithoutSiteInputSchema),
        z.lazy(() => BlockUncheckedUpdateWithoutSiteInputSchema)
      ]),
      create: z.union([
        z.lazy(() => BlockCreateWithoutSiteInputSchema),
        z.lazy(() => BlockUncheckedCreateWithoutSiteInputSchema)
      ])
    })
    .strict();

export const BlockUpdateWithWhereUniqueWithoutSiteInputSchema: z.ZodType<Prisma.BlockUpdateWithWhereUniqueWithoutSiteInput> =
  z
    .object({
      where: z.lazy(() => BlockWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => BlockUpdateWithoutSiteInputSchema),
        z.lazy(() => BlockUncheckedUpdateWithoutSiteInputSchema)
      ])
    })
    .strict();

export const BlockUpdateManyWithWhereWithoutSiteInputSchema: z.ZodType<Prisma.BlockUpdateManyWithWhereWithoutSiteInput> =
  z
    .object({
      where: z.lazy(() => BlockScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => BlockUpdateManyMutationInputSchema),
        z.lazy(() => BlockUncheckedUpdateManyWithoutSiteInputSchema)
      ])
    })
    .strict();

export const BlockScalarWhereInputSchema: z.ZodType<Prisma.BlockScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => BlockScalarWhereInputSchema),
          z.lazy(() => BlockScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => BlockScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => BlockScalarWhereInputSchema),
          z.lazy(() => BlockScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      type: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      position: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      label: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      href: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      logo: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      style: z.lazy(() => JsonNullableFilterSchema).optional(),
      widget: z.lazy(() => JsonNullableFilterSchema).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      siteId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional()
    })
    .strict();

export const ClickUpsertWithWhereUniqueWithoutSiteInputSchema: z.ZodType<Prisma.ClickUpsertWithWhereUniqueWithoutSiteInput> =
  z
    .object({
      where: z.lazy(() => ClickWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ClickUpdateWithoutSiteInputSchema),
        z.lazy(() => ClickUncheckedUpdateWithoutSiteInputSchema)
      ]),
      create: z.union([
        z.lazy(() => ClickCreateWithoutSiteInputSchema),
        z.lazy(() => ClickUncheckedCreateWithoutSiteInputSchema)
      ])
    })
    .strict();

export const ClickUpdateWithWhereUniqueWithoutSiteInputSchema: z.ZodType<Prisma.ClickUpdateWithWhereUniqueWithoutSiteInput> =
  z
    .object({
      where: z.lazy(() => ClickWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ClickUpdateWithoutSiteInputSchema),
        z.lazy(() => ClickUncheckedUpdateWithoutSiteInputSchema)
      ])
    })
    .strict();

export const ClickUpdateManyWithWhereWithoutSiteInputSchema: z.ZodType<Prisma.ClickUpdateManyWithWhereWithoutSiteInput> =
  z
    .object({
      where: z.lazy(() => ClickScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ClickUpdateManyMutationInputSchema),
        z.lazy(() => ClickUncheckedUpdateManyWithoutSiteInputSchema)
      ])
    })
    .strict();

export const SubscriberUpsertWithWhereUniqueWithoutSiteInputSchema: z.ZodType<Prisma.SubscriberUpsertWithWhereUniqueWithoutSiteInput> =
  z
    .object({
      where: z.lazy(() => SubscriberWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => SubscriberUpdateWithoutSiteInputSchema),
        z.lazy(() => SubscriberUncheckedUpdateWithoutSiteInputSchema)
      ]),
      create: z.union([
        z.lazy(() => SubscriberCreateWithoutSiteInputSchema),
        z.lazy(() => SubscriberUncheckedCreateWithoutSiteInputSchema)
      ])
    })
    .strict();

export const SubscriberUpdateWithWhereUniqueWithoutSiteInputSchema: z.ZodType<Prisma.SubscriberUpdateWithWhereUniqueWithoutSiteInput> =
  z
    .object({
      where: z.lazy(() => SubscriberWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => SubscriberUpdateWithoutSiteInputSchema),
        z.lazy(() => SubscriberUncheckedUpdateWithoutSiteInputSchema)
      ])
    })
    .strict();

export const SubscriberUpdateManyWithWhereWithoutSiteInputSchema: z.ZodType<Prisma.SubscriberUpdateManyWithWhereWithoutSiteInput> =
  z
    .object({
      where: z.lazy(() => SubscriberScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => SubscriberUpdateManyMutationInputSchema),
        z.lazy(() => SubscriberUncheckedUpdateManyWithoutSiteInputSchema)
      ])
    })
    .strict();

export const SubscriberScalarWhereInputSchema: z.ZodType<Prisma.SubscriberScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => SubscriberScalarWhereInputSchema),
          z.lazy(() => SubscriberScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => SubscriberScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => SubscriberScalarWhereInputSchema),
          z.lazy(() => SubscriberScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      email: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      siteId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional()
    })
    .strict();

export const LikeUpsertWithWhereUniqueWithoutSiteInputSchema: z.ZodType<Prisma.LikeUpsertWithWhereUniqueWithoutSiteInput> =
  z
    .object({
      where: z.lazy(() => LikeWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => LikeUpdateWithoutSiteInputSchema),
        z.lazy(() => LikeUncheckedUpdateWithoutSiteInputSchema)
      ]),
      create: z.union([
        z.lazy(() => LikeCreateWithoutSiteInputSchema),
        z.lazy(() => LikeUncheckedCreateWithoutSiteInputSchema)
      ])
    })
    .strict();

export const LikeUpdateWithWhereUniqueWithoutSiteInputSchema: z.ZodType<Prisma.LikeUpdateWithWhereUniqueWithoutSiteInput> =
  z
    .object({
      where: z.lazy(() => LikeWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => LikeUpdateWithoutSiteInputSchema),
        z.lazy(() => LikeUncheckedUpdateWithoutSiteInputSchema)
      ])
    })
    .strict();

export const LikeUpdateManyWithWhereWithoutSiteInputSchema: z.ZodType<Prisma.LikeUpdateManyWithWhereWithoutSiteInput> =
  z
    .object({
      where: z.lazy(() => LikeScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => LikeUpdateManyMutationInputSchema),
        z.lazy(() => LikeUncheckedUpdateManyWithoutSiteInputSchema)
      ])
    })
    .strict();

export const FeedUpsertWithWhereUniqueWithoutSiteInputSchema: z.ZodType<Prisma.FeedUpsertWithWhereUniqueWithoutSiteInput> =
  z
    .object({
      where: z.lazy(() => FeedWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => FeedUpdateWithoutSiteInputSchema),
        z.lazy(() => FeedUncheckedUpdateWithoutSiteInputSchema)
      ]),
      create: z.union([
        z.lazy(() => FeedCreateWithoutSiteInputSchema),
        z.lazy(() => FeedUncheckedCreateWithoutSiteInputSchema)
      ])
    })
    .strict();

export const FeedUpdateWithWhereUniqueWithoutSiteInputSchema: z.ZodType<Prisma.FeedUpdateWithWhereUniqueWithoutSiteInput> =
  z
    .object({
      where: z.lazy(() => FeedWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => FeedUpdateWithoutSiteInputSchema),
        z.lazy(() => FeedUncheckedUpdateWithoutSiteInputSchema)
      ])
    })
    .strict();

export const FeedUpdateManyWithWhereWithoutSiteInputSchema: z.ZodType<Prisma.FeedUpdateManyWithWhereWithoutSiteInput> =
  z
    .object({
      where: z.lazy(() => FeedScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => FeedUpdateManyMutationInputSchema),
        z.lazy(() => FeedUncheckedUpdateManyWithoutSiteInputSchema)
      ])
    })
    .strict();

export const FeedScalarWhereInputSchema: z.ZodType<Prisma.FeedScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => FeedScalarWhereInputSchema),
          z.lazy(() => FeedScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => FeedScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => FeedScalarWhereInputSchema),
          z.lazy(() => FeedScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      type: z
        .union([
          z.lazy(() => EnumFeedTypeFilterSchema),
          z.lazy(() => FeedTypeSchema)
        ])
        .optional(),
      content: z.lazy(() => JsonFilterSchema).optional(),
      commentable: z
        .union([z.lazy(() => BoolFilterSchema), z.boolean()])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      siteId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional()
    })
    .strict();

export const SiteCreateWithoutSubscribersInputSchema: z.ZodType<Prisma.SiteCreateWithoutSubscribersInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      display_name: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      font: z.string().optional(),
      image: z.string().optional().nullable(),
      imageBlurhash: z.string().optional().nullable(),
      subdomain: z.string().optional().nullable(),
      customDomain: z.string().optional().nullable(),
      message404: z.string().optional().nullable(),
      background: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutSitesInputSchema),
      blocks: z
        .lazy(() => BlockCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutSiteInputSchema).optional()
    })
    .strict();

export const SiteUncheckedCreateWithoutSubscribersInputSchema: z.ZodType<Prisma.SiteUncheckedCreateWithoutSubscribersInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      display_name: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      font: z.string().optional(),
      image: z.string().optional().nullable(),
      imageBlurhash: z.string().optional().nullable(),
      subdomain: z.string().optional().nullable(),
      customDomain: z.string().optional().nullable(),
      message404: z.string().optional().nullable(),
      background: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string(),
      blocks: z
        .lazy(() => BlockUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional()
    })
    .strict();

export const SiteCreateOrConnectWithoutSubscribersInputSchema: z.ZodType<Prisma.SiteCreateOrConnectWithoutSubscribersInput> =
  z
    .object({
      where: z.lazy(() => SiteWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => SiteCreateWithoutSubscribersInputSchema),
        z.lazy(() => SiteUncheckedCreateWithoutSubscribersInputSchema)
      ])
    })
    .strict();

export const SiteUpsertWithoutSubscribersInputSchema: z.ZodType<Prisma.SiteUpsertWithoutSubscribersInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => SiteUpdateWithoutSubscribersInputSchema),
        z.lazy(() => SiteUncheckedUpdateWithoutSubscribersInputSchema)
      ]),
      create: z.union([
        z.lazy(() => SiteCreateWithoutSubscribersInputSchema),
        z.lazy(() => SiteUncheckedCreateWithoutSubscribersInputSchema)
      ]),
      where: z.lazy(() => SiteWhereInputSchema).optional()
    })
    .strict();

export const SiteUpdateToOneWithWhereWithoutSubscribersInputSchema: z.ZodType<Prisma.SiteUpdateToOneWithWhereWithoutSubscribersInput> =
  z
    .object({
      where: z.lazy(() => SiteWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => SiteUpdateWithoutSubscribersInputSchema),
        z.lazy(() => SiteUncheckedUpdateWithoutSubscribersInputSchema)
      ])
    })
    .strict();

export const SiteUpdateWithoutSubscribersInputSchema: z.ZodType<Prisma.SiteUpdateWithoutSubscribersInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      display_name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      font: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      imageBlurhash: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subdomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      customDomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      message404: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      background: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutSitesNestedInputSchema)
        .optional(),
      blocks: z
        .lazy(() => BlockUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutSiteNestedInputSchema).optional()
    })
    .strict();

export const SiteUncheckedUpdateWithoutSubscribersInputSchema: z.ZodType<Prisma.SiteUncheckedUpdateWithoutSubscribersInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      display_name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      font: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      imageBlurhash: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subdomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      customDomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      message404: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      background: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blocks: z
        .lazy(() => BlockUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional()
    })
    .strict();

export const BlockCreateWithoutReservationsInputSchema: z.ZodType<Prisma.BlockCreateWithoutReservationsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string(),
      position: z.number().int().optional(),
      label: z.string().optional().nullable(),
      href: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      site: z.lazy(() => SiteCreateNestedOneWithoutBlocksInputSchema),
      categories: z
        .lazy(() => CategoryCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      inventories: z
        .lazy(() => InventoryCreateNestedManyWithoutBlockInputSchema)
        .optional()
    })
    .strict();

export const BlockUncheckedCreateWithoutReservationsInputSchema: z.ZodType<Prisma.BlockUncheckedCreateWithoutReservationsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string(),
      position: z.number().int().optional(),
      label: z.string().optional().nullable(),
      href: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      siteId: z.string(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      categories: z
        .lazy(() => CategoryUncheckedCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      inventories: z
        .lazy(() => InventoryUncheckedCreateNestedManyWithoutBlockInputSchema)
        .optional()
    })
    .strict();

export const BlockCreateOrConnectWithoutReservationsInputSchema: z.ZodType<Prisma.BlockCreateOrConnectWithoutReservationsInput> =
  z
    .object({
      where: z.lazy(() => BlockWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => BlockCreateWithoutReservationsInputSchema),
        z.lazy(() => BlockUncheckedCreateWithoutReservationsInputSchema)
      ])
    })
    .strict();

export const UserCreateWithoutReservationsInputSchema: z.ZodType<Prisma.UserCreateWithoutReservationsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutReservationsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutReservationsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutReservationsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutReservationsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutReservationsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutReservationsInputSchema)
      ])
    })
    .strict();

export const BlockUpsertWithoutReservationsInputSchema: z.ZodType<Prisma.BlockUpsertWithoutReservationsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => BlockUpdateWithoutReservationsInputSchema),
        z.lazy(() => BlockUncheckedUpdateWithoutReservationsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => BlockCreateWithoutReservationsInputSchema),
        z.lazy(() => BlockUncheckedCreateWithoutReservationsInputSchema)
      ]),
      where: z.lazy(() => BlockWhereInputSchema).optional()
    })
    .strict();

export const BlockUpdateToOneWithWhereWithoutReservationsInputSchema: z.ZodType<Prisma.BlockUpdateToOneWithWhereWithoutReservationsInput> =
  z
    .object({
      where: z.lazy(() => BlockWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => BlockUpdateWithoutReservationsInputSchema),
        z.lazy(() => BlockUncheckedUpdateWithoutReservationsInputSchema)
      ])
    })
    .strict();

export const BlockUpdateWithoutReservationsInputSchema: z.ZodType<Prisma.BlockUpdateWithoutReservationsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      label: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      href: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      site: z
        .lazy(() => SiteUpdateOneRequiredWithoutBlocksNestedInputSchema)
        .optional(),
      categories: z
        .lazy(() => CategoryUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      inventories: z
        .lazy(() => InventoryUpdateManyWithoutBlockNestedInputSchema)
        .optional()
    })
    .strict();

export const BlockUncheckedUpdateWithoutReservationsInputSchema: z.ZodType<Prisma.BlockUncheckedUpdateWithoutReservationsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      label: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      href: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      categories: z
        .lazy(() => CategoryUncheckedUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      inventories: z
        .lazy(() => InventoryUncheckedUpdateManyWithoutBlockNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUpsertWithoutReservationsInputSchema: z.ZodType<Prisma.UserUpsertWithoutReservationsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutReservationsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutReservationsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutReservationsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutReservationsInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutReservationsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutReservationsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutReservationsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutReservationsInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutReservationsInputSchema: z.ZodType<Prisma.UserUpdateWithoutReservationsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutReservationsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutReservationsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const InventoryCreateWithoutCategoryInputSchema: z.ZodType<Prisma.InventoryCreateWithoutCategoryInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      sku: z.string().optional().nullable(),
      basePrice: z.number(),
      active: z.boolean().optional(),
      isFeatured: z.boolean().optional(),
      metaTitle: z.string().optional().nullable(),
      metaDescription: z.string().optional().nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryCreatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      variants: z
        .lazy(() => InventoryVariantCreateNestedManyWithoutInventoryInputSchema)
        .optional(),
      block: z.lazy(() => BlockCreateNestedOneWithoutInventoriesInputSchema)
    })
    .strict();

export const InventoryUncheckedCreateWithoutCategoryInputSchema: z.ZodType<Prisma.InventoryUncheckedCreateWithoutCategoryInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      sku: z.string().optional().nullable(),
      basePrice: z.number(),
      active: z.boolean().optional(),
      isFeatured: z.boolean().optional(),
      metaTitle: z.string().optional().nullable(),
      metaDescription: z.string().optional().nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryCreatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      blockId: z.string(),
      variants: z
        .lazy(
          () =>
            InventoryVariantUncheckedCreateNestedManyWithoutInventoryInputSchema
        )
        .optional()
    })
    .strict();

export const InventoryCreateOrConnectWithoutCategoryInputSchema: z.ZodType<Prisma.InventoryCreateOrConnectWithoutCategoryInput> =
  z
    .object({
      where: z.lazy(() => InventoryWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => InventoryCreateWithoutCategoryInputSchema),
        z.lazy(() => InventoryUncheckedCreateWithoutCategoryInputSchema)
      ])
    })
    .strict();

export const InventoryCreateManyCategoryInputEnvelopeSchema: z.ZodType<Prisma.InventoryCreateManyCategoryInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => InventoryCreateManyCategoryInputSchema),
        z.lazy(() => InventoryCreateManyCategoryInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const CategoryCreateWithoutCategoryInputSchema: z.ZodType<Prisma.CategoryCreateWithoutCategoryInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      active: z.boolean().optional(),
      position: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      inventories: z
        .lazy(() => InventoryCreateNestedManyWithoutCategoryInputSchema)
        .optional(),
      categories: z
        .lazy(() => CategoryCreateNestedManyWithoutCategoryInputSchema)
        .optional(),
      block: z.lazy(() => BlockCreateNestedOneWithoutCategoriesInputSchema)
    })
    .strict();

export const CategoryUncheckedCreateWithoutCategoryInputSchema: z.ZodType<Prisma.CategoryUncheckedCreateWithoutCategoryInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      active: z.boolean().optional(),
      position: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      blockId: z.string(),
      inventories: z
        .lazy(
          () => InventoryUncheckedCreateNestedManyWithoutCategoryInputSchema
        )
        .optional(),
      categories: z
        .lazy(() => CategoryUncheckedCreateNestedManyWithoutCategoryInputSchema)
        .optional()
    })
    .strict();

export const CategoryCreateOrConnectWithoutCategoryInputSchema: z.ZodType<Prisma.CategoryCreateOrConnectWithoutCategoryInput> =
  z
    .object({
      where: z.lazy(() => CategoryWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CategoryCreateWithoutCategoryInputSchema),
        z.lazy(() => CategoryUncheckedCreateWithoutCategoryInputSchema)
      ])
    })
    .strict();

export const CategoryCreateManyCategoryInputEnvelopeSchema: z.ZodType<Prisma.CategoryCreateManyCategoryInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => CategoryCreateManyCategoryInputSchema),
        z.lazy(() => CategoryCreateManyCategoryInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const CategoryCreateWithoutCategoriesInputSchema: z.ZodType<Prisma.CategoryCreateWithoutCategoriesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      active: z.boolean().optional(),
      position: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      inventories: z
        .lazy(() => InventoryCreateNestedManyWithoutCategoryInputSchema)
        .optional(),
      category: z
        .lazy(() => CategoryCreateNestedOneWithoutCategoriesInputSchema)
        .optional(),
      block: z.lazy(() => BlockCreateNestedOneWithoutCategoriesInputSchema)
    })
    .strict();

export const CategoryUncheckedCreateWithoutCategoriesInputSchema: z.ZodType<Prisma.CategoryUncheckedCreateWithoutCategoriesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      active: z.boolean().optional(),
      position: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      categoryId: z.string().optional().nullable(),
      blockId: z.string(),
      inventories: z
        .lazy(
          () => InventoryUncheckedCreateNestedManyWithoutCategoryInputSchema
        )
        .optional()
    })
    .strict();

export const CategoryCreateOrConnectWithoutCategoriesInputSchema: z.ZodType<Prisma.CategoryCreateOrConnectWithoutCategoriesInput> =
  z
    .object({
      where: z.lazy(() => CategoryWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CategoryCreateWithoutCategoriesInputSchema),
        z.lazy(() => CategoryUncheckedCreateWithoutCategoriesInputSchema)
      ])
    })
    .strict();

export const BlockCreateWithoutCategoriesInputSchema: z.ZodType<Prisma.BlockCreateWithoutCategoriesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string(),
      position: z.number().int().optional(),
      label: z.string().optional().nullable(),
      href: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      site: z.lazy(() => SiteCreateNestedOneWithoutBlocksInputSchema),
      inventories: z
        .lazy(() => InventoryCreateNestedManyWithoutBlockInputSchema)
        .optional()
    })
    .strict();

export const BlockUncheckedCreateWithoutCategoriesInputSchema: z.ZodType<Prisma.BlockUncheckedCreateWithoutCategoriesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string(),
      position: z.number().int().optional(),
      label: z.string().optional().nullable(),
      href: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      siteId: z.string(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUncheckedCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      inventories: z
        .lazy(() => InventoryUncheckedCreateNestedManyWithoutBlockInputSchema)
        .optional()
    })
    .strict();

export const BlockCreateOrConnectWithoutCategoriesInputSchema: z.ZodType<Prisma.BlockCreateOrConnectWithoutCategoriesInput> =
  z
    .object({
      where: z.lazy(() => BlockWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => BlockCreateWithoutCategoriesInputSchema),
        z.lazy(() => BlockUncheckedCreateWithoutCategoriesInputSchema)
      ])
    })
    .strict();

export const InventoryUpsertWithWhereUniqueWithoutCategoryInputSchema: z.ZodType<Prisma.InventoryUpsertWithWhereUniqueWithoutCategoryInput> =
  z
    .object({
      where: z.lazy(() => InventoryWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => InventoryUpdateWithoutCategoryInputSchema),
        z.lazy(() => InventoryUncheckedUpdateWithoutCategoryInputSchema)
      ]),
      create: z.union([
        z.lazy(() => InventoryCreateWithoutCategoryInputSchema),
        z.lazy(() => InventoryUncheckedCreateWithoutCategoryInputSchema)
      ])
    })
    .strict();

export const InventoryUpdateWithWhereUniqueWithoutCategoryInputSchema: z.ZodType<Prisma.InventoryUpdateWithWhereUniqueWithoutCategoryInput> =
  z
    .object({
      where: z.lazy(() => InventoryWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => InventoryUpdateWithoutCategoryInputSchema),
        z.lazy(() => InventoryUncheckedUpdateWithoutCategoryInputSchema)
      ])
    })
    .strict();

export const InventoryUpdateManyWithWhereWithoutCategoryInputSchema: z.ZodType<Prisma.InventoryUpdateManyWithWhereWithoutCategoryInput> =
  z
    .object({
      where: z.lazy(() => InventoryScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => InventoryUpdateManyMutationInputSchema),
        z.lazy(() => InventoryUncheckedUpdateManyWithoutCategoryInputSchema)
      ])
    })
    .strict();

export const CategoryUpsertWithWhereUniqueWithoutCategoryInputSchema: z.ZodType<Prisma.CategoryUpsertWithWhereUniqueWithoutCategoryInput> =
  z
    .object({
      where: z.lazy(() => CategoryWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => CategoryUpdateWithoutCategoryInputSchema),
        z.lazy(() => CategoryUncheckedUpdateWithoutCategoryInputSchema)
      ]),
      create: z.union([
        z.lazy(() => CategoryCreateWithoutCategoryInputSchema),
        z.lazy(() => CategoryUncheckedCreateWithoutCategoryInputSchema)
      ])
    })
    .strict();

export const CategoryUpdateWithWhereUniqueWithoutCategoryInputSchema: z.ZodType<Prisma.CategoryUpdateWithWhereUniqueWithoutCategoryInput> =
  z
    .object({
      where: z.lazy(() => CategoryWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => CategoryUpdateWithoutCategoryInputSchema),
        z.lazy(() => CategoryUncheckedUpdateWithoutCategoryInputSchema)
      ])
    })
    .strict();

export const CategoryUpdateManyWithWhereWithoutCategoryInputSchema: z.ZodType<Prisma.CategoryUpdateManyWithWhereWithoutCategoryInput> =
  z
    .object({
      where: z.lazy(() => CategoryScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => CategoryUpdateManyMutationInputSchema),
        z.lazy(() => CategoryUncheckedUpdateManyWithoutCategoryInputSchema)
      ])
    })
    .strict();

export const CategoryUpsertWithoutCategoriesInputSchema: z.ZodType<Prisma.CategoryUpsertWithoutCategoriesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => CategoryUpdateWithoutCategoriesInputSchema),
        z.lazy(() => CategoryUncheckedUpdateWithoutCategoriesInputSchema)
      ]),
      create: z.union([
        z.lazy(() => CategoryCreateWithoutCategoriesInputSchema),
        z.lazy(() => CategoryUncheckedCreateWithoutCategoriesInputSchema)
      ]),
      where: z.lazy(() => CategoryWhereInputSchema).optional()
    })
    .strict();

export const CategoryUpdateToOneWithWhereWithoutCategoriesInputSchema: z.ZodType<Prisma.CategoryUpdateToOneWithWhereWithoutCategoriesInput> =
  z
    .object({
      where: z.lazy(() => CategoryWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => CategoryUpdateWithoutCategoriesInputSchema),
        z.lazy(() => CategoryUncheckedUpdateWithoutCategoriesInputSchema)
      ])
    })
    .strict();

export const CategoryUpdateWithoutCategoriesInputSchema: z.ZodType<Prisma.CategoryUpdateWithoutCategoriesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      inventories: z
        .lazy(() => InventoryUpdateManyWithoutCategoryNestedInputSchema)
        .optional(),
      category: z
        .lazy(() => CategoryUpdateOneWithoutCategoriesNestedInputSchema)
        .optional(),
      block: z
        .lazy(() => BlockUpdateOneRequiredWithoutCategoriesNestedInputSchema)
        .optional()
    })
    .strict();

export const CategoryUncheckedUpdateWithoutCategoriesInputSchema: z.ZodType<Prisma.CategoryUncheckedUpdateWithoutCategoriesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      categoryId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      inventories: z
        .lazy(
          () => InventoryUncheckedUpdateManyWithoutCategoryNestedInputSchema
        )
        .optional()
    })
    .strict();

export const BlockUpsertWithoutCategoriesInputSchema: z.ZodType<Prisma.BlockUpsertWithoutCategoriesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => BlockUpdateWithoutCategoriesInputSchema),
        z.lazy(() => BlockUncheckedUpdateWithoutCategoriesInputSchema)
      ]),
      create: z.union([
        z.lazy(() => BlockCreateWithoutCategoriesInputSchema),
        z.lazy(() => BlockUncheckedCreateWithoutCategoriesInputSchema)
      ]),
      where: z.lazy(() => BlockWhereInputSchema).optional()
    })
    .strict();

export const BlockUpdateToOneWithWhereWithoutCategoriesInputSchema: z.ZodType<Prisma.BlockUpdateToOneWithWhereWithoutCategoriesInput> =
  z
    .object({
      where: z.lazy(() => BlockWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => BlockUpdateWithoutCategoriesInputSchema),
        z.lazy(() => BlockUncheckedUpdateWithoutCategoriesInputSchema)
      ])
    })
    .strict();

export const BlockUpdateWithoutCategoriesInputSchema: z.ZodType<Prisma.BlockUpdateWithoutCategoriesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      label: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      href: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      site: z
        .lazy(() => SiteUpdateOneRequiredWithoutBlocksNestedInputSchema)
        .optional(),
      inventories: z
        .lazy(() => InventoryUpdateManyWithoutBlockNestedInputSchema)
        .optional()
    })
    .strict();

export const BlockUncheckedUpdateWithoutCategoriesInputSchema: z.ZodType<Prisma.BlockUncheckedUpdateWithoutCategoriesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      label: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      href: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUncheckedUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      inventories: z
        .lazy(() => InventoryUncheckedUpdateManyWithoutBlockNestedInputSchema)
        .optional()
    })
    .strict();

export const CategoryCreateWithoutInventoriesInputSchema: z.ZodType<Prisma.CategoryCreateWithoutInventoriesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      active: z.boolean().optional(),
      position: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      categories: z
        .lazy(() => CategoryCreateNestedManyWithoutCategoryInputSchema)
        .optional(),
      category: z
        .lazy(() => CategoryCreateNestedOneWithoutCategoriesInputSchema)
        .optional(),
      block: z.lazy(() => BlockCreateNestedOneWithoutCategoriesInputSchema)
    })
    .strict();

export const CategoryUncheckedCreateWithoutInventoriesInputSchema: z.ZodType<Prisma.CategoryUncheckedCreateWithoutInventoriesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      active: z.boolean().optional(),
      position: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      categoryId: z.string().optional().nullable(),
      blockId: z.string(),
      categories: z
        .lazy(() => CategoryUncheckedCreateNestedManyWithoutCategoryInputSchema)
        .optional()
    })
    .strict();

export const CategoryCreateOrConnectWithoutInventoriesInputSchema: z.ZodType<Prisma.CategoryCreateOrConnectWithoutInventoriesInput> =
  z
    .object({
      where: z.lazy(() => CategoryWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CategoryCreateWithoutInventoriesInputSchema),
        z.lazy(() => CategoryUncheckedCreateWithoutInventoriesInputSchema)
      ])
    })
    .strict();

export const InventoryVariantCreateWithoutInventoryInputSchema: z.ZodType<Prisma.InventoryVariantCreateWithoutInventoryInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      value: z.string(),
      type: z.lazy(() => VariantTypeSchema),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional()
        .nullable(),
      stock: z.number().int().optional(),
      active: z.boolean().optional(),
      position: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const InventoryVariantUncheckedCreateWithoutInventoryInputSchema: z.ZodType<Prisma.InventoryVariantUncheckedCreateWithoutInventoryInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      value: z.string(),
      type: z.lazy(() => VariantTypeSchema),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional()
        .nullable(),
      stock: z.number().int().optional(),
      active: z.boolean().optional(),
      position: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const InventoryVariantCreateOrConnectWithoutInventoryInputSchema: z.ZodType<Prisma.InventoryVariantCreateOrConnectWithoutInventoryInput> =
  z
    .object({
      where: z.lazy(() => InventoryVariantWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => InventoryVariantCreateWithoutInventoryInputSchema),
        z.lazy(() => InventoryVariantUncheckedCreateWithoutInventoryInputSchema)
      ])
    })
    .strict();

export const InventoryVariantCreateManyInventoryInputEnvelopeSchema: z.ZodType<Prisma.InventoryVariantCreateManyInventoryInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => InventoryVariantCreateManyInventoryInputSchema),
        z.lazy(() => InventoryVariantCreateManyInventoryInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const BlockCreateWithoutInventoriesInputSchema: z.ZodType<Prisma.BlockCreateWithoutInventoriesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string(),
      position: z.number().int().optional(),
      label: z.string().optional().nullable(),
      href: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      site: z.lazy(() => SiteCreateNestedOneWithoutBlocksInputSchema),
      categories: z
        .lazy(() => CategoryCreateNestedManyWithoutBlockInputSchema)
        .optional()
    })
    .strict();

export const BlockUncheckedCreateWithoutInventoriesInputSchema: z.ZodType<Prisma.BlockUncheckedCreateWithoutInventoriesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string(),
      position: z.number().int().optional(),
      label: z.string().optional().nullable(),
      href: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      siteId: z.string(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUncheckedCreateNestedManyWithoutBlockInputSchema)
        .optional(),
      categories: z
        .lazy(() => CategoryUncheckedCreateNestedManyWithoutBlockInputSchema)
        .optional()
    })
    .strict();

export const BlockCreateOrConnectWithoutInventoriesInputSchema: z.ZodType<Prisma.BlockCreateOrConnectWithoutInventoriesInput> =
  z
    .object({
      where: z.lazy(() => BlockWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => BlockCreateWithoutInventoriesInputSchema),
        z.lazy(() => BlockUncheckedCreateWithoutInventoriesInputSchema)
      ])
    })
    .strict();

export const CategoryUpsertWithoutInventoriesInputSchema: z.ZodType<Prisma.CategoryUpsertWithoutInventoriesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => CategoryUpdateWithoutInventoriesInputSchema),
        z.lazy(() => CategoryUncheckedUpdateWithoutInventoriesInputSchema)
      ]),
      create: z.union([
        z.lazy(() => CategoryCreateWithoutInventoriesInputSchema),
        z.lazy(() => CategoryUncheckedCreateWithoutInventoriesInputSchema)
      ]),
      where: z.lazy(() => CategoryWhereInputSchema).optional()
    })
    .strict();

export const CategoryUpdateToOneWithWhereWithoutInventoriesInputSchema: z.ZodType<Prisma.CategoryUpdateToOneWithWhereWithoutInventoriesInput> =
  z
    .object({
      where: z.lazy(() => CategoryWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => CategoryUpdateWithoutInventoriesInputSchema),
        z.lazy(() => CategoryUncheckedUpdateWithoutInventoriesInputSchema)
      ])
    })
    .strict();

export const CategoryUpdateWithoutInventoriesInputSchema: z.ZodType<Prisma.CategoryUpdateWithoutInventoriesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      categories: z
        .lazy(() => CategoryUpdateManyWithoutCategoryNestedInputSchema)
        .optional(),
      category: z
        .lazy(() => CategoryUpdateOneWithoutCategoriesNestedInputSchema)
        .optional(),
      block: z
        .lazy(() => BlockUpdateOneRequiredWithoutCategoriesNestedInputSchema)
        .optional()
    })
    .strict();

export const CategoryUncheckedUpdateWithoutInventoriesInputSchema: z.ZodType<Prisma.CategoryUncheckedUpdateWithoutInventoriesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      categoryId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      categories: z
        .lazy(() => CategoryUncheckedUpdateManyWithoutCategoryNestedInputSchema)
        .optional()
    })
    .strict();

export const InventoryVariantUpsertWithWhereUniqueWithoutInventoryInputSchema: z.ZodType<Prisma.InventoryVariantUpsertWithWhereUniqueWithoutInventoryInput> =
  z
    .object({
      where: z.lazy(() => InventoryVariantWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => InventoryVariantUpdateWithoutInventoryInputSchema),
        z.lazy(() => InventoryVariantUncheckedUpdateWithoutInventoryInputSchema)
      ]),
      create: z.union([
        z.lazy(() => InventoryVariantCreateWithoutInventoryInputSchema),
        z.lazy(() => InventoryVariantUncheckedCreateWithoutInventoryInputSchema)
      ])
    })
    .strict();

export const InventoryVariantUpdateWithWhereUniqueWithoutInventoryInputSchema: z.ZodType<Prisma.InventoryVariantUpdateWithWhereUniqueWithoutInventoryInput> =
  z
    .object({
      where: z.lazy(() => InventoryVariantWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => InventoryVariantUpdateWithoutInventoryInputSchema),
        z.lazy(() => InventoryVariantUncheckedUpdateWithoutInventoryInputSchema)
      ])
    })
    .strict();

export const InventoryVariantUpdateManyWithWhereWithoutInventoryInputSchema: z.ZodType<Prisma.InventoryVariantUpdateManyWithWhereWithoutInventoryInput> =
  z
    .object({
      where: z.lazy(() => InventoryVariantScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => InventoryVariantUpdateManyMutationInputSchema),
        z.lazy(
          () => InventoryVariantUncheckedUpdateManyWithoutInventoryInputSchema
        )
      ])
    })
    .strict();

export const InventoryVariantScalarWhereInputSchema: z.ZodType<Prisma.InventoryVariantScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => InventoryVariantScalarWhereInputSchema),
          z.lazy(() => InventoryVariantScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => InventoryVariantScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => InventoryVariantScalarWhereInputSchema),
          z.lazy(() => InventoryVariantScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      inventoryId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      value: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      type: z
        .union([
          z.lazy(() => EnumVariantTypeFilterSchema),
          z.lazy(() => VariantTypeSchema)
        ])
        .optional(),
      price: z
        .union([
          z.lazy(() => DecimalNullableFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema
            ])
            .refine(v => isValidDecimalInput(v), {
              message: 'Must be a Decimal'
            })
        ])
        .optional()
        .nullable(),
      stock: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      active: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      position: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional()
    })
    .strict();

export const BlockUpsertWithoutInventoriesInputSchema: z.ZodType<Prisma.BlockUpsertWithoutInventoriesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => BlockUpdateWithoutInventoriesInputSchema),
        z.lazy(() => BlockUncheckedUpdateWithoutInventoriesInputSchema)
      ]),
      create: z.union([
        z.lazy(() => BlockCreateWithoutInventoriesInputSchema),
        z.lazy(() => BlockUncheckedCreateWithoutInventoriesInputSchema)
      ]),
      where: z.lazy(() => BlockWhereInputSchema).optional()
    })
    .strict();

export const BlockUpdateToOneWithWhereWithoutInventoriesInputSchema: z.ZodType<Prisma.BlockUpdateToOneWithWhereWithoutInventoriesInput> =
  z
    .object({
      where: z.lazy(() => BlockWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => BlockUpdateWithoutInventoriesInputSchema),
        z.lazy(() => BlockUncheckedUpdateWithoutInventoriesInputSchema)
      ])
    })
    .strict();

export const BlockUpdateWithoutInventoriesInputSchema: z.ZodType<Prisma.BlockUpdateWithoutInventoriesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      label: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      href: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      site: z
        .lazy(() => SiteUpdateOneRequiredWithoutBlocksNestedInputSchema)
        .optional(),
      categories: z
        .lazy(() => CategoryUpdateManyWithoutBlockNestedInputSchema)
        .optional()
    })
    .strict();

export const BlockUncheckedUpdateWithoutInventoriesInputSchema: z.ZodType<Prisma.BlockUncheckedUpdateWithoutInventoriesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      label: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      href: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUncheckedUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      categories: z
        .lazy(() => CategoryUncheckedUpdateManyWithoutBlockNestedInputSchema)
        .optional()
    })
    .strict();

export const InventoryCreateWithoutVariantsInputSchema: z.ZodType<Prisma.InventoryCreateWithoutVariantsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      sku: z.string().optional().nullable(),
      basePrice: z.number(),
      active: z.boolean().optional(),
      isFeatured: z.boolean().optional(),
      metaTitle: z.string().optional().nullable(),
      metaDescription: z.string().optional().nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryCreatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      category: z
        .lazy(() => CategoryCreateNestedOneWithoutInventoriesInputSchema)
        .optional(),
      block: z.lazy(() => BlockCreateNestedOneWithoutInventoriesInputSchema)
    })
    .strict();

export const InventoryUncheckedCreateWithoutVariantsInputSchema: z.ZodType<Prisma.InventoryUncheckedCreateWithoutVariantsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      sku: z.string().optional().nullable(),
      basePrice: z.number(),
      active: z.boolean().optional(),
      isFeatured: z.boolean().optional(),
      metaTitle: z.string().optional().nullable(),
      metaDescription: z.string().optional().nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryCreatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      categoryId: z.string().optional().nullable(),
      blockId: z.string()
    })
    .strict();

export const InventoryCreateOrConnectWithoutVariantsInputSchema: z.ZodType<Prisma.InventoryCreateOrConnectWithoutVariantsInput> =
  z
    .object({
      where: z.lazy(() => InventoryWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => InventoryCreateWithoutVariantsInputSchema),
        z.lazy(() => InventoryUncheckedCreateWithoutVariantsInputSchema)
      ])
    })
    .strict();

export const InventoryUpsertWithoutVariantsInputSchema: z.ZodType<Prisma.InventoryUpsertWithoutVariantsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => InventoryUpdateWithoutVariantsInputSchema),
        z.lazy(() => InventoryUncheckedUpdateWithoutVariantsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => InventoryCreateWithoutVariantsInputSchema),
        z.lazy(() => InventoryUncheckedCreateWithoutVariantsInputSchema)
      ]),
      where: z.lazy(() => InventoryWhereInputSchema).optional()
    })
    .strict();

export const InventoryUpdateToOneWithWhereWithoutVariantsInputSchema: z.ZodType<Prisma.InventoryUpdateToOneWithWhereWithoutVariantsInput> =
  z
    .object({
      where: z.lazy(() => InventoryWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => InventoryUpdateWithoutVariantsInputSchema),
        z.lazy(() => InventoryUncheckedUpdateWithoutVariantsInputSchema)
      ])
    })
    .strict();

export const InventoryUpdateWithoutVariantsInputSchema: z.ZodType<Prisma.InventoryUpdateWithoutVariantsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      basePrice: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isFeatured: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metaTitle: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      metaDescription: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryUpdatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      category: z
        .lazy(() => CategoryUpdateOneWithoutInventoriesNestedInputSchema)
        .optional(),
      block: z
        .lazy(() => BlockUpdateOneRequiredWithoutInventoriesNestedInputSchema)
        .optional()
    })
    .strict();

export const InventoryUncheckedUpdateWithoutVariantsInputSchema: z.ZodType<Prisma.InventoryUncheckedUpdateWithoutVariantsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      basePrice: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isFeatured: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metaTitle: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      metaDescription: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryUpdatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      categoryId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const HistoryCreateWithoutCronInputSchema: z.ZodType<Prisma.HistoryCreateWithoutCronInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.string(),
      startedAt: z.coerce.date(),
      endedAt: z.coerce.date(),
      durationMs: z.number().int(),
      message: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional()
    })
    .strict();

export const HistoryUncheckedCreateWithoutCronInputSchema: z.ZodType<Prisma.HistoryUncheckedCreateWithoutCronInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.string(),
      startedAt: z.coerce.date(),
      endedAt: z.coerce.date(),
      durationMs: z.number().int(),
      message: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional()
    })
    .strict();

export const HistoryCreateOrConnectWithoutCronInputSchema: z.ZodType<Prisma.HistoryCreateOrConnectWithoutCronInput> =
  z
    .object({
      where: z.lazy(() => HistoryWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => HistoryCreateWithoutCronInputSchema),
        z.lazy(() => HistoryUncheckedCreateWithoutCronInputSchema)
      ])
    })
    .strict();

export const HistoryCreateManyCronInputEnvelopeSchema: z.ZodType<Prisma.HistoryCreateManyCronInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => HistoryCreateManyCronInputSchema),
        z.lazy(() => HistoryCreateManyCronInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const HistoryUpsertWithWhereUniqueWithoutCronInputSchema: z.ZodType<Prisma.HistoryUpsertWithWhereUniqueWithoutCronInput> =
  z
    .object({
      where: z.lazy(() => HistoryWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => HistoryUpdateWithoutCronInputSchema),
        z.lazy(() => HistoryUncheckedUpdateWithoutCronInputSchema)
      ]),
      create: z.union([
        z.lazy(() => HistoryCreateWithoutCronInputSchema),
        z.lazy(() => HistoryUncheckedCreateWithoutCronInputSchema)
      ])
    })
    .strict();

export const HistoryUpdateWithWhereUniqueWithoutCronInputSchema: z.ZodType<Prisma.HistoryUpdateWithWhereUniqueWithoutCronInput> =
  z
    .object({
      where: z.lazy(() => HistoryWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => HistoryUpdateWithoutCronInputSchema),
        z.lazy(() => HistoryUncheckedUpdateWithoutCronInputSchema)
      ])
    })
    .strict();

export const HistoryUpdateManyWithWhereWithoutCronInputSchema: z.ZodType<Prisma.HistoryUpdateManyWithWhereWithoutCronInput> =
  z
    .object({
      where: z.lazy(() => HistoryScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => HistoryUpdateManyMutationInputSchema),
        z.lazy(() => HistoryUncheckedUpdateManyWithoutCronInputSchema)
      ])
    })
    .strict();

export const HistoryScalarWhereInputSchema: z.ZodType<Prisma.HistoryScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => HistoryScalarWhereInputSchema),
          z.lazy(() => HistoryScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => HistoryScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => HistoryScalarWhereInputSchema),
          z.lazy(() => HistoryScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      status: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      startedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      endedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      durationMs: z
        .union([z.lazy(() => IntFilterSchema), z.number()])
        .optional(),
      message: z.lazy(() => JsonNullableFilterSchema).optional(),
      cronId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional()
    })
    .strict();

export const CronCreateWithoutHistoryInputSchema: z.ZodType<Prisma.CronCreateWithoutHistoryInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      cronExpr: z.string(),
      timezone: z.string().optional(),
      modulePath: z.string(),
      functionName: z.string(),
      enabled: z.boolean().optional(),
      lastRunAt: z.coerce.date().optional().nullable(),
      lastStatus: z.string().optional().nullable(),
      lastDurationMs: z.number().int().optional().nullable(),
      lockedAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const CronUncheckedCreateWithoutHistoryInputSchema: z.ZodType<Prisma.CronUncheckedCreateWithoutHistoryInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      cronExpr: z.string(),
      timezone: z.string().optional(),
      modulePath: z.string(),
      functionName: z.string(),
      enabled: z.boolean().optional(),
      lastRunAt: z.coerce.date().optional().nullable(),
      lastStatus: z.string().optional().nullable(),
      lastDurationMs: z.number().int().optional().nullable(),
      lockedAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const CronCreateOrConnectWithoutHistoryInputSchema: z.ZodType<Prisma.CronCreateOrConnectWithoutHistoryInput> =
  z
    .object({
      where: z.lazy(() => CronWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CronCreateWithoutHistoryInputSchema),
        z.lazy(() => CronUncheckedCreateWithoutHistoryInputSchema)
      ])
    })
    .strict();

export const CronUpsertWithoutHistoryInputSchema: z.ZodType<Prisma.CronUpsertWithoutHistoryInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => CronUpdateWithoutHistoryInputSchema),
        z.lazy(() => CronUncheckedUpdateWithoutHistoryInputSchema)
      ]),
      create: z.union([
        z.lazy(() => CronCreateWithoutHistoryInputSchema),
        z.lazy(() => CronUncheckedCreateWithoutHistoryInputSchema)
      ]),
      where: z.lazy(() => CronWhereInputSchema).optional()
    })
    .strict();

export const CronUpdateToOneWithWhereWithoutHistoryInputSchema: z.ZodType<Prisma.CronUpdateToOneWithWhereWithoutHistoryInput> =
  z
    .object({
      where: z.lazy(() => CronWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => CronUpdateWithoutHistoryInputSchema),
        z.lazy(() => CronUncheckedUpdateWithoutHistoryInputSchema)
      ])
    })
    .strict();

export const CronUpdateWithoutHistoryInputSchema: z.ZodType<Prisma.CronUpdateWithoutHistoryInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      cronExpr: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      timezone: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      modulePath: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      functionName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      enabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      lastRunAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      lastStatus: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      lastDurationMs: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      lockedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const CronUncheckedUpdateWithoutHistoryInputSchema: z.ZodType<Prisma.CronUncheckedUpdateWithoutHistoryInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      cronExpr: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      timezone: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      modulePath: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      functionName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      enabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      lastRunAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      lastStatus: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      lastDurationMs: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      lockedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const AccountCreateWithoutUserInputSchema: z.ZodType<Prisma.AccountCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      providerId: z.string().optional().nullable(),
      providerAccountId: z.string(),
      password: z.string().optional().nullable(),
      refresh_token: z.string().optional().nullable(),
      access_token: z.string().optional().nullable(),
      expires_at: z.number().int().optional().nullable(),
      scope: z.string().optional().nullable(),
      id_token: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const AccountUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.AccountUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      providerId: z.string().optional().nullable(),
      providerAccountId: z.string(),
      password: z.string().optional().nullable(),
      refresh_token: z.string().optional().nullable(),
      access_token: z.string().optional().nullable(),
      expires_at: z.number().int().optional().nullable(),
      scope: z.string().optional().nullable(),
      id_token: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const AccountCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.AccountCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => AccountWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => AccountCreateWithoutUserInputSchema),
        z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const AccountCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.AccountCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => AccountCreateManyUserInputSchema),
        z.lazy(() => AccountCreateManyUserInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const SessionCreateWithoutUserInputSchema: z.ZodType<Prisma.SessionCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      sessionToken: z.string(),
      expires: z.coerce.date(),
      ipAddress: z.string().optional().nullable(),
      userAgent: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const SessionUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.SessionUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      sessionToken: z.string(),
      expires: z.coerce.date(),
      ipAddress: z.string().optional().nullable(),
      userAgent: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const SessionCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.SessionCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => SessionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => SessionCreateWithoutUserInputSchema),
        z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const SessionCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.SessionCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => SessionCreateManyUserInputSchema),
        z.lazy(() => SessionCreateManyUserInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const SiteCreateWithoutUserInputSchema: z.ZodType<Prisma.SiteCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      display_name: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      font: z.string().optional(),
      image: z.string().optional().nullable(),
      imageBlurhash: z.string().optional().nullable(),
      subdomain: z.string().optional().nullable(),
      customDomain: z.string().optional().nullable(),
      message404: z.string().optional().nullable(),
      background: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      blocks: z
        .lazy(() => BlockCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      subscribers: z
        .lazy(() => SubscriberCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutSiteInputSchema).optional()
    })
    .strict();

export const SiteUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.SiteUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      display_name: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      font: z.string().optional(),
      image: z.string().optional().nullable(),
      imageBlurhash: z.string().optional().nullable(),
      subdomain: z.string().optional().nullable(),
      customDomain: z.string().optional().nullable(),
      message404: z.string().optional().nullable(),
      background: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      blocks: z
        .lazy(() => BlockUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      subscribers: z
        .lazy(() => SubscriberUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutSiteInputSchema)
        .optional()
    })
    .strict();

export const SiteCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.SiteCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => SiteWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => SiteCreateWithoutUserInputSchema),
        z.lazy(() => SiteUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const SiteCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.SiteCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => SiteCreateManyUserInputSchema),
        z.lazy(() => SiteCreateManyUserInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const SubscriptionCreateWithoutUserInputSchema: z.ZodType<Prisma.SubscriptionCreateWithoutUserInput> =
  z
    .object({
      id: z.string(),
      status: z.lazy(() => SubscriptionStatusSchema),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      quantity: z.number().int(),
      cancel_at_period_end: z.boolean(),
      created: z.coerce.date().optional(),
      current_period_start: z.coerce.date().optional(),
      current_period_end: z.coerce.date().optional(),
      ended_at: z.coerce.date().optional().nullable(),
      cancel_at: z.coerce.date().optional().nullable(),
      canceled_at: z.coerce.date().optional().nullable(),
      trial_start: z.coerce.date().optional().nullable(),
      trial_end: z.coerce.date().optional().nullable(),
      price: z.lazy(() => PriceCreateNestedOneWithoutSubscriptionsInputSchema)
    })
    .strict();

export const SubscriptionUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.SubscriptionUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string(),
      status: z.lazy(() => SubscriptionStatusSchema),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      quantity: z.number().int(),
      cancel_at_period_end: z.boolean(),
      created: z.coerce.date().optional(),
      current_period_start: z.coerce.date().optional(),
      current_period_end: z.coerce.date().optional(),
      ended_at: z.coerce.date().optional().nullable(),
      cancel_at: z.coerce.date().optional().nullable(),
      canceled_at: z.coerce.date().optional().nullable(),
      trial_start: z.coerce.date().optional().nullable(),
      trial_end: z.coerce.date().optional().nullable(),
      priceId: z.string()
    })
    .strict();

export const SubscriptionCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.SubscriptionCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => SubscriptionCreateWithoutUserInputSchema),
        z.lazy(() => SubscriptionUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const SubscriptionCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.SubscriptionCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => SubscriptionCreateManyUserInputSchema),
        z.lazy(() => SubscriptionCreateManyUserInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const AuthenticatorCreateWithoutUserInputSchema: z.ZodType<Prisma.AuthenticatorCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      credentialID: z.string(),
      providerAccountId: z.string(),
      credentialPublicKey: z.string(),
      counter: z.number().int(),
      credentialDeviceType: z.string(),
      credentialBackedUp: z.boolean(),
      transports: z.string().optional().nullable()
    })
    .strict();

export const AuthenticatorUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.AuthenticatorUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      credentialID: z.string(),
      providerAccountId: z.string(),
      credentialPublicKey: z.string(),
      counter: z.number().int(),
      credentialDeviceType: z.string(),
      credentialBackedUp: z.boolean(),
      transports: z.string().optional().nullable()
    })
    .strict();

export const AuthenticatorCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.AuthenticatorCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => AuthenticatorWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => AuthenticatorCreateWithoutUserInputSchema),
        z.lazy(() => AuthenticatorUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const AuthenticatorCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.AuthenticatorCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => AuthenticatorCreateManyUserInputSchema),
        z.lazy(() => AuthenticatorCreateManyUserInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const LinkCreateWithoutUserInputSchema: z.ZodType<Prisma.LinkCreateWithoutUserInput> =
  z
    .object({
      id: z.string(),
      url: z.string(),
      name: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutLinkInputSchema)
        .optional()
    })
    .strict();

export const LinkUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.LinkUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string(),
      url: z.string(),
      name: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutLinkInputSchema)
        .optional()
    })
    .strict();

export const LinkCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.LinkCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => LinkWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => LinkCreateWithoutUserInputSchema),
        z.lazy(() => LinkUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const LinkCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.LinkCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => LinkCreateManyUserInputSchema),
        z.lazy(() => LinkCreateManyUserInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const CustomerCreateWithoutUserInputSchema: z.ZodType<Prisma.CustomerCreateWithoutUserInput> =
  z
    .object({
      stripe_customer_id: z.string()
    })
    .strict();

export const CustomerUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.CustomerUncheckedCreateWithoutUserInput> =
  z
    .object({
      stripe_customer_id: z.string()
    })
    .strict();

export const CustomerCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.CustomerCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => CustomerWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CustomerCreateWithoutUserInputSchema),
        z.lazy(() => CustomerUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const TwoFactorConfirmationCreateWithoutUserInputSchema: z.ZodType<Prisma.TwoFactorConfirmationCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional()
    })
    .strict();

export const TwoFactorConfirmationUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.TwoFactorConfirmationUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional()
    })
    .strict();

export const TwoFactorConfirmationCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.TwoFactorConfirmationCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => TwoFactorConfirmationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => TwoFactorConfirmationCreateWithoutUserInputSchema),
        z.lazy(() => TwoFactorConfirmationUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const UserCreateWithoutAffiliatesInputSchema: z.ZodType<Prisma.UserCreateWithoutAffiliatesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutAffiliatesInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutAffiliatesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutAffiliatesInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutAffiliatesInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutAffiliatesInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutAffiliatesInputSchema)
      ])
    })
    .strict();

export const NafCodeCreateWithoutUsersInputSchema: z.ZodType<Prisma.NafCodeCreateWithoutUsersInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      class: z.lazy(() => NafClassCreateNestedOneWithoutCodesInputSchema)
    })
    .strict();

export const NafCodeUncheckedCreateWithoutUsersInputSchema: z.ZodType<Prisma.NafCodeUncheckedCreateWithoutUsersInput> =
  z
    .object({
      id: z.string(),
      title: z.string(),
      classId: z.string()
    })
    .strict();

export const NafCodeCreateOrConnectWithoutUsersInputSchema: z.ZodType<Prisma.NafCodeCreateOrConnectWithoutUsersInput> =
  z
    .object({
      where: z.lazy(() => NafCodeWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => NafCodeCreateWithoutUsersInputSchema),
        z.lazy(() => NafCodeUncheckedCreateWithoutUsersInputSchema)
      ])
    })
    .strict();

export const FeedbackCreateWithoutUserInputSchema: z.ZodType<Prisma.FeedbackCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      message: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const FeedbackUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.FeedbackUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      message: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const FeedbackCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.FeedbackCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => FeedbackWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => FeedbackCreateWithoutUserInputSchema),
        z.lazy(() => FeedbackUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const FeedbackCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.FeedbackCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => FeedbackCreateManyUserInputSchema),
        z.lazy(() => FeedbackCreateManyUserInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const LikeCreateWithoutUserInputSchema: z.ZodType<Prisma.LikeCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      ip: z.string(),
      createdAt: z.coerce.date().optional(),
      site: z.lazy(() => SiteCreateNestedOneWithoutLikesInputSchema),
      feed: z.lazy(() => FeedCreateNestedOneWithoutLikesInputSchema).optional()
    })
    .strict();

export const LikeUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.LikeUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      ip: z.string(),
      createdAt: z.coerce.date().optional(),
      siteId: z.string(),
      feedId: z.string().optional().nullable()
    })
    .strict();

export const LikeCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.LikeCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => LikeWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => LikeCreateWithoutUserInputSchema),
        z.lazy(() => LikeUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const LikeCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.LikeCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => LikeCreateManyUserInputSchema),
        z.lazy(() => LikeCreateManyUserInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const UserCreateWithoutRefererInputSchema: z.ZodType<Prisma.UserCreateWithoutRefererInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutRefererInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutRefererInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutRefererInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutRefererInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutRefererInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutRefererInputSchema)
      ])
    })
    .strict();

export const UserCreateManyRefererInputEnvelopeSchema: z.ZodType<Prisma.UserCreateManyRefererInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => UserCreateManyRefererInputSchema),
        z.lazy(() => UserCreateManyRefererInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const EventCreateWithoutUserInputSchema: z.ZodType<Prisma.EventCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      eventType: z.string(),
      payload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      status: z.string().optional(),
      attempts: z.number().int().optional(),
      lastError: z.string().optional().nullable()
    })
    .strict();

export const EventUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.EventUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      eventType: z.string(),
      payload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      status: z.string().optional(),
      attempts: z.number().int().optional(),
      lastError: z.string().optional().nullable()
    })
    .strict();

export const EventCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.EventCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => EventWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => EventCreateWithoutUserInputSchema),
        z.lazy(() => EventUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const EventCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.EventCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => EventCreateManyUserInputSchema),
        z.lazy(() => EventCreateManyUserInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const WorkflowStateCreateWithoutUserInputSchema: z.ZodType<Prisma.WorkflowStateCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.lazy(() => WorkflowStateStatusSchema).optional(),
      startedAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      workflow: z.lazy(() => WorkflowCreateNestedOneWithoutStatesInputSchema)
    })
    .strict();

export const WorkflowStateUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.WorkflowStateUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      workflowId: z.string(),
      status: z.lazy(() => WorkflowStateStatusSchema).optional(),
      startedAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const WorkflowStateCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.WorkflowStateCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => WorkflowStateWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => WorkflowStateCreateWithoutUserInputSchema),
        z.lazy(() => WorkflowStateUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const WorkflowStateCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.WorkflowStateCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => WorkflowStateCreateManyUserInputSchema),
        z.lazy(() => WorkflowStateCreateManyUserInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ExecutionCreateWithoutUserInputSchema: z.ZodType<Prisma.ExecutionCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      executedAt: z.coerce.date().optional().nullable(),
      status: z.lazy(() => ExecutionStatusSchema).optional(),
      errorMessage: z.string().optional().nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z.string().optional().nullable(),
      action: z.lazy(() => ActionCreateNestedOneWithoutExecutionsInputSchema),
      rule: z
        .lazy(() => RuleCreateNestedOneWithoutExecutionsInputSchema)
        .optional()
    })
    .strict();

export const ExecutionUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.ExecutionUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      actionId: z.string(),
      ruleId: z.string().optional().nullable(),
      executedAt: z.coerce.date().optional().nullable(),
      status: z.lazy(() => ExecutionStatusSchema).optional(),
      errorMessage: z.string().optional().nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z.string().optional().nullable()
    })
    .strict();

export const ExecutionCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.ExecutionCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => ExecutionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ExecutionCreateWithoutUserInputSchema),
        z.lazy(() => ExecutionUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const ExecutionCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.ExecutionCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ExecutionCreateManyUserInputSchema),
        z.lazy(() => ExecutionCreateManyUserInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const QueueCreateWithoutUserInputSchema: z.ZodType<Prisma.QueueCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      job: z.string().optional(),
      payload: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      status: z.string().optional(),
      attempts: z.number().int().optional(),
      lastError: z.string().optional().nullable(),
      runAt: z.coerce.date().optional(),
      priority: z.number().int().optional(),
      processingStartedAt: z.coerce.date().optional().nullable(),
      correlationId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const QueueUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.QueueUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      job: z.string().optional(),
      payload: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      status: z.string().optional(),
      attempts: z.number().int().optional(),
      lastError: z.string().optional().nullable(),
      runAt: z.coerce.date().optional(),
      priority: z.number().int().optional(),
      processingStartedAt: z.coerce.date().optional().nullable(),
      correlationId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const QueueCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.QueueCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => QueueWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => QueueCreateWithoutUserInputSchema),
        z.lazy(() => QueueUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const QueueCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.QueueCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => QueueCreateManyUserInputSchema),
        z.lazy(() => QueueCreateManyUserInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const OutboxCreateWithoutUserInputSchema: z.ZodType<Prisma.OutboxCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      subject: z.string(),
      body: z.string(),
      status: z.string().optional(),
      metadata: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      campaign: z
        .lazy(() => CampaignCreateNestedOneWithoutOutboxesInputSchema)
        .optional()
    })
    .strict();

export const OutboxUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.OutboxUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      subject: z.string(),
      body: z.string(),
      status: z.string().optional(),
      metadata: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      campaignId: z.string().optional().nullable()
    })
    .strict();

export const OutboxCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.OutboxCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => OutboxWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OutboxCreateWithoutUserInputSchema),
        z.lazy(() => OutboxUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const OutboxCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.OutboxCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => OutboxCreateManyUserInputSchema),
        z.lazy(() => OutboxCreateManyUserInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const FeedCreateWithoutUserInputSchema: z.ZodType<Prisma.FeedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => FeedTypeSchema).optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      site: z.lazy(() => SiteCreateNestedOneWithoutFeedInputSchema),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutFeedInputSchema)
        .optional(),
      likes: z.lazy(() => LikeCreateNestedManyWithoutFeedInputSchema).optional()
    })
    .strict();

export const FeedUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.FeedUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => FeedTypeSchema).optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      siteId: z.string(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutFeedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutFeedInputSchema)
        .optional()
    })
    .strict();

export const FeedCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.FeedCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => FeedWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => FeedCreateWithoutUserInputSchema),
        z.lazy(() => FeedUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const FeedCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.FeedCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => FeedCreateManyUserInputSchema),
        z.lazy(() => FeedCreateManyUserInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const CommentCreateWithoutUserInputSchema: z.ZodType<Prisma.CommentCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      content: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      feed: z
        .lazy(() => FeedCreateNestedOneWithoutCommentsInputSchema)
        .optional()
    })
    .strict();

export const CommentUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.CommentUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      content: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      feedId: z.string().optional().nullable()
    })
    .strict();

export const CommentCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.CommentCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => CommentWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CommentCreateWithoutUserInputSchema),
        z.lazy(() => CommentUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const CommentCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.CommentCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => CommentCreateManyUserInputSchema),
        z.lazy(() => CommentCreateManyUserInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const MessageCreateWithoutSenderInputSchema: z.ZodType<Prisma.MessageCreateWithoutSenderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      content: z.string(),
      createdAt: z.coerce.date().optional(),
      receiver: z.lazy(() => UserCreateNestedOneWithoutReceivedInputSchema)
    })
    .strict();

export const MessageUncheckedCreateWithoutSenderInputSchema: z.ZodType<Prisma.MessageUncheckedCreateWithoutSenderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      content: z.string(),
      createdAt: z.coerce.date().optional(),
      receiveEmail: z.string()
    })
    .strict();

export const MessageCreateOrConnectWithoutSenderInputSchema: z.ZodType<Prisma.MessageCreateOrConnectWithoutSenderInput> =
  z
    .object({
      where: z.lazy(() => MessageWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => MessageCreateWithoutSenderInputSchema),
        z.lazy(() => MessageUncheckedCreateWithoutSenderInputSchema)
      ])
    })
    .strict();

export const MessageCreateManySenderInputEnvelopeSchema: z.ZodType<Prisma.MessageCreateManySenderInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => MessageCreateManySenderInputSchema),
        z.lazy(() => MessageCreateManySenderInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const MessageCreateWithoutReceiverInputSchema: z.ZodType<Prisma.MessageCreateWithoutReceiverInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      content: z.string(),
      createdAt: z.coerce.date().optional(),
      sender: z.lazy(() => UserCreateNestedOneWithoutSentInputSchema)
    })
    .strict();

export const MessageUncheckedCreateWithoutReceiverInputSchema: z.ZodType<Prisma.MessageUncheckedCreateWithoutReceiverInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      content: z.string(),
      createdAt: z.coerce.date().optional(),
      senderEmail: z.string()
    })
    .strict();

export const MessageCreateOrConnectWithoutReceiverInputSchema: z.ZodType<Prisma.MessageCreateOrConnectWithoutReceiverInput> =
  z
    .object({
      where: z.lazy(() => MessageWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => MessageCreateWithoutReceiverInputSchema),
        z.lazy(() => MessageUncheckedCreateWithoutReceiverInputSchema)
      ])
    })
    .strict();

export const MessageCreateManyReceiverInputEnvelopeSchema: z.ZodType<Prisma.MessageCreateManyReceiverInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => MessageCreateManyReceiverInputSchema),
        z.lazy(() => MessageCreateManyReceiverInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ReservationCreateWithoutAffiliateInputSchema: z.ZodType<Prisma.ReservationCreateWithoutAffiliateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string().optional().nullable(),
      name: z.string().optional().nullable(),
      email: z.string(),
      dateStart: z.coerce.date(),
      dateEnd: z.coerce.date().optional().nullable(),
      comment: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      block: z
        .lazy(() => BlockCreateNestedOneWithoutReservationsInputSchema)
        .optional()
    })
    .strict();

export const ReservationUncheckedCreateWithoutAffiliateInputSchema: z.ZodType<Prisma.ReservationUncheckedCreateWithoutAffiliateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string().optional().nullable(),
      name: z.string().optional().nullable(),
      email: z.string(),
      dateStart: z.coerce.date(),
      dateEnd: z.coerce.date().optional().nullable(),
      comment: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      blockId: z.string().optional().nullable()
    })
    .strict();

export const ReservationCreateOrConnectWithoutAffiliateInputSchema: z.ZodType<Prisma.ReservationCreateOrConnectWithoutAffiliateInput> =
  z
    .object({
      where: z.lazy(() => ReservationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ReservationCreateWithoutAffiliateInputSchema),
        z.lazy(() => ReservationUncheckedCreateWithoutAffiliateInputSchema)
      ])
    })
    .strict();

export const ReservationCreateManyAffiliateInputEnvelopeSchema: z.ZodType<Prisma.ReservationCreateManyAffiliateInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ReservationCreateManyAffiliateInputSchema),
        z.lazy(() => ReservationCreateManyAffiliateInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ListCreateWithoutContactsInputSchema: z.ZodType<Prisma.ListCreateWithoutContactsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      owners: z
        .lazy(() => UserCreateNestedManyWithoutListsManageInputSchema)
        .optional(),
      campaigns: z
        .lazy(() => CampaignCreateNestedManyWithoutListInputSchema)
        .optional()
    })
    .strict();

export const ListUncheckedCreateWithoutContactsInputSchema: z.ZodType<Prisma.ListUncheckedCreateWithoutContactsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      owners: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutListsManageInputSchema)
        .optional(),
      campaigns: z
        .lazy(() => CampaignUncheckedCreateNestedManyWithoutListInputSchema)
        .optional()
    })
    .strict();

export const ListCreateOrConnectWithoutContactsInputSchema: z.ZodType<Prisma.ListCreateOrConnectWithoutContactsInput> =
  z
    .object({
      where: z.lazy(() => ListWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ListCreateWithoutContactsInputSchema),
        z.lazy(() => ListUncheckedCreateWithoutContactsInputSchema)
      ])
    })
    .strict();

export const ListCreateWithoutOwnersInputSchema: z.ZodType<Prisma.ListCreateWithoutOwnersInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      contacts: z
        .lazy(() => UserCreateNestedManyWithoutListsInputSchema)
        .optional(),
      campaigns: z
        .lazy(() => CampaignCreateNestedManyWithoutListInputSchema)
        .optional()
    })
    .strict();

export const ListUncheckedCreateWithoutOwnersInputSchema: z.ZodType<Prisma.ListUncheckedCreateWithoutOwnersInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      contacts: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutListsInputSchema)
        .optional(),
      campaigns: z
        .lazy(() => CampaignUncheckedCreateNestedManyWithoutListInputSchema)
        .optional()
    })
    .strict();

export const ListCreateOrConnectWithoutOwnersInputSchema: z.ZodType<Prisma.ListCreateOrConnectWithoutOwnersInput> =
  z
    .object({
      where: z.lazy(() => ListWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ListCreateWithoutOwnersInputSchema),
        z.lazy(() => ListUncheckedCreateWithoutOwnersInputSchema)
      ])
    })
    .strict();

export const EmailCreateWithoutUserInputSchema: z.ZodType<Prisma.EmailCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      subject: z.string(),
      content: z.string(),
      design: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      campaigns: z
        .lazy(() => CampaignCreateNestedManyWithoutEmailInputSchema)
        .optional()
    })
    .strict();

export const EmailUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.EmailUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      subject: z.string(),
      content: z.string(),
      design: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      campaigns: z
        .lazy(() => CampaignUncheckedCreateNestedManyWithoutEmailInputSchema)
        .optional()
    })
    .strict();

export const EmailCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.EmailCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => EmailWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => EmailCreateWithoutUserInputSchema),
        z.lazy(() => EmailUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const EmailCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.EmailCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => EmailCreateManyUserInputSchema),
        z.lazy(() => EmailCreateManyUserInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ClickCreateWithoutUserInputSchema: z.ZodType<Prisma.ClickCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      part: z.string().optional().nullable(),
      path: z.string().optional().nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      block: z
        .lazy(() => BlockCreateNestedOneWithoutClicksInputSchema)
        .optional(),
      site: z
        .lazy(() => SiteCreateNestedOneWithoutClicksInputSchema)
        .optional(),
      link: z
        .lazy(() => LinkCreateNestedOneWithoutClicksInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutReferralsInputSchema)
        .optional()
    })
    .strict();

export const ClickUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.ClickUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      part: z.string().optional().nullable(),
      path: z.string().optional().nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      blockId: z.string().optional().nullable(),
      siteId: z.string().optional().nullable(),
      linkId: z.string().optional().nullable(),
      refererId: z.string().optional().nullable()
    })
    .strict();

export const ClickCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.ClickCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => ClickWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ClickCreateWithoutUserInputSchema),
        z.lazy(() => ClickUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const ClickCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.ClickCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ClickCreateManyUserInputSchema),
        z.lazy(() => ClickCreateManyUserInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ClickCreateWithoutRefererInputSchema: z.ZodType<Prisma.ClickCreateWithoutRefererInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      part: z.string().optional().nullable(),
      path: z.string().optional().nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      block: z
        .lazy(() => BlockCreateNestedOneWithoutClicksInputSchema)
        .optional(),
      site: z
        .lazy(() => SiteCreateNestedOneWithoutClicksInputSchema)
        .optional(),
      link: z
        .lazy(() => LinkCreateNestedOneWithoutClicksInputSchema)
        .optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutClicksInputSchema).optional()
    })
    .strict();

export const ClickUncheckedCreateWithoutRefererInputSchema: z.ZodType<Prisma.ClickUncheckedCreateWithoutRefererInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      part: z.string().optional().nullable(),
      path: z.string().optional().nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      blockId: z.string().optional().nullable(),
      siteId: z.string().optional().nullable(),
      linkId: z.string().optional().nullable(),
      userId: z.string().optional().nullable()
    })
    .strict();

export const ClickCreateOrConnectWithoutRefererInputSchema: z.ZodType<Prisma.ClickCreateOrConnectWithoutRefererInput> =
  z
    .object({
      where: z.lazy(() => ClickWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ClickCreateWithoutRefererInputSchema),
        z.lazy(() => ClickUncheckedCreateWithoutRefererInputSchema)
      ])
    })
    .strict();

export const ClickCreateManyRefererInputEnvelopeSchema: z.ZodType<Prisma.ClickCreateManyRefererInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ClickCreateManyRefererInputSchema),
        z.lazy(() => ClickCreateManyRefererInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const AccountUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.AccountUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => AccountWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => AccountUpdateWithoutUserInputSchema),
        z.lazy(() => AccountUncheckedUpdateWithoutUserInputSchema)
      ]),
      create: z.union([
        z.lazy(() => AccountCreateWithoutUserInputSchema),
        z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const AccountUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.AccountUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => AccountWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => AccountUpdateWithoutUserInputSchema),
        z.lazy(() => AccountUncheckedUpdateWithoutUserInputSchema)
      ])
    })
    .strict();

export const AccountUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.AccountUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => AccountScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => AccountUpdateManyMutationInputSchema),
        z.lazy(() => AccountUncheckedUpdateManyWithoutUserInputSchema)
      ])
    })
    .strict();

export const AccountScalarWhereInputSchema: z.ZodType<Prisma.AccountScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => AccountScalarWhereInputSchema),
          z.lazy(() => AccountScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => AccountScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => AccountScalarWhereInputSchema),
          z.lazy(() => AccountScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      providerId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      providerAccountId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      password: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      refresh_token: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      access_token: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      expires_at: z
        .union([z.lazy(() => IntNullableFilterSchema), z.number()])
        .optional()
        .nullable(),
      scope: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      id_token: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional()
    })
    .strict();

export const SessionUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.SessionUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => SessionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => SessionUpdateWithoutUserInputSchema),
        z.lazy(() => SessionUncheckedUpdateWithoutUserInputSchema)
      ]),
      create: z.union([
        z.lazy(() => SessionCreateWithoutUserInputSchema),
        z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const SessionUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.SessionUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => SessionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => SessionUpdateWithoutUserInputSchema),
        z.lazy(() => SessionUncheckedUpdateWithoutUserInputSchema)
      ])
    })
    .strict();

export const SessionUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.SessionUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => SessionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => SessionUpdateManyMutationInputSchema),
        z.lazy(() => SessionUncheckedUpdateManyWithoutUserInputSchema)
      ])
    })
    .strict();

export const SessionScalarWhereInputSchema: z.ZodType<Prisma.SessionScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => SessionScalarWhereInputSchema),
          z.lazy(() => SessionScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => SessionScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => SessionScalarWhereInputSchema),
          z.lazy(() => SessionScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      sessionToken: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      expires: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      ipAddress: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      userAgent: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional()
    })
    .strict();

export const SiteUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.SiteUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => SiteWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => SiteUpdateWithoutUserInputSchema),
        z.lazy(() => SiteUncheckedUpdateWithoutUserInputSchema)
      ]),
      create: z.union([
        z.lazy(() => SiteCreateWithoutUserInputSchema),
        z.lazy(() => SiteUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const SiteUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.SiteUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => SiteWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => SiteUpdateWithoutUserInputSchema),
        z.lazy(() => SiteUncheckedUpdateWithoutUserInputSchema)
      ])
    })
    .strict();

export const SiteUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.SiteUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => SiteScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => SiteUpdateManyMutationInputSchema),
        z.lazy(() => SiteUncheckedUpdateManyWithoutUserInputSchema)
      ])
    })
    .strict();

export const SiteScalarWhereInputSchema: z.ZodType<Prisma.SiteScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => SiteScalarWhereInputSchema),
          z.lazy(() => SiteScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => SiteScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => SiteScalarWhereInputSchema),
          z.lazy(() => SiteScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      name: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      display_name: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      logo: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      font: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      image: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      imageBlurhash: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      subdomain: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      customDomain: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      message404: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      background: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional()
    })
    .strict();

export const SubscriptionUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.SubscriptionUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => SubscriptionUpdateWithoutUserInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateWithoutUserInputSchema)
      ]),
      create: z.union([
        z.lazy(() => SubscriptionCreateWithoutUserInputSchema),
        z.lazy(() => SubscriptionUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const SubscriptionUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.SubscriptionUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => SubscriptionUpdateWithoutUserInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateWithoutUserInputSchema)
      ])
    })
    .strict();

export const SubscriptionUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.SubscriptionUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => SubscriptionUpdateManyMutationInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateManyWithoutUserInputSchema)
      ])
    })
    .strict();

export const AuthenticatorUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.AuthenticatorUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => AuthenticatorWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => AuthenticatorUpdateWithoutUserInputSchema),
        z.lazy(() => AuthenticatorUncheckedUpdateWithoutUserInputSchema)
      ]),
      create: z.union([
        z.lazy(() => AuthenticatorCreateWithoutUserInputSchema),
        z.lazy(() => AuthenticatorUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const AuthenticatorUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.AuthenticatorUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => AuthenticatorWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => AuthenticatorUpdateWithoutUserInputSchema),
        z.lazy(() => AuthenticatorUncheckedUpdateWithoutUserInputSchema)
      ])
    })
    .strict();

export const AuthenticatorUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.AuthenticatorUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => AuthenticatorScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => AuthenticatorUpdateManyMutationInputSchema),
        z.lazy(() => AuthenticatorUncheckedUpdateManyWithoutUserInputSchema)
      ])
    })
    .strict();

export const AuthenticatorScalarWhereInputSchema: z.ZodType<Prisma.AuthenticatorScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => AuthenticatorScalarWhereInputSchema),
          z.lazy(() => AuthenticatorScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => AuthenticatorScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => AuthenticatorScalarWhereInputSchema),
          z.lazy(() => AuthenticatorScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      credentialID: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      providerAccountId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      credentialPublicKey: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      counter: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      credentialDeviceType: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      credentialBackedUp: z
        .union([z.lazy(() => BoolFilterSchema), z.boolean()])
        .optional(),
      transports: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional()
    })
    .strict();

export const LinkUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.LinkUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => LinkWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => LinkUpdateWithoutUserInputSchema),
        z.lazy(() => LinkUncheckedUpdateWithoutUserInputSchema)
      ]),
      create: z.union([
        z.lazy(() => LinkCreateWithoutUserInputSchema),
        z.lazy(() => LinkUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const LinkUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.LinkUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => LinkWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => LinkUpdateWithoutUserInputSchema),
        z.lazy(() => LinkUncheckedUpdateWithoutUserInputSchema)
      ])
    })
    .strict();

export const LinkUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.LinkUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => LinkScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => LinkUpdateManyMutationInputSchema),
        z.lazy(() => LinkUncheckedUpdateManyWithoutUserInputSchema)
      ])
    })
    .strict();

export const LinkScalarWhereInputSchema: z.ZodType<Prisma.LinkScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => LinkScalarWhereInputSchema),
          z.lazy(() => LinkScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => LinkScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => LinkScalarWhereInputSchema),
          z.lazy(() => LinkScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      url: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      name: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      userId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable()
    })
    .strict();

export const CustomerUpsertWithoutUserInputSchema: z.ZodType<Prisma.CustomerUpsertWithoutUserInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => CustomerUpdateWithoutUserInputSchema),
        z.lazy(() => CustomerUncheckedUpdateWithoutUserInputSchema)
      ]),
      create: z.union([
        z.lazy(() => CustomerCreateWithoutUserInputSchema),
        z.lazy(() => CustomerUncheckedCreateWithoutUserInputSchema)
      ]),
      where: z.lazy(() => CustomerWhereInputSchema).optional()
    })
    .strict();

export const CustomerUpdateToOneWithWhereWithoutUserInputSchema: z.ZodType<Prisma.CustomerUpdateToOneWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => CustomerWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => CustomerUpdateWithoutUserInputSchema),
        z.lazy(() => CustomerUncheckedUpdateWithoutUserInputSchema)
      ])
    })
    .strict();

export const CustomerUpdateWithoutUserInputSchema: z.ZodType<Prisma.CustomerUpdateWithoutUserInput> =
  z
    .object({
      stripe_customer_id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const CustomerUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.CustomerUncheckedUpdateWithoutUserInput> =
  z
    .object({
      stripe_customer_id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const TwoFactorConfirmationUpsertWithoutUserInputSchema: z.ZodType<Prisma.TwoFactorConfirmationUpsertWithoutUserInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => TwoFactorConfirmationUpdateWithoutUserInputSchema),
        z.lazy(() => TwoFactorConfirmationUncheckedUpdateWithoutUserInputSchema)
      ]),
      create: z.union([
        z.lazy(() => TwoFactorConfirmationCreateWithoutUserInputSchema),
        z.lazy(() => TwoFactorConfirmationUncheckedCreateWithoutUserInputSchema)
      ]),
      where: z.lazy(() => TwoFactorConfirmationWhereInputSchema).optional()
    })
    .strict();

export const TwoFactorConfirmationUpdateToOneWithWhereWithoutUserInputSchema: z.ZodType<Prisma.TwoFactorConfirmationUpdateToOneWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => TwoFactorConfirmationWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => TwoFactorConfirmationUpdateWithoutUserInputSchema),
        z.lazy(() => TwoFactorConfirmationUncheckedUpdateWithoutUserInputSchema)
      ])
    })
    .strict();

export const TwoFactorConfirmationUpdateWithoutUserInputSchema: z.ZodType<Prisma.TwoFactorConfirmationUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const TwoFactorConfirmationUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.TwoFactorConfirmationUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserUpsertWithoutAffiliatesInputSchema: z.ZodType<Prisma.UserUpsertWithoutAffiliatesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutAffiliatesInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutAffiliatesInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutAffiliatesInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutAffiliatesInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutAffiliatesInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutAffiliatesInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutAffiliatesInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutAffiliatesInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutAffiliatesInputSchema: z.ZodType<Prisma.UserUpdateWithoutAffiliatesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutAffiliatesInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutAffiliatesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const NafCodeUpsertWithoutUsersInputSchema: z.ZodType<Prisma.NafCodeUpsertWithoutUsersInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => NafCodeUpdateWithoutUsersInputSchema),
        z.lazy(() => NafCodeUncheckedUpdateWithoutUsersInputSchema)
      ]),
      create: z.union([
        z.lazy(() => NafCodeCreateWithoutUsersInputSchema),
        z.lazy(() => NafCodeUncheckedCreateWithoutUsersInputSchema)
      ]),
      where: z.lazy(() => NafCodeWhereInputSchema).optional()
    })
    .strict();

export const NafCodeUpdateToOneWithWhereWithoutUsersInputSchema: z.ZodType<Prisma.NafCodeUpdateToOneWithWhereWithoutUsersInput> =
  z
    .object({
      where: z.lazy(() => NafCodeWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => NafCodeUpdateWithoutUsersInputSchema),
        z.lazy(() => NafCodeUncheckedUpdateWithoutUsersInputSchema)
      ])
    })
    .strict();

export const NafCodeUpdateWithoutUsersInputSchema: z.ZodType<Prisma.NafCodeUpdateWithoutUsersInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      class: z
        .lazy(() => NafClassUpdateOneRequiredWithoutCodesNestedInputSchema)
        .optional()
    })
    .strict();

export const NafCodeUncheckedUpdateWithoutUsersInputSchema: z.ZodType<Prisma.NafCodeUncheckedUpdateWithoutUsersInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      classId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const FeedbackUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.FeedbackUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => FeedbackWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => FeedbackUpdateWithoutUserInputSchema),
        z.lazy(() => FeedbackUncheckedUpdateWithoutUserInputSchema)
      ]),
      create: z.union([
        z.lazy(() => FeedbackCreateWithoutUserInputSchema),
        z.lazy(() => FeedbackUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const FeedbackUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.FeedbackUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => FeedbackWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => FeedbackUpdateWithoutUserInputSchema),
        z.lazy(() => FeedbackUncheckedUpdateWithoutUserInputSchema)
      ])
    })
    .strict();

export const FeedbackUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.FeedbackUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => FeedbackScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => FeedbackUpdateManyMutationInputSchema),
        z.lazy(() => FeedbackUncheckedUpdateManyWithoutUserInputSchema)
      ])
    })
    .strict();

export const FeedbackScalarWhereInputSchema: z.ZodType<Prisma.FeedbackScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => FeedbackScalarWhereInputSchema),
          z.lazy(() => FeedbackScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => FeedbackScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => FeedbackScalarWhereInputSchema),
          z.lazy(() => FeedbackScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      message: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      userId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable()
    })
    .strict();

export const LikeUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.LikeUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => LikeWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => LikeUpdateWithoutUserInputSchema),
        z.lazy(() => LikeUncheckedUpdateWithoutUserInputSchema)
      ]),
      create: z.union([
        z.lazy(() => LikeCreateWithoutUserInputSchema),
        z.lazy(() => LikeUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const LikeUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.LikeUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => LikeWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => LikeUpdateWithoutUserInputSchema),
        z.lazy(() => LikeUncheckedUpdateWithoutUserInputSchema)
      ])
    })
    .strict();

export const LikeUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.LikeUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => LikeScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => LikeUpdateManyMutationInputSchema),
        z.lazy(() => LikeUncheckedUpdateManyWithoutUserInputSchema)
      ])
    })
    .strict();

export const UserUpsertWithWhereUniqueWithoutRefererInputSchema: z.ZodType<Prisma.UserUpsertWithWhereUniqueWithoutRefererInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => UserUpdateWithoutRefererInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutRefererInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutRefererInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutRefererInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithWhereUniqueWithoutRefererInputSchema: z.ZodType<Prisma.UserUpdateWithWhereUniqueWithoutRefererInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => UserUpdateWithoutRefererInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutRefererInputSchema)
      ])
    })
    .strict();

export const UserUpdateManyWithWhereWithoutRefererInputSchema: z.ZodType<Prisma.UserUpdateManyWithWhereWithoutRefererInput> =
  z
    .object({
      where: z.lazy(() => UserScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => UserUpdateManyMutationInputSchema),
        z.lazy(() => UserUncheckedUpdateManyWithoutRefererInputSchema)
      ])
    })
    .strict();

export const EventUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.EventUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => EventWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => EventUpdateWithoutUserInputSchema),
        z.lazy(() => EventUncheckedUpdateWithoutUserInputSchema)
      ]),
      create: z.union([
        z.lazy(() => EventCreateWithoutUserInputSchema),
        z.lazy(() => EventUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const EventUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.EventUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => EventWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => EventUpdateWithoutUserInputSchema),
        z.lazy(() => EventUncheckedUpdateWithoutUserInputSchema)
      ])
    })
    .strict();

export const EventUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.EventUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => EventScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => EventUpdateManyMutationInputSchema),
        z.lazy(() => EventUncheckedUpdateManyWithoutUserInputSchema)
      ])
    })
    .strict();

export const EventScalarWhereInputSchema: z.ZodType<Prisma.EventScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => EventScalarWhereInputSchema),
          z.lazy(() => EventScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => EventScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => EventScalarWhereInputSchema),
          z.lazy(() => EventScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      userId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      eventType: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      payload: z.lazy(() => JsonNullableFilterSchema).optional(),
      correlationId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      status: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      attempts: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      lastError: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable()
    })
    .strict();

export const WorkflowStateUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.WorkflowStateUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => WorkflowStateWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => WorkflowStateUpdateWithoutUserInputSchema),
        z.lazy(() => WorkflowStateUncheckedUpdateWithoutUserInputSchema)
      ]),
      create: z.union([
        z.lazy(() => WorkflowStateCreateWithoutUserInputSchema),
        z.lazy(() => WorkflowStateUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const WorkflowStateUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.WorkflowStateUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => WorkflowStateWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => WorkflowStateUpdateWithoutUserInputSchema),
        z.lazy(() => WorkflowStateUncheckedUpdateWithoutUserInputSchema)
      ])
    })
    .strict();

export const WorkflowStateUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.WorkflowStateUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => WorkflowStateScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => WorkflowStateUpdateManyMutationInputSchema),
        z.lazy(() => WorkflowStateUncheckedUpdateManyWithoutUserInputSchema)
      ])
    })
    .strict();

export const WorkflowStateScalarWhereInputSchema: z.ZodType<Prisma.WorkflowStateScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => WorkflowStateScalarWhereInputSchema),
          z.lazy(() => WorkflowStateScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => WorkflowStateScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => WorkflowStateScalarWhereInputSchema),
          z.lazy(() => WorkflowStateScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      userId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      workflowId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumWorkflowStateStatusFilterSchema),
          z.lazy(() => WorkflowStateStatusSchema)
        ])
        .optional(),
      startedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional()
    })
    .strict();

export const ExecutionUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.ExecutionUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => ExecutionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ExecutionUpdateWithoutUserInputSchema),
        z.lazy(() => ExecutionUncheckedUpdateWithoutUserInputSchema)
      ]),
      create: z.union([
        z.lazy(() => ExecutionCreateWithoutUserInputSchema),
        z.lazy(() => ExecutionUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const ExecutionUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.ExecutionUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => ExecutionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ExecutionUpdateWithoutUserInputSchema),
        z.lazy(() => ExecutionUncheckedUpdateWithoutUserInputSchema)
      ])
    })
    .strict();

export const ExecutionUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.ExecutionUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => ExecutionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ExecutionUpdateManyMutationInputSchema),
        z.lazy(() => ExecutionUncheckedUpdateManyWithoutUserInputSchema)
      ])
    })
    .strict();

export const ExecutionScalarWhereInputSchema: z.ZodType<Prisma.ExecutionScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ExecutionScalarWhereInputSchema),
          z.lazy(() => ExecutionScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => ExecutionScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ExecutionScalarWhereInputSchema),
          z.lazy(() => ExecutionScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      userId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      actionId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      ruleId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      executedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => EnumExecutionStatusFilterSchema),
          z.lazy(() => ExecutionStatusSchema)
        ])
        .optional(),
      errorMessage: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      resultPayload: z.lazy(() => JsonNullableFilterSchema).optional(),
      correlationId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable()
    })
    .strict();

export const QueueUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.QueueUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => QueueWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => QueueUpdateWithoutUserInputSchema),
        z.lazy(() => QueueUncheckedUpdateWithoutUserInputSchema)
      ]),
      create: z.union([
        z.lazy(() => QueueCreateWithoutUserInputSchema),
        z.lazy(() => QueueUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const QueueUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.QueueUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => QueueWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => QueueUpdateWithoutUserInputSchema),
        z.lazy(() => QueueUncheckedUpdateWithoutUserInputSchema)
      ])
    })
    .strict();

export const QueueUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.QueueUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => QueueScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => QueueUpdateManyMutationInputSchema),
        z.lazy(() => QueueUncheckedUpdateManyWithoutUserInputSchema)
      ])
    })
    .strict();

export const QueueScalarWhereInputSchema: z.ZodType<Prisma.QueueScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => QueueScalarWhereInputSchema),
          z.lazy(() => QueueScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => QueueScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => QueueScalarWhereInputSchema),
          z.lazy(() => QueueScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      job: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      payload: z.lazy(() => JsonFilterSchema).optional(),
      status: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      attempts: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      lastError: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      runAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      priority: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      processingStartedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      correlationId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      userId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable()
    })
    .strict();

export const OutboxUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.OutboxUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => OutboxWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => OutboxUpdateWithoutUserInputSchema),
        z.lazy(() => OutboxUncheckedUpdateWithoutUserInputSchema)
      ]),
      create: z.union([
        z.lazy(() => OutboxCreateWithoutUserInputSchema),
        z.lazy(() => OutboxUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const OutboxUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.OutboxUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => OutboxWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => OutboxUpdateWithoutUserInputSchema),
        z.lazy(() => OutboxUncheckedUpdateWithoutUserInputSchema)
      ])
    })
    .strict();

export const OutboxUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.OutboxUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => OutboxScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => OutboxUpdateManyMutationInputSchema),
        z.lazy(() => OutboxUncheckedUpdateManyWithoutUserInputSchema)
      ])
    })
    .strict();

export const FeedUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.FeedUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => FeedWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => FeedUpdateWithoutUserInputSchema),
        z.lazy(() => FeedUncheckedUpdateWithoutUserInputSchema)
      ]),
      create: z.union([
        z.lazy(() => FeedCreateWithoutUserInputSchema),
        z.lazy(() => FeedUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const FeedUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.FeedUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => FeedWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => FeedUpdateWithoutUserInputSchema),
        z.lazy(() => FeedUncheckedUpdateWithoutUserInputSchema)
      ])
    })
    .strict();

export const FeedUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.FeedUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => FeedScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => FeedUpdateManyMutationInputSchema),
        z.lazy(() => FeedUncheckedUpdateManyWithoutUserInputSchema)
      ])
    })
    .strict();

export const CommentUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.CommentUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => CommentWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => CommentUpdateWithoutUserInputSchema),
        z.lazy(() => CommentUncheckedUpdateWithoutUserInputSchema)
      ]),
      create: z.union([
        z.lazy(() => CommentCreateWithoutUserInputSchema),
        z.lazy(() => CommentUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const CommentUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.CommentUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => CommentWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => CommentUpdateWithoutUserInputSchema),
        z.lazy(() => CommentUncheckedUpdateWithoutUserInputSchema)
      ])
    })
    .strict();

export const CommentUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.CommentUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => CommentScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => CommentUpdateManyMutationInputSchema),
        z.lazy(() => CommentUncheckedUpdateManyWithoutUserInputSchema)
      ])
    })
    .strict();

export const MessageUpsertWithWhereUniqueWithoutSenderInputSchema: z.ZodType<Prisma.MessageUpsertWithWhereUniqueWithoutSenderInput> =
  z
    .object({
      where: z.lazy(() => MessageWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => MessageUpdateWithoutSenderInputSchema),
        z.lazy(() => MessageUncheckedUpdateWithoutSenderInputSchema)
      ]),
      create: z.union([
        z.lazy(() => MessageCreateWithoutSenderInputSchema),
        z.lazy(() => MessageUncheckedCreateWithoutSenderInputSchema)
      ])
    })
    .strict();

export const MessageUpdateWithWhereUniqueWithoutSenderInputSchema: z.ZodType<Prisma.MessageUpdateWithWhereUniqueWithoutSenderInput> =
  z
    .object({
      where: z.lazy(() => MessageWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => MessageUpdateWithoutSenderInputSchema),
        z.lazy(() => MessageUncheckedUpdateWithoutSenderInputSchema)
      ])
    })
    .strict();

export const MessageUpdateManyWithWhereWithoutSenderInputSchema: z.ZodType<Prisma.MessageUpdateManyWithWhereWithoutSenderInput> =
  z
    .object({
      where: z.lazy(() => MessageScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => MessageUpdateManyMutationInputSchema),
        z.lazy(() => MessageUncheckedUpdateManyWithoutSenderInputSchema)
      ])
    })
    .strict();

export const MessageScalarWhereInputSchema: z.ZodType<Prisma.MessageScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => MessageScalarWhereInputSchema),
          z.lazy(() => MessageScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => MessageScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => MessageScalarWhereInputSchema),
          z.lazy(() => MessageScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      content: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      senderEmail: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      receiveEmail: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional()
    })
    .strict();

export const MessageUpsertWithWhereUniqueWithoutReceiverInputSchema: z.ZodType<Prisma.MessageUpsertWithWhereUniqueWithoutReceiverInput> =
  z
    .object({
      where: z.lazy(() => MessageWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => MessageUpdateWithoutReceiverInputSchema),
        z.lazy(() => MessageUncheckedUpdateWithoutReceiverInputSchema)
      ]),
      create: z.union([
        z.lazy(() => MessageCreateWithoutReceiverInputSchema),
        z.lazy(() => MessageUncheckedCreateWithoutReceiverInputSchema)
      ])
    })
    .strict();

export const MessageUpdateWithWhereUniqueWithoutReceiverInputSchema: z.ZodType<Prisma.MessageUpdateWithWhereUniqueWithoutReceiverInput> =
  z
    .object({
      where: z.lazy(() => MessageWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => MessageUpdateWithoutReceiverInputSchema),
        z.lazy(() => MessageUncheckedUpdateWithoutReceiverInputSchema)
      ])
    })
    .strict();

export const MessageUpdateManyWithWhereWithoutReceiverInputSchema: z.ZodType<Prisma.MessageUpdateManyWithWhereWithoutReceiverInput> =
  z
    .object({
      where: z.lazy(() => MessageScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => MessageUpdateManyMutationInputSchema),
        z.lazy(() => MessageUncheckedUpdateManyWithoutReceiverInputSchema)
      ])
    })
    .strict();

export const ReservationUpsertWithWhereUniqueWithoutAffiliateInputSchema: z.ZodType<Prisma.ReservationUpsertWithWhereUniqueWithoutAffiliateInput> =
  z
    .object({
      where: z.lazy(() => ReservationWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ReservationUpdateWithoutAffiliateInputSchema),
        z.lazy(() => ReservationUncheckedUpdateWithoutAffiliateInputSchema)
      ]),
      create: z.union([
        z.lazy(() => ReservationCreateWithoutAffiliateInputSchema),
        z.lazy(() => ReservationUncheckedCreateWithoutAffiliateInputSchema)
      ])
    })
    .strict();

export const ReservationUpdateWithWhereUniqueWithoutAffiliateInputSchema: z.ZodType<Prisma.ReservationUpdateWithWhereUniqueWithoutAffiliateInput> =
  z
    .object({
      where: z.lazy(() => ReservationWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ReservationUpdateWithoutAffiliateInputSchema),
        z.lazy(() => ReservationUncheckedUpdateWithoutAffiliateInputSchema)
      ])
    })
    .strict();

export const ReservationUpdateManyWithWhereWithoutAffiliateInputSchema: z.ZodType<Prisma.ReservationUpdateManyWithWhereWithoutAffiliateInput> =
  z
    .object({
      where: z.lazy(() => ReservationScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ReservationUpdateManyMutationInputSchema),
        z.lazy(() => ReservationUncheckedUpdateManyWithoutAffiliateInputSchema)
      ])
    })
    .strict();

export const ListUpsertWithWhereUniqueWithoutContactsInputSchema: z.ZodType<Prisma.ListUpsertWithWhereUniqueWithoutContactsInput> =
  z
    .object({
      where: z.lazy(() => ListWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ListUpdateWithoutContactsInputSchema),
        z.lazy(() => ListUncheckedUpdateWithoutContactsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => ListCreateWithoutContactsInputSchema),
        z.lazy(() => ListUncheckedCreateWithoutContactsInputSchema)
      ])
    })
    .strict();

export const ListUpdateWithWhereUniqueWithoutContactsInputSchema: z.ZodType<Prisma.ListUpdateWithWhereUniqueWithoutContactsInput> =
  z
    .object({
      where: z.lazy(() => ListWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ListUpdateWithoutContactsInputSchema),
        z.lazy(() => ListUncheckedUpdateWithoutContactsInputSchema)
      ])
    })
    .strict();

export const ListUpdateManyWithWhereWithoutContactsInputSchema: z.ZodType<Prisma.ListUpdateManyWithWhereWithoutContactsInput> =
  z
    .object({
      where: z.lazy(() => ListScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ListUpdateManyMutationInputSchema),
        z.lazy(() => ListUncheckedUpdateManyWithoutContactsInputSchema)
      ])
    })
    .strict();

export const ListScalarWhereInputSchema: z.ZodType<Prisma.ListScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ListScalarWhereInputSchema),
          z.lazy(() => ListScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => ListScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ListScalarWhereInputSchema),
          z.lazy(() => ListScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      title: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional()
    })
    .strict();

export const ListUpsertWithWhereUniqueWithoutOwnersInputSchema: z.ZodType<Prisma.ListUpsertWithWhereUniqueWithoutOwnersInput> =
  z
    .object({
      where: z.lazy(() => ListWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ListUpdateWithoutOwnersInputSchema),
        z.lazy(() => ListUncheckedUpdateWithoutOwnersInputSchema)
      ]),
      create: z.union([
        z.lazy(() => ListCreateWithoutOwnersInputSchema),
        z.lazy(() => ListUncheckedCreateWithoutOwnersInputSchema)
      ])
    })
    .strict();

export const ListUpdateWithWhereUniqueWithoutOwnersInputSchema: z.ZodType<Prisma.ListUpdateWithWhereUniqueWithoutOwnersInput> =
  z
    .object({
      where: z.lazy(() => ListWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ListUpdateWithoutOwnersInputSchema),
        z.lazy(() => ListUncheckedUpdateWithoutOwnersInputSchema)
      ])
    })
    .strict();

export const ListUpdateManyWithWhereWithoutOwnersInputSchema: z.ZodType<Prisma.ListUpdateManyWithWhereWithoutOwnersInput> =
  z
    .object({
      where: z.lazy(() => ListScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ListUpdateManyMutationInputSchema),
        z.lazy(() => ListUncheckedUpdateManyWithoutOwnersInputSchema)
      ])
    })
    .strict();

export const EmailUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.EmailUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => EmailWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => EmailUpdateWithoutUserInputSchema),
        z.lazy(() => EmailUncheckedUpdateWithoutUserInputSchema)
      ]),
      create: z.union([
        z.lazy(() => EmailCreateWithoutUserInputSchema),
        z.lazy(() => EmailUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const EmailUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.EmailUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => EmailWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => EmailUpdateWithoutUserInputSchema),
        z.lazy(() => EmailUncheckedUpdateWithoutUserInputSchema)
      ])
    })
    .strict();

export const EmailUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.EmailUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => EmailScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => EmailUpdateManyMutationInputSchema),
        z.lazy(() => EmailUncheckedUpdateManyWithoutUserInputSchema)
      ])
    })
    .strict();

export const EmailScalarWhereInputSchema: z.ZodType<Prisma.EmailScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => EmailScalarWhereInputSchema),
          z.lazy(() => EmailScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => EmailScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => EmailScalarWhereInputSchema),
          z.lazy(() => EmailScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      title: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      subject: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      content: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      design: z.lazy(() => JsonFilterSchema).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional()
    })
    .strict();

export const ClickUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.ClickUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => ClickWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ClickUpdateWithoutUserInputSchema),
        z.lazy(() => ClickUncheckedUpdateWithoutUserInputSchema)
      ]),
      create: z.union([
        z.lazy(() => ClickCreateWithoutUserInputSchema),
        z.lazy(() => ClickUncheckedCreateWithoutUserInputSchema)
      ])
    })
    .strict();

export const ClickUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.ClickUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => ClickWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ClickUpdateWithoutUserInputSchema),
        z.lazy(() => ClickUncheckedUpdateWithoutUserInputSchema)
      ])
    })
    .strict();

export const ClickUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.ClickUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => ClickScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ClickUpdateManyMutationInputSchema),
        z.lazy(() => ClickUncheckedUpdateManyWithoutUserInputSchema)
      ])
    })
    .strict();

export const ClickUpsertWithWhereUniqueWithoutRefererInputSchema: z.ZodType<Prisma.ClickUpsertWithWhereUniqueWithoutRefererInput> =
  z
    .object({
      where: z.lazy(() => ClickWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ClickUpdateWithoutRefererInputSchema),
        z.lazy(() => ClickUncheckedUpdateWithoutRefererInputSchema)
      ]),
      create: z.union([
        z.lazy(() => ClickCreateWithoutRefererInputSchema),
        z.lazy(() => ClickUncheckedCreateWithoutRefererInputSchema)
      ])
    })
    .strict();

export const ClickUpdateWithWhereUniqueWithoutRefererInputSchema: z.ZodType<Prisma.ClickUpdateWithWhereUniqueWithoutRefererInput> =
  z
    .object({
      where: z.lazy(() => ClickWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ClickUpdateWithoutRefererInputSchema),
        z.lazy(() => ClickUncheckedUpdateWithoutRefererInputSchema)
      ])
    })
    .strict();

export const ClickUpdateManyWithWhereWithoutRefererInputSchema: z.ZodType<Prisma.ClickUpdateManyWithWhereWithoutRefererInput> =
  z
    .object({
      where: z.lazy(() => ClickScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ClickUpdateManyMutationInputSchema),
        z.lazy(() => ClickUncheckedUpdateManyWithoutRefererInputSchema)
      ])
    })
    .strict();

export const UserCreateWithoutSentInputSchema: z.ZodType<Prisma.UserCreateWithoutSentInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutSentInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutSentInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutSentInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutSentInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutSentInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutSentInputSchema)
      ])
    })
    .strict();

export const UserCreateWithoutReceivedInputSchema: z.ZodType<Prisma.UserCreateWithoutReceivedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutReceivedInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutReceivedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutReceivedInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutReceivedInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutReceivedInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutReceivedInputSchema)
      ])
    })
    .strict();

export const UserUpsertWithoutSentInputSchema: z.ZodType<Prisma.UserUpsertWithoutSentInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutSentInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutSentInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutSentInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutSentInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutSentInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutSentInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutSentInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutSentInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutSentInputSchema: z.ZodType<Prisma.UserUpdateWithoutSentInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutSentInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutSentInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUpsertWithoutReceivedInputSchema: z.ZodType<Prisma.UserUpsertWithoutReceivedInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutReceivedInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutReceivedInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutReceivedInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutReceivedInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutReceivedInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutReceivedInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutReceivedInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutReceivedInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutReceivedInputSchema: z.ZodType<Prisma.UserUpdateWithoutReceivedInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutReceivedInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutReceivedInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserCreateWithoutFeedbackInputSchema: z.ZodType<Prisma.UserCreateWithoutFeedbackInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutFeedbackInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutFeedbackInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutFeedbackInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutFeedbackInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutFeedbackInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutFeedbackInputSchema)
      ])
    })
    .strict();

export const UserUpsertWithoutFeedbackInputSchema: z.ZodType<Prisma.UserUpsertWithoutFeedbackInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutFeedbackInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutFeedbackInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutFeedbackInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutFeedbackInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutFeedbackInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutFeedbackInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutFeedbackInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutFeedbackInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutFeedbackInputSchema: z.ZodType<Prisma.UserUpdateWithoutFeedbackInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutFeedbackInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutFeedbackInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserCreateWithoutJobsInputSchema: z.ZodType<Prisma.UserCreateWithoutJobsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutJobsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutJobsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutJobsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutJobsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutJobsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutJobsInputSchema)
      ])
    })
    .strict();

export const UserUpsertWithoutJobsInputSchema: z.ZodType<Prisma.UserUpsertWithoutJobsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutJobsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutJobsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutJobsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutJobsInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutJobsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutJobsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutJobsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutJobsInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutJobsInputSchema: z.ZodType<Prisma.UserUpdateWithoutJobsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutJobsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutJobsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const RuleCreateWithoutActionInputSchema: z.ZodType<Prisma.RuleCreateWithoutActionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      delayMinutes: z.number().int().optional(),
      order: z.number().int().optional(),
      isActive: z.boolean().optional(),
      version: z.number().int().optional(),
      ruleConditions: z
        .lazy(() => RuleConditionCreateNestedManyWithoutRuleInputSchema)
        .optional(),
      workflow: z.lazy(() => WorkflowCreateNestedOneWithoutRulesInputSchema),
      trigger: z.lazy(() => TriggerCreateNestedOneWithoutRulesInputSchema),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutRuleInputSchema)
        .optional()
    })
    .strict();

export const RuleUncheckedCreateWithoutActionInputSchema: z.ZodType<Prisma.RuleUncheckedCreateWithoutActionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      workflowId: z.string(),
      triggerId: z.string(),
      delayMinutes: z.number().int().optional(),
      order: z.number().int().optional(),
      isActive: z.boolean().optional(),
      version: z.number().int().optional(),
      ruleConditions: z
        .lazy(
          () => RuleConditionUncheckedCreateNestedManyWithoutRuleInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutRuleInputSchema)
        .optional()
    })
    .strict();

export const RuleCreateOrConnectWithoutActionInputSchema: z.ZodType<Prisma.RuleCreateOrConnectWithoutActionInput> =
  z
    .object({
      where: z.lazy(() => RuleWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => RuleCreateWithoutActionInputSchema),
        z.lazy(() => RuleUncheckedCreateWithoutActionInputSchema)
      ])
    })
    .strict();

export const RuleCreateManyActionInputEnvelopeSchema: z.ZodType<Prisma.RuleCreateManyActionInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => RuleCreateManyActionInputSchema),
        z.lazy(() => RuleCreateManyActionInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ExecutionCreateWithoutActionInputSchema: z.ZodType<Prisma.ExecutionCreateWithoutActionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      executedAt: z.coerce.date().optional().nullable(),
      status: z.lazy(() => ExecutionStatusSchema).optional(),
      errorMessage: z.string().optional().nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z.string().optional().nullable(),
      user: z.lazy(() => UserCreateNestedOneWithoutExecutionsInputSchema),
      rule: z
        .lazy(() => RuleCreateNestedOneWithoutExecutionsInputSchema)
        .optional()
    })
    .strict();

export const ExecutionUncheckedCreateWithoutActionInputSchema: z.ZodType<Prisma.ExecutionUncheckedCreateWithoutActionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      userId: z.string(),
      ruleId: z.string().optional().nullable(),
      executedAt: z.coerce.date().optional().nullable(),
      status: z.lazy(() => ExecutionStatusSchema).optional(),
      errorMessage: z.string().optional().nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z.string().optional().nullable()
    })
    .strict();

export const ExecutionCreateOrConnectWithoutActionInputSchema: z.ZodType<Prisma.ExecutionCreateOrConnectWithoutActionInput> =
  z
    .object({
      where: z.lazy(() => ExecutionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ExecutionCreateWithoutActionInputSchema),
        z.lazy(() => ExecutionUncheckedCreateWithoutActionInputSchema)
      ])
    })
    .strict();

export const ExecutionCreateManyActionInputEnvelopeSchema: z.ZodType<Prisma.ExecutionCreateManyActionInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ExecutionCreateManyActionInputSchema),
        z.lazy(() => ExecutionCreateManyActionInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const RuleUpsertWithWhereUniqueWithoutActionInputSchema: z.ZodType<Prisma.RuleUpsertWithWhereUniqueWithoutActionInput> =
  z
    .object({
      where: z.lazy(() => RuleWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => RuleUpdateWithoutActionInputSchema),
        z.lazy(() => RuleUncheckedUpdateWithoutActionInputSchema)
      ]),
      create: z.union([
        z.lazy(() => RuleCreateWithoutActionInputSchema),
        z.lazy(() => RuleUncheckedCreateWithoutActionInputSchema)
      ])
    })
    .strict();

export const RuleUpdateWithWhereUniqueWithoutActionInputSchema: z.ZodType<Prisma.RuleUpdateWithWhereUniqueWithoutActionInput> =
  z
    .object({
      where: z.lazy(() => RuleWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => RuleUpdateWithoutActionInputSchema),
        z.lazy(() => RuleUncheckedUpdateWithoutActionInputSchema)
      ])
    })
    .strict();

export const RuleUpdateManyWithWhereWithoutActionInputSchema: z.ZodType<Prisma.RuleUpdateManyWithWhereWithoutActionInput> =
  z
    .object({
      where: z.lazy(() => RuleScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => RuleUpdateManyMutationInputSchema),
        z.lazy(() => RuleUncheckedUpdateManyWithoutActionInputSchema)
      ])
    })
    .strict();

export const RuleScalarWhereInputSchema: z.ZodType<Prisma.RuleScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => RuleScalarWhereInputSchema),
          z.lazy(() => RuleScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => RuleScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => RuleScalarWhereInputSchema),
          z.lazy(() => RuleScalarWhereInputSchema).array()
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      workflowId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      actionId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      triggerId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      delayMinutes: z
        .union([z.lazy(() => IntFilterSchema), z.number()])
        .optional(),
      order: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      isActive: z
        .union([z.lazy(() => BoolFilterSchema), z.boolean()])
        .optional(),
      version: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional()
    })
    .strict();

export const ExecutionUpsertWithWhereUniqueWithoutActionInputSchema: z.ZodType<Prisma.ExecutionUpsertWithWhereUniqueWithoutActionInput> =
  z
    .object({
      where: z.lazy(() => ExecutionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ExecutionUpdateWithoutActionInputSchema),
        z.lazy(() => ExecutionUncheckedUpdateWithoutActionInputSchema)
      ]),
      create: z.union([
        z.lazy(() => ExecutionCreateWithoutActionInputSchema),
        z.lazy(() => ExecutionUncheckedCreateWithoutActionInputSchema)
      ])
    })
    .strict();

export const ExecutionUpdateWithWhereUniqueWithoutActionInputSchema: z.ZodType<Prisma.ExecutionUpdateWithWhereUniqueWithoutActionInput> =
  z
    .object({
      where: z.lazy(() => ExecutionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ExecutionUpdateWithoutActionInputSchema),
        z.lazy(() => ExecutionUncheckedUpdateWithoutActionInputSchema)
      ])
    })
    .strict();

export const ExecutionUpdateManyWithWhereWithoutActionInputSchema: z.ZodType<Prisma.ExecutionUpdateManyWithWhereWithoutActionInput> =
  z
    .object({
      where: z.lazy(() => ExecutionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ExecutionUpdateManyMutationInputSchema),
        z.lazy(() => ExecutionUncheckedUpdateManyWithoutActionInputSchema)
      ])
    })
    .strict();

export const RuleCreateWithoutWorkflowInputSchema: z.ZodType<Prisma.RuleCreateWithoutWorkflowInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      delayMinutes: z.number().int().optional(),
      order: z.number().int().optional(),
      isActive: z.boolean().optional(),
      version: z.number().int().optional(),
      ruleConditions: z
        .lazy(() => RuleConditionCreateNestedManyWithoutRuleInputSchema)
        .optional(),
      action: z.lazy(() => ActionCreateNestedOneWithoutRulesInputSchema),
      trigger: z.lazy(() => TriggerCreateNestedOneWithoutRulesInputSchema),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutRuleInputSchema)
        .optional()
    })
    .strict();

export const RuleUncheckedCreateWithoutWorkflowInputSchema: z.ZodType<Prisma.RuleUncheckedCreateWithoutWorkflowInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      actionId: z.string(),
      triggerId: z.string(),
      delayMinutes: z.number().int().optional(),
      order: z.number().int().optional(),
      isActive: z.boolean().optional(),
      version: z.number().int().optional(),
      ruleConditions: z
        .lazy(
          () => RuleConditionUncheckedCreateNestedManyWithoutRuleInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutRuleInputSchema)
        .optional()
    })
    .strict();

export const RuleCreateOrConnectWithoutWorkflowInputSchema: z.ZodType<Prisma.RuleCreateOrConnectWithoutWorkflowInput> =
  z
    .object({
      where: z.lazy(() => RuleWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => RuleCreateWithoutWorkflowInputSchema),
        z.lazy(() => RuleUncheckedCreateWithoutWorkflowInputSchema)
      ])
    })
    .strict();

export const RuleCreateManyWorkflowInputEnvelopeSchema: z.ZodType<Prisma.RuleCreateManyWorkflowInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => RuleCreateManyWorkflowInputSchema),
        z.lazy(() => RuleCreateManyWorkflowInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const WorkflowStateCreateWithoutWorkflowInputSchema: z.ZodType<Prisma.WorkflowStateCreateWithoutWorkflowInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.lazy(() => WorkflowStateStatusSchema).optional(),
      startedAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutWorkflowStatesInputSchema)
    })
    .strict();

export const WorkflowStateUncheckedCreateWithoutWorkflowInputSchema: z.ZodType<Prisma.WorkflowStateUncheckedCreateWithoutWorkflowInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      userId: z.string(),
      status: z.lazy(() => WorkflowStateStatusSchema).optional(),
      startedAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const WorkflowStateCreateOrConnectWithoutWorkflowInputSchema: z.ZodType<Prisma.WorkflowStateCreateOrConnectWithoutWorkflowInput> =
  z
    .object({
      where: z.lazy(() => WorkflowStateWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => WorkflowStateCreateWithoutWorkflowInputSchema),
        z.lazy(() => WorkflowStateUncheckedCreateWithoutWorkflowInputSchema)
      ])
    })
    .strict();

export const WorkflowStateCreateManyWorkflowInputEnvelopeSchema: z.ZodType<Prisma.WorkflowStateCreateManyWorkflowInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => WorkflowStateCreateManyWorkflowInputSchema),
        z.lazy(() => WorkflowStateCreateManyWorkflowInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const RuleUpsertWithWhereUniqueWithoutWorkflowInputSchema: z.ZodType<Prisma.RuleUpsertWithWhereUniqueWithoutWorkflowInput> =
  z
    .object({
      where: z.lazy(() => RuleWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => RuleUpdateWithoutWorkflowInputSchema),
        z.lazy(() => RuleUncheckedUpdateWithoutWorkflowInputSchema)
      ]),
      create: z.union([
        z.lazy(() => RuleCreateWithoutWorkflowInputSchema),
        z.lazy(() => RuleUncheckedCreateWithoutWorkflowInputSchema)
      ])
    })
    .strict();

export const RuleUpdateWithWhereUniqueWithoutWorkflowInputSchema: z.ZodType<Prisma.RuleUpdateWithWhereUniqueWithoutWorkflowInput> =
  z
    .object({
      where: z.lazy(() => RuleWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => RuleUpdateWithoutWorkflowInputSchema),
        z.lazy(() => RuleUncheckedUpdateWithoutWorkflowInputSchema)
      ])
    })
    .strict();

export const RuleUpdateManyWithWhereWithoutWorkflowInputSchema: z.ZodType<Prisma.RuleUpdateManyWithWhereWithoutWorkflowInput> =
  z
    .object({
      where: z.lazy(() => RuleScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => RuleUpdateManyMutationInputSchema),
        z.lazy(() => RuleUncheckedUpdateManyWithoutWorkflowInputSchema)
      ])
    })
    .strict();

export const WorkflowStateUpsertWithWhereUniqueWithoutWorkflowInputSchema: z.ZodType<Prisma.WorkflowStateUpsertWithWhereUniqueWithoutWorkflowInput> =
  z
    .object({
      where: z.lazy(() => WorkflowStateWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => WorkflowStateUpdateWithoutWorkflowInputSchema),
        z.lazy(() => WorkflowStateUncheckedUpdateWithoutWorkflowInputSchema)
      ]),
      create: z.union([
        z.lazy(() => WorkflowStateCreateWithoutWorkflowInputSchema),
        z.lazy(() => WorkflowStateUncheckedCreateWithoutWorkflowInputSchema)
      ])
    })
    .strict();

export const WorkflowStateUpdateWithWhereUniqueWithoutWorkflowInputSchema: z.ZodType<Prisma.WorkflowStateUpdateWithWhereUniqueWithoutWorkflowInput> =
  z
    .object({
      where: z.lazy(() => WorkflowStateWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => WorkflowStateUpdateWithoutWorkflowInputSchema),
        z.lazy(() => WorkflowStateUncheckedUpdateWithoutWorkflowInputSchema)
      ])
    })
    .strict();

export const WorkflowStateUpdateManyWithWhereWithoutWorkflowInputSchema: z.ZodType<Prisma.WorkflowStateUpdateManyWithWhereWithoutWorkflowInput> =
  z
    .object({
      where: z.lazy(() => WorkflowStateScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => WorkflowStateUpdateManyMutationInputSchema),
        z.lazy(() => WorkflowStateUncheckedUpdateManyWithoutWorkflowInputSchema)
      ])
    })
    .strict();

export const RuleCreateWithoutTriggerInputSchema: z.ZodType<Prisma.RuleCreateWithoutTriggerInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      delayMinutes: z.number().int().optional(),
      order: z.number().int().optional(),
      isActive: z.boolean().optional(),
      version: z.number().int().optional(),
      ruleConditions: z
        .lazy(() => RuleConditionCreateNestedManyWithoutRuleInputSchema)
        .optional(),
      workflow: z.lazy(() => WorkflowCreateNestedOneWithoutRulesInputSchema),
      action: z.lazy(() => ActionCreateNestedOneWithoutRulesInputSchema),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutRuleInputSchema)
        .optional()
    })
    .strict();

export const RuleUncheckedCreateWithoutTriggerInputSchema: z.ZodType<Prisma.RuleUncheckedCreateWithoutTriggerInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      workflowId: z.string(),
      actionId: z.string(),
      delayMinutes: z.number().int().optional(),
      order: z.number().int().optional(),
      isActive: z.boolean().optional(),
      version: z.number().int().optional(),
      ruleConditions: z
        .lazy(
          () => RuleConditionUncheckedCreateNestedManyWithoutRuleInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutRuleInputSchema)
        .optional()
    })
    .strict();

export const RuleCreateOrConnectWithoutTriggerInputSchema: z.ZodType<Prisma.RuleCreateOrConnectWithoutTriggerInput> =
  z
    .object({
      where: z.lazy(() => RuleWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => RuleCreateWithoutTriggerInputSchema),
        z.lazy(() => RuleUncheckedCreateWithoutTriggerInputSchema)
      ])
    })
    .strict();

export const RuleCreateManyTriggerInputEnvelopeSchema: z.ZodType<Prisma.RuleCreateManyTriggerInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => RuleCreateManyTriggerInputSchema),
        z.lazy(() => RuleCreateManyTriggerInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const RuleUpsertWithWhereUniqueWithoutTriggerInputSchema: z.ZodType<Prisma.RuleUpsertWithWhereUniqueWithoutTriggerInput> =
  z
    .object({
      where: z.lazy(() => RuleWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => RuleUpdateWithoutTriggerInputSchema),
        z.lazy(() => RuleUncheckedUpdateWithoutTriggerInputSchema)
      ]),
      create: z.union([
        z.lazy(() => RuleCreateWithoutTriggerInputSchema),
        z.lazy(() => RuleUncheckedCreateWithoutTriggerInputSchema)
      ])
    })
    .strict();

export const RuleUpdateWithWhereUniqueWithoutTriggerInputSchema: z.ZodType<Prisma.RuleUpdateWithWhereUniqueWithoutTriggerInput> =
  z
    .object({
      where: z.lazy(() => RuleWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => RuleUpdateWithoutTriggerInputSchema),
        z.lazy(() => RuleUncheckedUpdateWithoutTriggerInputSchema)
      ])
    })
    .strict();

export const RuleUpdateManyWithWhereWithoutTriggerInputSchema: z.ZodType<Prisma.RuleUpdateManyWithWhereWithoutTriggerInput> =
  z
    .object({
      where: z.lazy(() => RuleScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => RuleUpdateManyMutationInputSchema),
        z.lazy(() => RuleUncheckedUpdateManyWithoutTriggerInputSchema)
      ])
    })
    .strict();

export const RuleConditionCreateWithoutRuleInputSchema: z.ZodType<Prisma.RuleConditionCreateWithoutRuleInput> =
  z
    .object({
      group: z.number().int().optional(),
      logic: z.lazy(() => OperatorSchema).optional(),
      condition: z.lazy(() => ConditionCreateNestedOneWithoutRulesInputSchema)
    })
    .strict();

export const RuleConditionUncheckedCreateWithoutRuleInputSchema: z.ZodType<Prisma.RuleConditionUncheckedCreateWithoutRuleInput> =
  z
    .object({
      conditionId: z.string(),
      group: z.number().int().optional(),
      logic: z.lazy(() => OperatorSchema).optional()
    })
    .strict();

export const RuleConditionCreateOrConnectWithoutRuleInputSchema: z.ZodType<Prisma.RuleConditionCreateOrConnectWithoutRuleInput> =
  z
    .object({
      where: z.lazy(() => RuleConditionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => RuleConditionCreateWithoutRuleInputSchema),
        z.lazy(() => RuleConditionUncheckedCreateWithoutRuleInputSchema)
      ])
    })
    .strict();

export const RuleConditionCreateManyRuleInputEnvelopeSchema: z.ZodType<Prisma.RuleConditionCreateManyRuleInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => RuleConditionCreateManyRuleInputSchema),
        z.lazy(() => RuleConditionCreateManyRuleInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const WorkflowCreateWithoutRulesInputSchema: z.ZodType<Prisma.WorkflowCreateWithoutRulesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      isDefault: z.boolean().optional(),
      isActive: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      states: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutWorkflowInputSchema)
        .optional()
    })
    .strict();

export const WorkflowUncheckedCreateWithoutRulesInputSchema: z.ZodType<Prisma.WorkflowUncheckedCreateWithoutRulesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      isDefault: z.boolean().optional(),
      isActive: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      states: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutWorkflowInputSchema
        )
        .optional()
    })
    .strict();

export const WorkflowCreateOrConnectWithoutRulesInputSchema: z.ZodType<Prisma.WorkflowCreateOrConnectWithoutRulesInput> =
  z
    .object({
      where: z.lazy(() => WorkflowWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => WorkflowCreateWithoutRulesInputSchema),
        z.lazy(() => WorkflowUncheckedCreateWithoutRulesInputSchema)
      ])
    })
    .strict();

export const ActionCreateWithoutRulesInputSchema: z.ZodType<Prisma.ActionCreateWithoutRulesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      code: z.string(),
      description: z.string().optional().nullable(),
      type: z.string(),
      config: z.union([
        z.lazy(() => JsonNullValueInputSchema),
        InputJsonValueSchema
      ]),
      isPublished: z.boolean().optional(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutActionInputSchema)
        .optional()
    })
    .strict();

export const ActionUncheckedCreateWithoutRulesInputSchema: z.ZodType<Prisma.ActionUncheckedCreateWithoutRulesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      code: z.string(),
      description: z.string().optional().nullable(),
      type: z.string(),
      config: z.union([
        z.lazy(() => JsonNullValueInputSchema),
        InputJsonValueSchema
      ]),
      isPublished: z.boolean().optional(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutActionInputSchema)
        .optional()
    })
    .strict();

export const ActionCreateOrConnectWithoutRulesInputSchema: z.ZodType<Prisma.ActionCreateOrConnectWithoutRulesInput> =
  z
    .object({
      where: z.lazy(() => ActionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ActionCreateWithoutRulesInputSchema),
        z.lazy(() => ActionUncheckedCreateWithoutRulesInputSchema)
      ])
    })
    .strict();

export const TriggerCreateWithoutRulesInputSchema: z.ZodType<Prisma.TriggerCreateWithoutRulesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      code: z.string(),
      description: z.string().optional().nullable()
    })
    .strict();

export const TriggerUncheckedCreateWithoutRulesInputSchema: z.ZodType<Prisma.TriggerUncheckedCreateWithoutRulesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      code: z.string(),
      description: z.string().optional().nullable()
    })
    .strict();

export const TriggerCreateOrConnectWithoutRulesInputSchema: z.ZodType<Prisma.TriggerCreateOrConnectWithoutRulesInput> =
  z
    .object({
      where: z.lazy(() => TriggerWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => TriggerCreateWithoutRulesInputSchema),
        z.lazy(() => TriggerUncheckedCreateWithoutRulesInputSchema)
      ])
    })
    .strict();

export const ExecutionCreateWithoutRuleInputSchema: z.ZodType<Prisma.ExecutionCreateWithoutRuleInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      executedAt: z.coerce.date().optional().nullable(),
      status: z.lazy(() => ExecutionStatusSchema).optional(),
      errorMessage: z.string().optional().nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z.string().optional().nullable(),
      user: z.lazy(() => UserCreateNestedOneWithoutExecutionsInputSchema),
      action: z.lazy(() => ActionCreateNestedOneWithoutExecutionsInputSchema)
    })
    .strict();

export const ExecutionUncheckedCreateWithoutRuleInputSchema: z.ZodType<Prisma.ExecutionUncheckedCreateWithoutRuleInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      userId: z.string(),
      actionId: z.string(),
      executedAt: z.coerce.date().optional().nullable(),
      status: z.lazy(() => ExecutionStatusSchema).optional(),
      errorMessage: z.string().optional().nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z.string().optional().nullable()
    })
    .strict();

export const ExecutionCreateOrConnectWithoutRuleInputSchema: z.ZodType<Prisma.ExecutionCreateOrConnectWithoutRuleInput> =
  z
    .object({
      where: z.lazy(() => ExecutionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ExecutionCreateWithoutRuleInputSchema),
        z.lazy(() => ExecutionUncheckedCreateWithoutRuleInputSchema)
      ])
    })
    .strict();

export const ExecutionCreateManyRuleInputEnvelopeSchema: z.ZodType<Prisma.ExecutionCreateManyRuleInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ExecutionCreateManyRuleInputSchema),
        z.lazy(() => ExecutionCreateManyRuleInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const RuleConditionUpsertWithWhereUniqueWithoutRuleInputSchema: z.ZodType<Prisma.RuleConditionUpsertWithWhereUniqueWithoutRuleInput> =
  z
    .object({
      where: z.lazy(() => RuleConditionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => RuleConditionUpdateWithoutRuleInputSchema),
        z.lazy(() => RuleConditionUncheckedUpdateWithoutRuleInputSchema)
      ]),
      create: z.union([
        z.lazy(() => RuleConditionCreateWithoutRuleInputSchema),
        z.lazy(() => RuleConditionUncheckedCreateWithoutRuleInputSchema)
      ])
    })
    .strict();

export const RuleConditionUpdateWithWhereUniqueWithoutRuleInputSchema: z.ZodType<Prisma.RuleConditionUpdateWithWhereUniqueWithoutRuleInput> =
  z
    .object({
      where: z.lazy(() => RuleConditionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => RuleConditionUpdateWithoutRuleInputSchema),
        z.lazy(() => RuleConditionUncheckedUpdateWithoutRuleInputSchema)
      ])
    })
    .strict();

export const RuleConditionUpdateManyWithWhereWithoutRuleInputSchema: z.ZodType<Prisma.RuleConditionUpdateManyWithWhereWithoutRuleInput> =
  z
    .object({
      where: z.lazy(() => RuleConditionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => RuleConditionUpdateManyMutationInputSchema),
        z.lazy(() => RuleConditionUncheckedUpdateManyWithoutRuleInputSchema)
      ])
    })
    .strict();

export const RuleConditionScalarWhereInputSchema: z.ZodType<Prisma.RuleConditionScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => RuleConditionScalarWhereInputSchema),
          z.lazy(() => RuleConditionScalarWhereInputSchema).array()
        ])
        .optional(),
      OR: z
        .lazy(() => RuleConditionScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => RuleConditionScalarWhereInputSchema),
          z.lazy(() => RuleConditionScalarWhereInputSchema).array()
        ])
        .optional(),
      ruleId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      conditionId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      group: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      logic: z
        .union([
          z.lazy(() => EnumOperatorFilterSchema),
          z.lazy(() => OperatorSchema)
        ])
        .optional()
    })
    .strict();

export const WorkflowUpsertWithoutRulesInputSchema: z.ZodType<Prisma.WorkflowUpsertWithoutRulesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => WorkflowUpdateWithoutRulesInputSchema),
        z.lazy(() => WorkflowUncheckedUpdateWithoutRulesInputSchema)
      ]),
      create: z.union([
        z.lazy(() => WorkflowCreateWithoutRulesInputSchema),
        z.lazy(() => WorkflowUncheckedCreateWithoutRulesInputSchema)
      ]),
      where: z.lazy(() => WorkflowWhereInputSchema).optional()
    })
    .strict();

export const WorkflowUpdateToOneWithWhereWithoutRulesInputSchema: z.ZodType<Prisma.WorkflowUpdateToOneWithWhereWithoutRulesInput> =
  z
    .object({
      where: z.lazy(() => WorkflowWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => WorkflowUpdateWithoutRulesInputSchema),
        z.lazy(() => WorkflowUncheckedUpdateWithoutRulesInputSchema)
      ])
    })
    .strict();

export const WorkflowUpdateWithoutRulesInputSchema: z.ZodType<Prisma.WorkflowUpdateWithoutRulesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isDefault: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      states: z
        .lazy(() => WorkflowStateUpdateManyWithoutWorkflowNestedInputSchema)
        .optional()
    })
    .strict();

export const WorkflowUncheckedUpdateWithoutRulesInputSchema: z.ZodType<Prisma.WorkflowUncheckedUpdateWithoutRulesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isDefault: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      states: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutWorkflowNestedInputSchema
        )
        .optional()
    })
    .strict();

export const ActionUpsertWithoutRulesInputSchema: z.ZodType<Prisma.ActionUpsertWithoutRulesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ActionUpdateWithoutRulesInputSchema),
        z.lazy(() => ActionUncheckedUpdateWithoutRulesInputSchema)
      ]),
      create: z.union([
        z.lazy(() => ActionCreateWithoutRulesInputSchema),
        z.lazy(() => ActionUncheckedCreateWithoutRulesInputSchema)
      ]),
      where: z.lazy(() => ActionWhereInputSchema).optional()
    })
    .strict();

export const ActionUpdateToOneWithWhereWithoutRulesInputSchema: z.ZodType<Prisma.ActionUpdateToOneWithWhereWithoutRulesInput> =
  z
    .object({
      where: z.lazy(() => ActionWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ActionUpdateWithoutRulesInputSchema),
        z.lazy(() => ActionUncheckedUpdateWithoutRulesInputSchema)
      ])
    })
    .strict();

export const ActionUpdateWithoutRulesInputSchema: z.ZodType<Prisma.ActionUpdateWithoutRulesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      code: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      config: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      isPublished: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutActionNestedInputSchema)
        .optional()
    })
    .strict();

export const ActionUncheckedUpdateWithoutRulesInputSchema: z.ZodType<Prisma.ActionUncheckedUpdateWithoutRulesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      code: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      config: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      isPublished: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutActionNestedInputSchema)
        .optional()
    })
    .strict();

export const TriggerUpsertWithoutRulesInputSchema: z.ZodType<Prisma.TriggerUpsertWithoutRulesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => TriggerUpdateWithoutRulesInputSchema),
        z.lazy(() => TriggerUncheckedUpdateWithoutRulesInputSchema)
      ]),
      create: z.union([
        z.lazy(() => TriggerCreateWithoutRulesInputSchema),
        z.lazy(() => TriggerUncheckedCreateWithoutRulesInputSchema)
      ]),
      where: z.lazy(() => TriggerWhereInputSchema).optional()
    })
    .strict();

export const TriggerUpdateToOneWithWhereWithoutRulesInputSchema: z.ZodType<Prisma.TriggerUpdateToOneWithWhereWithoutRulesInput> =
  z
    .object({
      where: z.lazy(() => TriggerWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => TriggerUpdateWithoutRulesInputSchema),
        z.lazy(() => TriggerUncheckedUpdateWithoutRulesInputSchema)
      ])
    })
    .strict();

export const TriggerUpdateWithoutRulesInputSchema: z.ZodType<Prisma.TriggerUpdateWithoutRulesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      code: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const TriggerUncheckedUpdateWithoutRulesInputSchema: z.ZodType<Prisma.TriggerUncheckedUpdateWithoutRulesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      code: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ExecutionUpsertWithWhereUniqueWithoutRuleInputSchema: z.ZodType<Prisma.ExecutionUpsertWithWhereUniqueWithoutRuleInput> =
  z
    .object({
      where: z.lazy(() => ExecutionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ExecutionUpdateWithoutRuleInputSchema),
        z.lazy(() => ExecutionUncheckedUpdateWithoutRuleInputSchema)
      ]),
      create: z.union([
        z.lazy(() => ExecutionCreateWithoutRuleInputSchema),
        z.lazy(() => ExecutionUncheckedCreateWithoutRuleInputSchema)
      ])
    })
    .strict();

export const ExecutionUpdateWithWhereUniqueWithoutRuleInputSchema: z.ZodType<Prisma.ExecutionUpdateWithWhereUniqueWithoutRuleInput> =
  z
    .object({
      where: z.lazy(() => ExecutionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ExecutionUpdateWithoutRuleInputSchema),
        z.lazy(() => ExecutionUncheckedUpdateWithoutRuleInputSchema)
      ])
    })
    .strict();

export const ExecutionUpdateManyWithWhereWithoutRuleInputSchema: z.ZodType<Prisma.ExecutionUpdateManyWithWhereWithoutRuleInput> =
  z
    .object({
      where: z.lazy(() => ExecutionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ExecutionUpdateManyMutationInputSchema),
        z.lazy(() => ExecutionUncheckedUpdateManyWithoutRuleInputSchema)
      ])
    })
    .strict();

export const RuleConditionCreateWithoutConditionInputSchema: z.ZodType<Prisma.RuleConditionCreateWithoutConditionInput> =
  z
    .object({
      group: z.number().int().optional(),
      logic: z.lazy(() => OperatorSchema).optional(),
      rule: z.lazy(() => RuleCreateNestedOneWithoutRuleConditionsInputSchema)
    })
    .strict();

export const RuleConditionUncheckedCreateWithoutConditionInputSchema: z.ZodType<Prisma.RuleConditionUncheckedCreateWithoutConditionInput> =
  z
    .object({
      ruleId: z.string(),
      group: z.number().int().optional(),
      logic: z.lazy(() => OperatorSchema).optional()
    })
    .strict();

export const RuleConditionCreateOrConnectWithoutConditionInputSchema: z.ZodType<Prisma.RuleConditionCreateOrConnectWithoutConditionInput> =
  z
    .object({
      where: z.lazy(() => RuleConditionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => RuleConditionCreateWithoutConditionInputSchema),
        z.lazy(() => RuleConditionUncheckedCreateWithoutConditionInputSchema)
      ])
    })
    .strict();

export const RuleConditionCreateManyConditionInputEnvelopeSchema: z.ZodType<Prisma.RuleConditionCreateManyConditionInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => RuleConditionCreateManyConditionInputSchema),
        z.lazy(() => RuleConditionCreateManyConditionInputSchema).array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const RuleConditionUpsertWithWhereUniqueWithoutConditionInputSchema: z.ZodType<Prisma.RuleConditionUpsertWithWhereUniqueWithoutConditionInput> =
  z
    .object({
      where: z.lazy(() => RuleConditionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => RuleConditionUpdateWithoutConditionInputSchema),
        z.lazy(() => RuleConditionUncheckedUpdateWithoutConditionInputSchema)
      ]),
      create: z.union([
        z.lazy(() => RuleConditionCreateWithoutConditionInputSchema),
        z.lazy(() => RuleConditionUncheckedCreateWithoutConditionInputSchema)
      ])
    })
    .strict();

export const RuleConditionUpdateWithWhereUniqueWithoutConditionInputSchema: z.ZodType<Prisma.RuleConditionUpdateWithWhereUniqueWithoutConditionInput> =
  z
    .object({
      where: z.lazy(() => RuleConditionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => RuleConditionUpdateWithoutConditionInputSchema),
        z.lazy(() => RuleConditionUncheckedUpdateWithoutConditionInputSchema)
      ])
    })
    .strict();

export const RuleConditionUpdateManyWithWhereWithoutConditionInputSchema: z.ZodType<Prisma.RuleConditionUpdateManyWithWhereWithoutConditionInput> =
  z
    .object({
      where: z.lazy(() => RuleConditionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => RuleConditionUpdateManyMutationInputSchema),
        z.lazy(
          () => RuleConditionUncheckedUpdateManyWithoutConditionInputSchema
        )
      ])
    })
    .strict();

export const RuleCreateWithoutRuleConditionsInputSchema: z.ZodType<Prisma.RuleCreateWithoutRuleConditionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      delayMinutes: z.number().int().optional(),
      order: z.number().int().optional(),
      isActive: z.boolean().optional(),
      version: z.number().int().optional(),
      workflow: z.lazy(() => WorkflowCreateNestedOneWithoutRulesInputSchema),
      action: z.lazy(() => ActionCreateNestedOneWithoutRulesInputSchema),
      trigger: z.lazy(() => TriggerCreateNestedOneWithoutRulesInputSchema),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutRuleInputSchema)
        .optional()
    })
    .strict();

export const RuleUncheckedCreateWithoutRuleConditionsInputSchema: z.ZodType<Prisma.RuleUncheckedCreateWithoutRuleConditionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      workflowId: z.string(),
      actionId: z.string(),
      triggerId: z.string(),
      delayMinutes: z.number().int().optional(),
      order: z.number().int().optional(),
      isActive: z.boolean().optional(),
      version: z.number().int().optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutRuleInputSchema)
        .optional()
    })
    .strict();

export const RuleCreateOrConnectWithoutRuleConditionsInputSchema: z.ZodType<Prisma.RuleCreateOrConnectWithoutRuleConditionsInput> =
  z
    .object({
      where: z.lazy(() => RuleWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => RuleCreateWithoutRuleConditionsInputSchema),
        z.lazy(() => RuleUncheckedCreateWithoutRuleConditionsInputSchema)
      ])
    })
    .strict();

export const ConditionCreateWithoutRulesInputSchema: z.ZodType<Prisma.ConditionCreateWithoutRulesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      type: z.lazy(() => ConditionTypeSchema),
      parameters: z.union([
        z.lazy(() => JsonNullValueInputSchema),
        InputJsonValueSchema
      ]),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const ConditionUncheckedCreateWithoutRulesInputSchema: z.ZodType<Prisma.ConditionUncheckedCreateWithoutRulesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      type: z.lazy(() => ConditionTypeSchema),
      parameters: z.union([
        z.lazy(() => JsonNullValueInputSchema),
        InputJsonValueSchema
      ]),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const ConditionCreateOrConnectWithoutRulesInputSchema: z.ZodType<Prisma.ConditionCreateOrConnectWithoutRulesInput> =
  z
    .object({
      where: z.lazy(() => ConditionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ConditionCreateWithoutRulesInputSchema),
        z.lazy(() => ConditionUncheckedCreateWithoutRulesInputSchema)
      ])
    })
    .strict();

export const RuleUpsertWithoutRuleConditionsInputSchema: z.ZodType<Prisma.RuleUpsertWithoutRuleConditionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => RuleUpdateWithoutRuleConditionsInputSchema),
        z.lazy(() => RuleUncheckedUpdateWithoutRuleConditionsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => RuleCreateWithoutRuleConditionsInputSchema),
        z.lazy(() => RuleUncheckedCreateWithoutRuleConditionsInputSchema)
      ]),
      where: z.lazy(() => RuleWhereInputSchema).optional()
    })
    .strict();

export const RuleUpdateToOneWithWhereWithoutRuleConditionsInputSchema: z.ZodType<Prisma.RuleUpdateToOneWithWhereWithoutRuleConditionsInput> =
  z
    .object({
      where: z.lazy(() => RuleWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => RuleUpdateWithoutRuleConditionsInputSchema),
        z.lazy(() => RuleUncheckedUpdateWithoutRuleConditionsInputSchema)
      ])
    })
    .strict();

export const RuleUpdateWithoutRuleConditionsInputSchema: z.ZodType<Prisma.RuleUpdateWithoutRuleConditionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      delayMinutes: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      order: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      workflow: z
        .lazy(() => WorkflowUpdateOneRequiredWithoutRulesNestedInputSchema)
        .optional(),
      action: z
        .lazy(() => ActionUpdateOneRequiredWithoutRulesNestedInputSchema)
        .optional(),
      trigger: z
        .lazy(() => TriggerUpdateOneRequiredWithoutRulesNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutRuleNestedInputSchema)
        .optional()
    })
    .strict();

export const RuleUncheckedUpdateWithoutRuleConditionsInputSchema: z.ZodType<Prisma.RuleUncheckedUpdateWithoutRuleConditionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      workflowId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      actionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      triggerId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      delayMinutes: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      order: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutRuleNestedInputSchema)
        .optional()
    })
    .strict();

export const ConditionUpsertWithoutRulesInputSchema: z.ZodType<Prisma.ConditionUpsertWithoutRulesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ConditionUpdateWithoutRulesInputSchema),
        z.lazy(() => ConditionUncheckedUpdateWithoutRulesInputSchema)
      ]),
      create: z.union([
        z.lazy(() => ConditionCreateWithoutRulesInputSchema),
        z.lazy(() => ConditionUncheckedCreateWithoutRulesInputSchema)
      ]),
      where: z.lazy(() => ConditionWhereInputSchema).optional()
    })
    .strict();

export const ConditionUpdateToOneWithWhereWithoutRulesInputSchema: z.ZodType<Prisma.ConditionUpdateToOneWithWhereWithoutRulesInput> =
  z
    .object({
      where: z.lazy(() => ConditionWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ConditionUpdateWithoutRulesInputSchema),
        z.lazy(() => ConditionUncheckedUpdateWithoutRulesInputSchema)
      ])
    })
    .strict();

export const ConditionUpdateWithoutRulesInputSchema: z.ZodType<Prisma.ConditionUpdateWithoutRulesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => ConditionTypeSchema),
          z.lazy(() => EnumConditionTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      parameters: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const ConditionUncheckedUpdateWithoutRulesInputSchema: z.ZodType<Prisma.ConditionUncheckedUpdateWithoutRulesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => ConditionTypeSchema),
          z.lazy(() => EnumConditionTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      parameters: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserCreateWithoutEventsInputSchema: z.ZodType<Prisma.UserCreateWithoutEventsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutEventsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutEventsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutEventsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutEventsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutEventsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutEventsInputSchema)
      ])
    })
    .strict();

export const UserUpsertWithoutEventsInputSchema: z.ZodType<Prisma.UserUpsertWithoutEventsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutEventsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutEventsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutEventsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutEventsInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutEventsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutEventsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutEventsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutEventsInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutEventsInputSchema: z.ZodType<Prisma.UserUpdateWithoutEventsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutEventsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutEventsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserCreateWithoutWorkflowStatesInputSchema: z.ZodType<Prisma.UserCreateWithoutWorkflowStatesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutWorkflowStatesInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutWorkflowStatesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutWorkflowStatesInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutWorkflowStatesInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutWorkflowStatesInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutWorkflowStatesInputSchema)
      ])
    })
    .strict();

export const WorkflowCreateWithoutStatesInputSchema: z.ZodType<Prisma.WorkflowCreateWithoutStatesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      isDefault: z.boolean().optional(),
      isActive: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      rules: z
        .lazy(() => RuleCreateNestedManyWithoutWorkflowInputSchema)
        .optional()
    })
    .strict();

export const WorkflowUncheckedCreateWithoutStatesInputSchema: z.ZodType<Prisma.WorkflowUncheckedCreateWithoutStatesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      isDefault: z.boolean().optional(),
      isActive: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      rules: z
        .lazy(() => RuleUncheckedCreateNestedManyWithoutWorkflowInputSchema)
        .optional()
    })
    .strict();

export const WorkflowCreateOrConnectWithoutStatesInputSchema: z.ZodType<Prisma.WorkflowCreateOrConnectWithoutStatesInput> =
  z
    .object({
      where: z.lazy(() => WorkflowWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => WorkflowCreateWithoutStatesInputSchema),
        z.lazy(() => WorkflowUncheckedCreateWithoutStatesInputSchema)
      ])
    })
    .strict();

export const UserUpsertWithoutWorkflowStatesInputSchema: z.ZodType<Prisma.UserUpsertWithoutWorkflowStatesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutWorkflowStatesInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutWorkflowStatesInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutWorkflowStatesInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutWorkflowStatesInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutWorkflowStatesInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutWorkflowStatesInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutWorkflowStatesInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutWorkflowStatesInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutWorkflowStatesInputSchema: z.ZodType<Prisma.UserUpdateWithoutWorkflowStatesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutWorkflowStatesInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutWorkflowStatesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const WorkflowUpsertWithoutStatesInputSchema: z.ZodType<Prisma.WorkflowUpsertWithoutStatesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => WorkflowUpdateWithoutStatesInputSchema),
        z.lazy(() => WorkflowUncheckedUpdateWithoutStatesInputSchema)
      ]),
      create: z.union([
        z.lazy(() => WorkflowCreateWithoutStatesInputSchema),
        z.lazy(() => WorkflowUncheckedCreateWithoutStatesInputSchema)
      ]),
      where: z.lazy(() => WorkflowWhereInputSchema).optional()
    })
    .strict();

export const WorkflowUpdateToOneWithWhereWithoutStatesInputSchema: z.ZodType<Prisma.WorkflowUpdateToOneWithWhereWithoutStatesInput> =
  z
    .object({
      where: z.lazy(() => WorkflowWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => WorkflowUpdateWithoutStatesInputSchema),
        z.lazy(() => WorkflowUncheckedUpdateWithoutStatesInputSchema)
      ])
    })
    .strict();

export const WorkflowUpdateWithoutStatesInputSchema: z.ZodType<Prisma.WorkflowUpdateWithoutStatesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isDefault: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      rules: z
        .lazy(() => RuleUpdateManyWithoutWorkflowNestedInputSchema)
        .optional()
    })
    .strict();

export const WorkflowUncheckedUpdateWithoutStatesInputSchema: z.ZodType<Prisma.WorkflowUncheckedUpdateWithoutStatesInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isDefault: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      rules: z
        .lazy(() => RuleUncheckedUpdateManyWithoutWorkflowNestedInputSchema)
        .optional()
    })
    .strict();

export const UserCreateWithoutExecutionsInputSchema: z.ZodType<Prisma.UserCreateWithoutExecutionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorCreateNestedManyWithoutUserInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationCreateNestedOneWithoutUserInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserCreateNestedOneWithoutAffiliatesInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeCreateNestedOneWithoutUsersInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateCreateNestedManyWithoutUserInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z.lazy(() => FeedCreateNestedManyWithoutUserInputSchema).optional(),
      comments: z
        .lazy(() => CommentCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationCreateNestedManyWithoutAffiliateInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedCreateWithoutExecutionsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutExecutionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable(),
      codeNaf: z.string().optional().nullable(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedCreateNestedManyWithoutUserInputSchema
        )
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutSenderInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedCreateNestedManyWithoutReceiverInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedCreateNestedManyWithoutAffiliateInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutContactsInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedCreateNestedManyWithoutOwnersInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedCreateNestedManyWithoutRefererInputSchema)
        .optional()
    })
    .strict();

export const UserCreateOrConnectWithoutExecutionsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutExecutionsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutExecutionsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutExecutionsInputSchema)
      ])
    })
    .strict();

export const ActionCreateWithoutExecutionsInputSchema: z.ZodType<Prisma.ActionCreateWithoutExecutionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      code: z.string(),
      description: z.string().optional().nullable(),
      type: z.string(),
      config: z.union([
        z.lazy(() => JsonNullValueInputSchema),
        InputJsonValueSchema
      ]),
      isPublished: z.boolean().optional(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      rules: z
        .lazy(() => RuleCreateNestedManyWithoutActionInputSchema)
        .optional()
    })
    .strict();

export const ActionUncheckedCreateWithoutExecutionsInputSchema: z.ZodType<Prisma.ActionUncheckedCreateWithoutExecutionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      code: z.string(),
      description: z.string().optional().nullable(),
      type: z.string(),
      config: z.union([
        z.lazy(() => JsonNullValueInputSchema),
        InputJsonValueSchema
      ]),
      isPublished: z.boolean().optional(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      rules: z
        .lazy(() => RuleUncheckedCreateNestedManyWithoutActionInputSchema)
        .optional()
    })
    .strict();

export const ActionCreateOrConnectWithoutExecutionsInputSchema: z.ZodType<Prisma.ActionCreateOrConnectWithoutExecutionsInput> =
  z
    .object({
      where: z.lazy(() => ActionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ActionCreateWithoutExecutionsInputSchema),
        z.lazy(() => ActionUncheckedCreateWithoutExecutionsInputSchema)
      ])
    })
    .strict();

export const RuleCreateWithoutExecutionsInputSchema: z.ZodType<Prisma.RuleCreateWithoutExecutionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      delayMinutes: z.number().int().optional(),
      order: z.number().int().optional(),
      isActive: z.boolean().optional(),
      version: z.number().int().optional(),
      ruleConditions: z
        .lazy(() => RuleConditionCreateNestedManyWithoutRuleInputSchema)
        .optional(),
      workflow: z.lazy(() => WorkflowCreateNestedOneWithoutRulesInputSchema),
      action: z.lazy(() => ActionCreateNestedOneWithoutRulesInputSchema),
      trigger: z.lazy(() => TriggerCreateNestedOneWithoutRulesInputSchema)
    })
    .strict();

export const RuleUncheckedCreateWithoutExecutionsInputSchema: z.ZodType<Prisma.RuleUncheckedCreateWithoutExecutionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      workflowId: z.string(),
      actionId: z.string(),
      triggerId: z.string(),
      delayMinutes: z.number().int().optional(),
      order: z.number().int().optional(),
      isActive: z.boolean().optional(),
      version: z.number().int().optional(),
      ruleConditions: z
        .lazy(
          () => RuleConditionUncheckedCreateNestedManyWithoutRuleInputSchema
        )
        .optional()
    })
    .strict();

export const RuleCreateOrConnectWithoutExecutionsInputSchema: z.ZodType<Prisma.RuleCreateOrConnectWithoutExecutionsInput> =
  z
    .object({
      where: z.lazy(() => RuleWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => RuleCreateWithoutExecutionsInputSchema),
        z.lazy(() => RuleUncheckedCreateWithoutExecutionsInputSchema)
      ])
    })
    .strict();

export const UserUpsertWithoutExecutionsInputSchema: z.ZodType<Prisma.UserUpsertWithoutExecutionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutExecutionsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutExecutionsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutExecutionsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutExecutionsInputSchema)
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional()
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutExecutionsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutExecutionsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutExecutionsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutExecutionsInputSchema)
      ])
    })
    .strict();

export const UserUpdateWithoutExecutionsInputSchema: z.ZodType<Prisma.UserUpdateWithoutExecutionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutExecutionsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutExecutionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const ActionUpsertWithoutExecutionsInputSchema: z.ZodType<Prisma.ActionUpsertWithoutExecutionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ActionUpdateWithoutExecutionsInputSchema),
        z.lazy(() => ActionUncheckedUpdateWithoutExecutionsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => ActionCreateWithoutExecutionsInputSchema),
        z.lazy(() => ActionUncheckedCreateWithoutExecutionsInputSchema)
      ]),
      where: z.lazy(() => ActionWhereInputSchema).optional()
    })
    .strict();

export const ActionUpdateToOneWithWhereWithoutExecutionsInputSchema: z.ZodType<Prisma.ActionUpdateToOneWithWhereWithoutExecutionsInput> =
  z
    .object({
      where: z.lazy(() => ActionWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ActionUpdateWithoutExecutionsInputSchema),
        z.lazy(() => ActionUncheckedUpdateWithoutExecutionsInputSchema)
      ])
    })
    .strict();

export const ActionUpdateWithoutExecutionsInputSchema: z.ZodType<Prisma.ActionUpdateWithoutExecutionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      code: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      config: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      isPublished: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      rules: z
        .lazy(() => RuleUpdateManyWithoutActionNestedInputSchema)
        .optional()
    })
    .strict();

export const ActionUncheckedUpdateWithoutExecutionsInputSchema: z.ZodType<Prisma.ActionUncheckedUpdateWithoutExecutionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      code: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      type: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      config: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      isPublished: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      rules: z
        .lazy(() => RuleUncheckedUpdateManyWithoutActionNestedInputSchema)
        .optional()
    })
    .strict();

export const RuleUpsertWithoutExecutionsInputSchema: z.ZodType<Prisma.RuleUpsertWithoutExecutionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => RuleUpdateWithoutExecutionsInputSchema),
        z.lazy(() => RuleUncheckedUpdateWithoutExecutionsInputSchema)
      ]),
      create: z.union([
        z.lazy(() => RuleCreateWithoutExecutionsInputSchema),
        z.lazy(() => RuleUncheckedCreateWithoutExecutionsInputSchema)
      ]),
      where: z.lazy(() => RuleWhereInputSchema).optional()
    })
    .strict();

export const RuleUpdateToOneWithWhereWithoutExecutionsInputSchema: z.ZodType<Prisma.RuleUpdateToOneWithWhereWithoutExecutionsInput> =
  z
    .object({
      where: z.lazy(() => RuleWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => RuleUpdateWithoutExecutionsInputSchema),
        z.lazy(() => RuleUncheckedUpdateWithoutExecutionsInputSchema)
      ])
    })
    .strict();

export const RuleUpdateWithoutExecutionsInputSchema: z.ZodType<Prisma.RuleUpdateWithoutExecutionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      delayMinutes: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      order: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ruleConditions: z
        .lazy(() => RuleConditionUpdateManyWithoutRuleNestedInputSchema)
        .optional(),
      workflow: z
        .lazy(() => WorkflowUpdateOneRequiredWithoutRulesNestedInputSchema)
        .optional(),
      action: z
        .lazy(() => ActionUpdateOneRequiredWithoutRulesNestedInputSchema)
        .optional(),
      trigger: z
        .lazy(() => TriggerUpdateOneRequiredWithoutRulesNestedInputSchema)
        .optional()
    })
    .strict();

export const RuleUncheckedUpdateWithoutExecutionsInputSchema: z.ZodType<Prisma.RuleUncheckedUpdateWithoutExecutionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      workflowId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      actionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      triggerId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      delayMinutes: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      order: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ruleConditions: z
        .lazy(
          () => RuleConditionUncheckedUpdateManyWithoutRuleNestedInputSchema
        )
        .optional()
    })
    .strict();

export const PriceCreateManyProductInputSchema: z.ZodType<Prisma.PriceCreateManyProductInput> =
  z
    .object({
      id: z.string(),
      active: z.boolean(),
      description: z.string(),
      unit_amount: z.number().int().optional().nullable(),
      currency: z.string(),
      type: z.lazy(() => PricingTypeSchema),
      interval: z
        .lazy(() => PricingPlanIntervalSchema)
        .optional()
        .nullable(),
      interval_count: z.number().int().optional().nullable(),
      trial_period_days: z.number().int().optional().nullable(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional()
    })
    .strict();

export const PriceUpdateWithoutProductInputSchema: z.ZodType<Prisma.PriceUpdateWithoutProductInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      unit_amount: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => PricingTypeSchema),
          z.lazy(() => EnumPricingTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      interval: z
        .union([
          z.lazy(() => PricingPlanIntervalSchema),
          z.lazy(
            () =>
              NullableEnumPricingPlanIntervalFieldUpdateOperationsInputSchema
          )
        ])
        .optional()
        .nullable(),
      interval_count: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_period_days: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutPriceNestedInputSchema)
        .optional()
    })
    .strict();

export const PriceUncheckedUpdateWithoutProductInputSchema: z.ZodType<Prisma.PriceUncheckedUpdateWithoutProductInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      unit_amount: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => PricingTypeSchema),
          z.lazy(() => EnumPricingTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      interval: z
        .union([
          z.lazy(() => PricingPlanIntervalSchema),
          z.lazy(
            () =>
              NullableEnumPricingPlanIntervalFieldUpdateOperationsInputSchema
          )
        ])
        .optional()
        .nullable(),
      interval_count: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_period_days: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      subscriptions: z
        .lazy(
          () => SubscriptionUncheckedUpdateManyWithoutPriceNestedInputSchema
        )
        .optional()
    })
    .strict();

export const PriceUncheckedUpdateManyWithoutProductInputSchema: z.ZodType<Prisma.PriceUncheckedUpdateManyWithoutProductInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      unit_amount: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => PricingTypeSchema),
          z.lazy(() => EnumPricingTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      interval: z
        .union([
          z.lazy(() => PricingPlanIntervalSchema),
          z.lazy(
            () =>
              NullableEnumPricingPlanIntervalFieldUpdateOperationsInputSchema
          )
        ])
        .optional()
        .nullable(),
      interval_count: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_period_days: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional()
    })
    .strict();

export const SubscriptionCreateManyPriceInputSchema: z.ZodType<Prisma.SubscriptionCreateManyPriceInput> =
  z
    .object({
      id: z.string(),
      status: z.lazy(() => SubscriptionStatusSchema),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      quantity: z.number().int(),
      cancel_at_period_end: z.boolean(),
      created: z.coerce.date().optional(),
      current_period_start: z.coerce.date().optional(),
      current_period_end: z.coerce.date().optional(),
      ended_at: z.coerce.date().optional().nullable(),
      cancel_at: z.coerce.date().optional().nullable(),
      canceled_at: z.coerce.date().optional().nullable(),
      trial_start: z.coerce.date().optional().nullable(),
      trial_end: z.coerce.date().optional().nullable(),
      userId: z.string()
    })
    .strict();

export const SubscriptionUpdateWithoutPriceInputSchema: z.ZodType<Prisma.SubscriptionUpdateWithoutPriceInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      cancel_at_period_end: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      created: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      current_period_start: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      current_period_end: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ended_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      cancel_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      canceled_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_start: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_end: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutSubscriptionsNestedInputSchema)
        .optional()
    })
    .strict();

export const SubscriptionUncheckedUpdateWithoutPriceInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateWithoutPriceInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      cancel_at_period_end: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      created: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      current_period_start: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      current_period_end: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ended_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      cancel_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      canceled_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_start: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_end: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const SubscriptionUncheckedUpdateManyWithoutPriceInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateManyWithoutPriceInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      cancel_at_period_end: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      created: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      current_period_start: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      current_period_end: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ended_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      cancel_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      canceled_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_start: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_end: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const CommentCreateManyFeedInputSchema: z.ZodType<Prisma.CommentCreateManyFeedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      content: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string()
    })
    .strict();

export const LikeCreateManyFeedInputSchema: z.ZodType<Prisma.LikeCreateManyFeedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      ip: z.string(),
      createdAt: z.coerce.date().optional(),
      siteId: z.string(),
      userId: z.string().optional().nullable()
    })
    .strict();

export const CommentUpdateWithoutFeedInputSchema: z.ZodType<Prisma.CommentUpdateWithoutFeedInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutCommentsNestedInputSchema)
        .optional()
    })
    .strict();

export const CommentUncheckedUpdateWithoutFeedInputSchema: z.ZodType<Prisma.CommentUncheckedUpdateWithoutFeedInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const CommentUncheckedUpdateManyWithoutFeedInputSchema: z.ZodType<Prisma.CommentUncheckedUpdateManyWithoutFeedInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const LikeUpdateWithoutFeedInputSchema: z.ZodType<Prisma.LikeUpdateWithoutFeedInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ip: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      site: z
        .lazy(() => SiteUpdateOneRequiredWithoutLikesNestedInputSchema)
        .optional(),
      user: z.lazy(() => UserUpdateOneWithoutLikesNestedInputSchema).optional()
    })
    .strict();

export const LikeUncheckedUpdateWithoutFeedInputSchema: z.ZodType<Prisma.LikeUncheckedUpdateWithoutFeedInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ip: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const LikeUncheckedUpdateManyWithoutFeedInputSchema: z.ZodType<Prisma.LikeUncheckedUpdateManyWithoutFeedInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ip: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const NafDivisionCreateManySectionInputSchema: z.ZodType<Prisma.NafDivisionCreateManySectionInput> =
  z
    .object({
      id: z.string(),
      title: z.string()
    })
    .strict();

export const NafDivisionUpdateWithoutSectionInputSchema: z.ZodType<Prisma.NafDivisionUpdateWithoutSectionInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      groups: z
        .lazy(() => NafGroupUpdateManyWithoutDivisionNestedInputSchema)
        .optional()
    })
    .strict();

export const NafDivisionUncheckedUpdateWithoutSectionInputSchema: z.ZodType<Prisma.NafDivisionUncheckedUpdateWithoutSectionInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      groups: z
        .lazy(() => NafGroupUncheckedUpdateManyWithoutDivisionNestedInputSchema)
        .optional()
    })
    .strict();

export const NafDivisionUncheckedUpdateManyWithoutSectionInputSchema: z.ZodType<Prisma.NafDivisionUncheckedUpdateManyWithoutSectionInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const NafGroupCreateManyDivisionInputSchema: z.ZodType<Prisma.NafGroupCreateManyDivisionInput> =
  z
    .object({
      id: z.string(),
      title: z.string()
    })
    .strict();

export const NafGroupUpdateWithoutDivisionInputSchema: z.ZodType<Prisma.NafGroupUpdateWithoutDivisionInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      classes: z
        .lazy(() => NafClassUpdateManyWithoutGroupNestedInputSchema)
        .optional()
    })
    .strict();

export const NafGroupUncheckedUpdateWithoutDivisionInputSchema: z.ZodType<Prisma.NafGroupUncheckedUpdateWithoutDivisionInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      classes: z
        .lazy(() => NafClassUncheckedUpdateManyWithoutGroupNestedInputSchema)
        .optional()
    })
    .strict();

export const NafGroupUncheckedUpdateManyWithoutDivisionInputSchema: z.ZodType<Prisma.NafGroupUncheckedUpdateManyWithoutDivisionInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const NafClassCreateManyGroupInputSchema: z.ZodType<Prisma.NafClassCreateManyGroupInput> =
  z
    .object({
      id: z.string(),
      title: z.string()
    })
    .strict();

export const NafClassUpdateWithoutGroupInputSchema: z.ZodType<Prisma.NafClassUpdateWithoutGroupInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      codes: z
        .lazy(() => NafCodeUpdateManyWithoutClassNestedInputSchema)
        .optional()
    })
    .strict();

export const NafClassUncheckedUpdateWithoutGroupInputSchema: z.ZodType<Prisma.NafClassUncheckedUpdateWithoutGroupInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      codes: z
        .lazy(() => NafCodeUncheckedUpdateManyWithoutClassNestedInputSchema)
        .optional()
    })
    .strict();

export const NafClassUncheckedUpdateManyWithoutGroupInputSchema: z.ZodType<Prisma.NafClassUncheckedUpdateManyWithoutGroupInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const NafCodeCreateManyClassInputSchema: z.ZodType<Prisma.NafCodeCreateManyClassInput> =
  z
    .object({
      id: z.string(),
      title: z.string()
    })
    .strict();

export const NafCodeUpdateWithoutClassInputSchema: z.ZodType<Prisma.NafCodeUpdateWithoutClassInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      users: z.lazy(() => UserUpdateManyWithoutNafNestedInputSchema).optional()
    })
    .strict();

export const NafCodeUncheckedUpdateWithoutClassInputSchema: z.ZodType<Prisma.NafCodeUncheckedUpdateWithoutClassInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      users: z
        .lazy(() => UserUncheckedUpdateManyWithoutNafNestedInputSchema)
        .optional()
    })
    .strict();

export const NafCodeUncheckedUpdateManyWithoutClassInputSchema: z.ZodType<Prisma.NafCodeUncheckedUpdateManyWithoutClassInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const UserCreateManyNafInputSchema: z.ZodType<Prisma.UserCreateManyNafInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      refererId: z.string().optional().nullable()
    })
    .strict();

export const UserUpdateWithoutNafInputSchema: z.ZodType<Prisma.UserUpdateWithoutNafInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutNafInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutNafInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateManyWithoutNafInputSchema: z.ZodType<Prisma.UserUncheckedUpdateManyWithoutNafInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const CampaignCreateManyListInputSchema: z.ZodType<Prisma.CampaignCreateManyListInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => CampaignTypeSchema).optional(),
      smart: z.boolean().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      active: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      emailId: z.string()
    })
    .strict();

export const UserUpdateWithoutListsManageInputSchema: z.ZodType<Prisma.UserUpdateWithoutListsManageInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutListsManageInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutListsManageInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateManyWithoutListsManageInputSchema: z.ZodType<Prisma.UserUncheckedUpdateManyWithoutListsManageInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const UserUpdateWithoutListsInputSchema: z.ZodType<Prisma.UserUpdateWithoutListsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutAffiliatesNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutListsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutListsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateManyWithoutListsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateManyWithoutListsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const CampaignUpdateWithoutListInputSchema: z.ZodType<Prisma.CampaignUpdateWithoutListInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => CampaignTypeSchema),
          z.lazy(() => EnumCampaignTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      smart: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      email: z
        .lazy(() => EmailUpdateOneRequiredWithoutCampaignsNestedInputSchema)
        .optional(),
      outboxes: z
        .lazy(() => OutboxUpdateManyWithoutCampaignNestedInputSchema)
        .optional()
    })
    .strict();

export const CampaignUncheckedUpdateWithoutListInputSchema: z.ZodType<Prisma.CampaignUncheckedUpdateWithoutListInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => CampaignTypeSchema),
          z.lazy(() => EnumCampaignTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      smart: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      outboxes: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutCampaignNestedInputSchema)
        .optional()
    })
    .strict();

export const CampaignUncheckedUpdateManyWithoutListInputSchema: z.ZodType<Prisma.CampaignUncheckedUpdateManyWithoutListInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => CampaignTypeSchema),
          z.lazy(() => EnumCampaignTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      smart: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const OutboxCreateManyCampaignInputSchema: z.ZodType<Prisma.OutboxCreateManyCampaignInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.string(),
      subject: z.string(),
      body: z.string(),
      status: z.string().optional(),
      metadata: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional()
    })
    .strict();

export const OutboxUpdateWithoutCampaignInputSchema: z.ZodType<Prisma.OutboxUpdateWithoutCampaignInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      subject: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      body: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      user: z.lazy(() => UserUpdateOneWithoutOutboxNestedInputSchema).optional()
    })
    .strict();

export const OutboxUncheckedUpdateWithoutCampaignInputSchema: z.ZodType<Prisma.OutboxUncheckedUpdateWithoutCampaignInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      subject: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      body: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const OutboxUncheckedUpdateManyWithoutCampaignInputSchema: z.ZodType<Prisma.OutboxUncheckedUpdateManyWithoutCampaignInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      subject: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      body: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const CampaignCreateManyEmailInputSchema: z.ZodType<Prisma.CampaignCreateManyEmailInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => CampaignTypeSchema).optional(),
      smart: z.boolean().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      active: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      listId: z.string().optional().nullable()
    })
    .strict();

export const CampaignUpdateWithoutEmailInputSchema: z.ZodType<Prisma.CampaignUpdateWithoutEmailInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => CampaignTypeSchema),
          z.lazy(() => EnumCampaignTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      smart: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      list: z
        .lazy(() => ListUpdateOneWithoutCampaignsNestedInputSchema)
        .optional(),
      outboxes: z
        .lazy(() => OutboxUpdateManyWithoutCampaignNestedInputSchema)
        .optional()
    })
    .strict();

export const CampaignUncheckedUpdateWithoutEmailInputSchema: z.ZodType<Prisma.CampaignUncheckedUpdateWithoutEmailInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => CampaignTypeSchema),
          z.lazy(() => EnumCampaignTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      smart: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      listId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      outboxes: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutCampaignNestedInputSchema)
        .optional()
    })
    .strict();

export const CampaignUncheckedUpdateManyWithoutEmailInputSchema: z.ZodType<Prisma.CampaignUncheckedUpdateManyWithoutEmailInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => CampaignTypeSchema),
          z.lazy(() => EnumCampaignTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      smart: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      listId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ClickCreateManyLinkInputSchema: z.ZodType<Prisma.ClickCreateManyLinkInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      part: z.string().optional().nullable(),
      path: z.string().optional().nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      blockId: z.string().optional().nullable(),
      siteId: z.string().optional().nullable(),
      userId: z.string().optional().nullable(),
      refererId: z.string().optional().nullable()
    })
    .strict();

export const ClickUpdateWithoutLinkInputSchema: z.ZodType<Prisma.ClickUpdateWithoutLinkInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      part: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      path: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      block: z
        .lazy(() => BlockUpdateOneWithoutClicksNestedInputSchema)
        .optional(),
      site: z
        .lazy(() => SiteUpdateOneWithoutClicksNestedInputSchema)
        .optional(),
      user: z
        .lazy(() => UserUpdateOneWithoutClicksNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutReferralsNestedInputSchema)
        .optional()
    })
    .strict();

export const ClickUncheckedUpdateWithoutLinkInputSchema: z.ZodType<Prisma.ClickUncheckedUpdateWithoutLinkInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      part: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      path: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ClickUncheckedUpdateManyWithoutLinkInputSchema: z.ZodType<Prisma.ClickUncheckedUpdateManyWithoutLinkInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      part: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      path: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ClickCreateManyBlockInputSchema: z.ZodType<Prisma.ClickCreateManyBlockInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      part: z.string().optional().nullable(),
      path: z.string().optional().nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      siteId: z.string().optional().nullable(),
      linkId: z.string().optional().nullable(),
      userId: z.string().optional().nullable(),
      refererId: z.string().optional().nullable()
    })
    .strict();

export const ReservationCreateManyBlockInputSchema: z.ZodType<Prisma.ReservationCreateManyBlockInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string().optional().nullable(),
      name: z.string().optional().nullable(),
      email: z.string(),
      dateStart: z.coerce.date(),
      dateEnd: z.coerce.date().optional().nullable(),
      comment: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      affiliateId: z.string().optional().nullable()
    })
    .strict();

export const CategoryCreateManyBlockInputSchema: z.ZodType<Prisma.CategoryCreateManyBlockInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      active: z.boolean().optional(),
      position: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      categoryId: z.string().optional().nullable()
    })
    .strict();

export const InventoryCreateManyBlockInputSchema: z.ZodType<Prisma.InventoryCreateManyBlockInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      sku: z.string().optional().nullable(),
      basePrice: z.number(),
      active: z.boolean().optional(),
      isFeatured: z.boolean().optional(),
      metaTitle: z.string().optional().nullable(),
      metaDescription: z.string().optional().nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryCreatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      categoryId: z.string().optional().nullable()
    })
    .strict();

export const ClickUpdateWithoutBlockInputSchema: z.ZodType<Prisma.ClickUpdateWithoutBlockInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      part: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      path: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      site: z
        .lazy(() => SiteUpdateOneWithoutClicksNestedInputSchema)
        .optional(),
      link: z
        .lazy(() => LinkUpdateOneWithoutClicksNestedInputSchema)
        .optional(),
      user: z
        .lazy(() => UserUpdateOneWithoutClicksNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutReferralsNestedInputSchema)
        .optional()
    })
    .strict();

export const ClickUncheckedUpdateWithoutBlockInputSchema: z.ZodType<Prisma.ClickUncheckedUpdateWithoutBlockInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      part: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      path: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      linkId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ClickUncheckedUpdateManyWithoutBlockInputSchema: z.ZodType<Prisma.ClickUncheckedUpdateManyWithoutBlockInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      part: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      path: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      linkId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ReservationUpdateWithoutBlockInputSchema: z.ZodType<Prisma.ReservationUpdateWithoutBlockInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      dateStart: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      dateEnd: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      comment: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliate: z
        .lazy(() => UserUpdateOneWithoutReservationsNestedInputSchema)
        .optional()
    })
    .strict();

export const ReservationUncheckedUpdateWithoutBlockInputSchema: z.ZodType<Prisma.ReservationUncheckedUpdateWithoutBlockInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      dateStart: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      dateEnd: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      comment: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ReservationUncheckedUpdateManyWithoutBlockInputSchema: z.ZodType<Prisma.ReservationUncheckedUpdateManyWithoutBlockInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      dateStart: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      dateEnd: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      comment: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const CategoryUpdateWithoutBlockInputSchema: z.ZodType<Prisma.CategoryUpdateWithoutBlockInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      inventories: z
        .lazy(() => InventoryUpdateManyWithoutCategoryNestedInputSchema)
        .optional(),
      categories: z
        .lazy(() => CategoryUpdateManyWithoutCategoryNestedInputSchema)
        .optional(),
      category: z
        .lazy(() => CategoryUpdateOneWithoutCategoriesNestedInputSchema)
        .optional()
    })
    .strict();

export const CategoryUncheckedUpdateWithoutBlockInputSchema: z.ZodType<Prisma.CategoryUncheckedUpdateWithoutBlockInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      categoryId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      inventories: z
        .lazy(
          () => InventoryUncheckedUpdateManyWithoutCategoryNestedInputSchema
        )
        .optional(),
      categories: z
        .lazy(() => CategoryUncheckedUpdateManyWithoutCategoryNestedInputSchema)
        .optional()
    })
    .strict();

export const CategoryUncheckedUpdateManyWithoutBlockInputSchema: z.ZodType<Prisma.CategoryUncheckedUpdateManyWithoutBlockInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      categoryId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const InventoryUpdateWithoutBlockInputSchema: z.ZodType<Prisma.InventoryUpdateWithoutBlockInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      basePrice: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isFeatured: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metaTitle: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      metaDescription: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryUpdatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      category: z
        .lazy(() => CategoryUpdateOneWithoutInventoriesNestedInputSchema)
        .optional(),
      variants: z
        .lazy(() => InventoryVariantUpdateManyWithoutInventoryNestedInputSchema)
        .optional()
    })
    .strict();

export const InventoryUncheckedUpdateWithoutBlockInputSchema: z.ZodType<Prisma.InventoryUncheckedUpdateWithoutBlockInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      basePrice: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isFeatured: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metaTitle: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      metaDescription: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryUpdatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      categoryId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      variants: z
        .lazy(
          () =>
            InventoryVariantUncheckedUpdateManyWithoutInventoryNestedInputSchema
        )
        .optional()
    })
    .strict();

export const InventoryUncheckedUpdateManyWithoutBlockInputSchema: z.ZodType<Prisma.InventoryUncheckedUpdateManyWithoutBlockInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      basePrice: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isFeatured: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metaTitle: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      metaDescription: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryUpdatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      categoryId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const BlockCreateManySiteInputSchema: z.ZodType<Prisma.BlockCreateManySiteInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string(),
      position: z.number().int().optional(),
      label: z.string().optional().nullable(),
      href: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const ClickCreateManySiteInputSchema: z.ZodType<Prisma.ClickCreateManySiteInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      part: z.string().optional().nullable(),
      path: z.string().optional().nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      blockId: z.string().optional().nullable(),
      linkId: z.string().optional().nullable(),
      userId: z.string().optional().nullable(),
      refererId: z.string().optional().nullable()
    })
    .strict();

export const SubscriberCreateManySiteInputSchema: z.ZodType<Prisma.SubscriberCreateManySiteInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const LikeCreateManySiteInputSchema: z.ZodType<Prisma.LikeCreateManySiteInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      ip: z.string(),
      createdAt: z.coerce.date().optional(),
      userId: z.string().optional().nullable(),
      feedId: z.string().optional().nullable()
    })
    .strict();

export const FeedCreateManySiteInputSchema: z.ZodType<Prisma.FeedCreateManySiteInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => FeedTypeSchema).optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      userId: z.string()
    })
    .strict();

export const BlockUpdateWithoutSiteInputSchema: z.ZodType<Prisma.BlockUpdateWithoutSiteInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      label: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      href: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      categories: z
        .lazy(() => CategoryUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      inventories: z
        .lazy(() => InventoryUpdateManyWithoutBlockNestedInputSchema)
        .optional()
    })
    .strict();

export const BlockUncheckedUpdateWithoutSiteInputSchema: z.ZodType<Prisma.BlockUncheckedUpdateWithoutSiteInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      label: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      href: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUncheckedUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      categories: z
        .lazy(() => CategoryUncheckedUpdateManyWithoutBlockNestedInputSchema)
        .optional(),
      inventories: z
        .lazy(() => InventoryUncheckedUpdateManyWithoutBlockNestedInputSchema)
        .optional()
    })
    .strict();

export const BlockUncheckedUpdateManyWithoutSiteInputSchema: z.ZodType<Prisma.BlockUncheckedUpdateManyWithoutSiteInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      label: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      href: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      style: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      widget: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const ClickUpdateWithoutSiteInputSchema: z.ZodType<Prisma.ClickUpdateWithoutSiteInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      part: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      path: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      block: z
        .lazy(() => BlockUpdateOneWithoutClicksNestedInputSchema)
        .optional(),
      link: z
        .lazy(() => LinkUpdateOneWithoutClicksNestedInputSchema)
        .optional(),
      user: z
        .lazy(() => UserUpdateOneWithoutClicksNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutReferralsNestedInputSchema)
        .optional()
    })
    .strict();

export const ClickUncheckedUpdateWithoutSiteInputSchema: z.ZodType<Prisma.ClickUncheckedUpdateWithoutSiteInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      part: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      path: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      linkId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ClickUncheckedUpdateManyWithoutSiteInputSchema: z.ZodType<Prisma.ClickUncheckedUpdateManyWithoutSiteInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      part: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      path: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      linkId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const SubscriberUpdateWithoutSiteInputSchema: z.ZodType<Prisma.SubscriberUpdateWithoutSiteInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const SubscriberUncheckedUpdateWithoutSiteInputSchema: z.ZodType<Prisma.SubscriberUncheckedUpdateWithoutSiteInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const SubscriberUncheckedUpdateManyWithoutSiteInputSchema: z.ZodType<Prisma.SubscriberUncheckedUpdateManyWithoutSiteInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const LikeUpdateWithoutSiteInputSchema: z.ZodType<Prisma.LikeUpdateWithoutSiteInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ip: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      user: z.lazy(() => UserUpdateOneWithoutLikesNestedInputSchema).optional(),
      feed: z.lazy(() => FeedUpdateOneWithoutLikesNestedInputSchema).optional()
    })
    .strict();

export const LikeUncheckedUpdateWithoutSiteInputSchema: z.ZodType<Prisma.LikeUncheckedUpdateWithoutSiteInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ip: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      feedId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const LikeUncheckedUpdateManyWithoutSiteInputSchema: z.ZodType<Prisma.LikeUncheckedUpdateManyWithoutSiteInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ip: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      feedId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const FeedUpdateWithoutSiteInputSchema: z.ZodType<Prisma.FeedUpdateWithoutSiteInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => FeedTypeSchema),
          z.lazy(() => EnumFeedTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutFeedNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutFeedNestedInputSchema)
        .optional(),
      likes: z.lazy(() => LikeUpdateManyWithoutFeedNestedInputSchema).optional()
    })
    .strict();

export const FeedUncheckedUpdateWithoutSiteInputSchema: z.ZodType<Prisma.FeedUncheckedUpdateWithoutSiteInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => FeedTypeSchema),
          z.lazy(() => EnumFeedTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutFeedNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutFeedNestedInputSchema)
        .optional()
    })
    .strict();

export const FeedUncheckedUpdateManyWithoutSiteInputSchema: z.ZodType<Prisma.FeedUncheckedUpdateManyWithoutSiteInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => FeedTypeSchema),
          z.lazy(() => EnumFeedTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const InventoryCreateManyCategoryInputSchema: z.ZodType<Prisma.InventoryCreateManyCategoryInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      sku: z.string().optional().nullable(),
      basePrice: z.number(),
      active: z.boolean().optional(),
      isFeatured: z.boolean().optional(),
      metaTitle: z.string().optional().nullable(),
      metaDescription: z.string().optional().nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryCreatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      blockId: z.string()
    })
    .strict();

export const CategoryCreateManyCategoryInputSchema: z.ZodType<Prisma.CategoryCreateManyCategoryInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      slug: z.string(),
      active: z.boolean().optional(),
      position: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      blockId: z.string()
    })
    .strict();

export const InventoryUpdateWithoutCategoryInputSchema: z.ZodType<Prisma.InventoryUpdateWithoutCategoryInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      basePrice: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isFeatured: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metaTitle: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      metaDescription: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryUpdatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      variants: z
        .lazy(() => InventoryVariantUpdateManyWithoutInventoryNestedInputSchema)
        .optional(),
      block: z
        .lazy(() => BlockUpdateOneRequiredWithoutInventoriesNestedInputSchema)
        .optional()
    })
    .strict();

export const InventoryUncheckedUpdateWithoutCategoryInputSchema: z.ZodType<Prisma.InventoryUncheckedUpdateWithoutCategoryInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      basePrice: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isFeatured: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metaTitle: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      metaDescription: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryUpdatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      variants: z
        .lazy(
          () =>
            InventoryVariantUncheckedUpdateManyWithoutInventoryNestedInputSchema
        )
        .optional()
    })
    .strict();

export const InventoryUncheckedUpdateManyWithoutCategoryInputSchema: z.ZodType<Prisma.InventoryUncheckedUpdateManyWithoutCategoryInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sku: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      basePrice: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isFeatured: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metaTitle: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      metaDescription: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      tags: z
        .union([
          z.lazy(() => InventoryUpdatetagsInputSchema),
          z.string().array()
        ])
        .optional(),
      stock: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const CategoryUpdateWithoutCategoryInputSchema: z.ZodType<Prisma.CategoryUpdateWithoutCategoryInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      inventories: z
        .lazy(() => InventoryUpdateManyWithoutCategoryNestedInputSchema)
        .optional(),
      categories: z
        .lazy(() => CategoryUpdateManyWithoutCategoryNestedInputSchema)
        .optional(),
      block: z
        .lazy(() => BlockUpdateOneRequiredWithoutCategoriesNestedInputSchema)
        .optional()
    })
    .strict();

export const CategoryUncheckedUpdateWithoutCategoryInputSchema: z.ZodType<Prisma.CategoryUncheckedUpdateWithoutCategoryInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      inventories: z
        .lazy(
          () => InventoryUncheckedUpdateManyWithoutCategoryNestedInputSchema
        )
        .optional(),
      categories: z
        .lazy(() => CategoryUncheckedUpdateManyWithoutCategoryNestedInputSchema)
        .optional()
    })
    .strict();

export const CategoryUncheckedUpdateManyWithoutCategoryInputSchema: z.ZodType<Prisma.CategoryUncheckedUpdateManyWithoutCategoryInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      slug: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const InventoryVariantCreateManyInventoryInputSchema: z.ZodType<Prisma.InventoryVariantCreateManyInventoryInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      value: z.string(),
      type: z.lazy(() => VariantTypeSchema),
      price: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema
        ])
        .refine(v => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional()
        .nullable(),
      stock: z.number().int().optional(),
      active: z.boolean().optional(),
      position: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const InventoryVariantUpdateWithoutInventoryInputSchema: z.ZodType<Prisma.InventoryVariantUpdateWithoutInventoryInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      value: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => VariantTypeSchema),
          z.lazy(() => EnumVariantTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema
            ])
            .refine(v => isValidDecimalInput(v), {
              message: 'Must be a Decimal'
            }),
          z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      stock: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const InventoryVariantUncheckedUpdateWithoutInventoryInputSchema: z.ZodType<Prisma.InventoryVariantUncheckedUpdateWithoutInventoryInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      value: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => VariantTypeSchema),
          z.lazy(() => EnumVariantTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema
            ])
            .refine(v => isValidDecimalInput(v), {
              message: 'Must be a Decimal'
            }),
          z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      stock: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const InventoryVariantUncheckedUpdateManyWithoutInventoryInputSchema: z.ZodType<Prisma.InventoryVariantUncheckedUpdateManyWithoutInventoryInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      value: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => VariantTypeSchema),
          z.lazy(() => EnumVariantTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      price: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema
            ])
            .refine(v => isValidDecimalInput(v), {
              message: 'Must be a Decimal'
            }),
          z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      stock: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      active: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      position: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const HistoryCreateManyCronInputSchema: z.ZodType<Prisma.HistoryCreateManyCronInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.string(),
      startedAt: z.coerce.date(),
      endedAt: z.coerce.date(),
      durationMs: z.number().int(),
      message: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional()
    })
    .strict();

export const HistoryUpdateWithoutCronInputSchema: z.ZodType<Prisma.HistoryUpdateWithoutCronInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      startedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      endedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      durationMs: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      message: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const HistoryUncheckedUpdateWithoutCronInputSchema: z.ZodType<Prisma.HistoryUncheckedUpdateWithoutCronInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      startedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      endedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      durationMs: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      message: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const HistoryUncheckedUpdateManyWithoutCronInputSchema: z.ZodType<Prisma.HistoryUncheckedUpdateManyWithoutCronInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      startedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      endedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      durationMs: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      message: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const AccountCreateManyUserInputSchema: z.ZodType<Prisma.AccountCreateManyUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      providerId: z.string().optional().nullable(),
      providerAccountId: z.string(),
      password: z.string().optional().nullable(),
      refresh_token: z.string().optional().nullable(),
      access_token: z.string().optional().nullable(),
      expires_at: z.number().int().optional().nullable(),
      scope: z.string().optional().nullable(),
      id_token: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const SessionCreateManyUserInputSchema: z.ZodType<Prisma.SessionCreateManyUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      sessionToken: z.string(),
      expires: z.coerce.date(),
      ipAddress: z.string().optional().nullable(),
      userAgent: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const SiteCreateManyUserInputSchema: z.ZodType<Prisma.SiteCreateManyUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      display_name: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      font: z.string().optional(),
      image: z.string().optional().nullable(),
      imageBlurhash: z.string().optional().nullable(),
      subdomain: z.string().optional().nullable(),
      customDomain: z.string().optional().nullable(),
      message404: z.string().optional().nullable(),
      background: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const SubscriptionCreateManyUserInputSchema: z.ZodType<Prisma.SubscriptionCreateManyUserInput> =
  z
    .object({
      id: z.string(),
      status: z.lazy(() => SubscriptionStatusSchema),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      quantity: z.number().int(),
      cancel_at_period_end: z.boolean(),
      created: z.coerce.date().optional(),
      current_period_start: z.coerce.date().optional(),
      current_period_end: z.coerce.date().optional(),
      ended_at: z.coerce.date().optional().nullable(),
      cancel_at: z.coerce.date().optional().nullable(),
      canceled_at: z.coerce.date().optional().nullable(),
      trial_start: z.coerce.date().optional().nullable(),
      trial_end: z.coerce.date().optional().nullable(),
      priceId: z.string()
    })
    .strict();

export const AuthenticatorCreateManyUserInputSchema: z.ZodType<Prisma.AuthenticatorCreateManyUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      credentialID: z.string(),
      providerAccountId: z.string(),
      credentialPublicKey: z.string(),
      counter: z.number().int(),
      credentialDeviceType: z.string(),
      credentialBackedUp: z.boolean(),
      transports: z.string().optional().nullable()
    })
    .strict();

export const LinkCreateManyUserInputSchema: z.ZodType<Prisma.LinkCreateManyUserInput> =
  z
    .object({
      id: z.string(),
      url: z.string(),
      name: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const FeedbackCreateManyUserInputSchema: z.ZodType<Prisma.FeedbackCreateManyUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      message: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const LikeCreateManyUserInputSchema: z.ZodType<Prisma.LikeCreateManyUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      ip: z.string(),
      createdAt: z.coerce.date().optional(),
      siteId: z.string(),
      feedId: z.string().optional().nullable()
    })
    .strict();

export const UserCreateManyRefererInputSchema: z.ZodType<Prisma.UserCreateManyRefererInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string(),
      emailVerified: z.boolean().optional(),
      image: z.string().optional().nullable(),
      isTwoFactorEnabled: z.boolean().optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z.string().optional().nullable(),
      address: z.string().optional().nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      activity: z.string().optional().nullable(),
      bounced: z.number().int().optional(),
      affiliateRate: z.number().optional().nullable(),
      isAnonymous: z.boolean().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      role: z.lazy(() => UserRoleSchema).optional(),
      codeNaf: z.string().optional().nullable()
    })
    .strict();

export const EventCreateManyUserInputSchema: z.ZodType<Prisma.EventCreateManyUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      eventType: z.string(),
      payload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      status: z.string().optional(),
      attempts: z.number().int().optional(),
      lastError: z.string().optional().nullable()
    })
    .strict();

export const WorkflowStateCreateManyUserInputSchema: z.ZodType<Prisma.WorkflowStateCreateManyUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      workflowId: z.string(),
      status: z.lazy(() => WorkflowStateStatusSchema).optional(),
      startedAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const ExecutionCreateManyUserInputSchema: z.ZodType<Prisma.ExecutionCreateManyUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      actionId: z.string(),
      ruleId: z.string().optional().nullable(),
      executedAt: z.coerce.date().optional().nullable(),
      status: z.lazy(() => ExecutionStatusSchema).optional(),
      errorMessage: z.string().optional().nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z.string().optional().nullable()
    })
    .strict();

export const QueueCreateManyUserInputSchema: z.ZodType<Prisma.QueueCreateManyUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      job: z.string().optional(),
      payload: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      status: z.string().optional(),
      attempts: z.number().int().optional(),
      lastError: z.string().optional().nullable(),
      runAt: z.coerce.date().optional(),
      priority: z.number().int().optional(),
      processingStartedAt: z.coerce.date().optional().nullable(),
      correlationId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const OutboxCreateManyUserInputSchema: z.ZodType<Prisma.OutboxCreateManyUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      subject: z.string(),
      body: z.string(),
      status: z.string().optional(),
      metadata: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      campaignId: z.string().optional().nullable()
    })
    .strict();

export const FeedCreateManyUserInputSchema: z.ZodType<Prisma.FeedCreateManyUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.lazy(() => FeedTypeSchema).optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      siteId: z.string()
    })
    .strict();

export const CommentCreateManyUserInputSchema: z.ZodType<Prisma.CommentCreateManyUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      content: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      feedId: z.string().optional().nullable()
    })
    .strict();

export const MessageCreateManySenderInputSchema: z.ZodType<Prisma.MessageCreateManySenderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      content: z.string(),
      createdAt: z.coerce.date().optional(),
      receiveEmail: z.string()
    })
    .strict();

export const MessageCreateManyReceiverInputSchema: z.ZodType<Prisma.MessageCreateManyReceiverInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      content: z.string(),
      createdAt: z.coerce.date().optional(),
      senderEmail: z.string()
    })
    .strict();

export const ReservationCreateManyAffiliateInputSchema: z.ZodType<Prisma.ReservationCreateManyAffiliateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string().optional().nullable(),
      name: z.string().optional().nullable(),
      email: z.string(),
      dateStart: z.coerce.date(),
      dateEnd: z.coerce.date().optional().nullable(),
      comment: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      blockId: z.string().optional().nullable()
    })
    .strict();

export const EmailCreateManyUserInputSchema: z.ZodType<Prisma.EmailCreateManyUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      title: z.string(),
      description: z.string().optional().nullable(),
      subject: z.string(),
      content: z.string(),
      design: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const ClickCreateManyUserInputSchema: z.ZodType<Prisma.ClickCreateManyUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      part: z.string().optional().nullable(),
      path: z.string().optional().nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      blockId: z.string().optional().nullable(),
      siteId: z.string().optional().nullable(),
      linkId: z.string().optional().nullable(),
      refererId: z.string().optional().nullable()
    })
    .strict();

export const ClickCreateManyRefererInputSchema: z.ZodType<Prisma.ClickCreateManyRefererInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      part: z.string().optional().nullable(),
      path: z.string().optional().nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z.coerce.date().optional(),
      blockId: z.string().optional().nullable(),
      siteId: z.string().optional().nullable(),
      linkId: z.string().optional().nullable(),
      userId: z.string().optional().nullable()
    })
    .strict();

export const AccountUpdateWithoutUserInputSchema: z.ZodType<Prisma.AccountUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      providerId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      providerAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      password: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      refresh_token: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      access_token: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      expires_at: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      scope: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      id_token: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const AccountUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.AccountUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      providerId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      providerAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      password: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      refresh_token: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      access_token: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      expires_at: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      scope: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      id_token: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const AccountUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.AccountUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      providerId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      providerAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      password: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      refresh_token: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      access_token: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      expires_at: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      scope: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      id_token: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const SessionUpdateWithoutUserInputSchema: z.ZodType<Prisma.SessionUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sessionToken: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      expires: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ipAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      userAgent: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const SessionUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.SessionUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sessionToken: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      expires: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ipAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      userAgent: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const SessionUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.SessionUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sessionToken: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      expires: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ipAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      userAgent: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const SiteUpdateWithoutUserInputSchema: z.ZodType<Prisma.SiteUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      display_name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      font: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      imageBlurhash: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subdomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      customDomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      message404: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      background: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blocks: z
        .lazy(() => BlockUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      subscribers: z
        .lazy(() => SubscriberUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutSiteNestedInputSchema).optional()
    })
    .strict();

export const SiteUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.SiteUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      display_name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      font: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      imageBlurhash: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subdomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      customDomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      message404: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      background: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blocks: z
        .lazy(() => BlockUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      subscribers: z
        .lazy(() => SubscriberUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutSiteNestedInputSchema)
        .optional()
    })
    .strict();

export const SiteUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.SiteUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      display_name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      logo: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      font: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      imageBlurhash: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subdomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      customDomain: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      message404: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      background: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const SubscriptionUpdateWithoutUserInputSchema: z.ZodType<Prisma.SubscriptionUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      cancel_at_period_end: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      created: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      current_period_start: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      current_period_end: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ended_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      cancel_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      canceled_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_start: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_end: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      price: z
        .lazy(() => PriceUpdateOneRequiredWithoutSubscriptionsNestedInputSchema)
        .optional()
    })
    .strict();

export const SubscriptionUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      cancel_at_period_end: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      created: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      current_period_start: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      current_period_end: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ended_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      cancel_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      canceled_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_start: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_end: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      priceId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const SubscriptionUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      quantity: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      cancel_at_period_end: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      created: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      current_period_start: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      current_period_end: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ended_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      cancel_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      canceled_at: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_start: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      trial_end: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      priceId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const AuthenticatorUpdateWithoutUserInputSchema: z.ZodType<Prisma.AuthenticatorUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      providerAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialPublicKey: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      counter: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialDeviceType: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialBackedUp: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      transports: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const AuthenticatorUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.AuthenticatorUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      providerAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialPublicKey: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      counter: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialDeviceType: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialBackedUp: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      transports: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const AuthenticatorUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.AuthenticatorUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialID: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      providerAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialPublicKey: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      counter: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialDeviceType: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      credentialBackedUp: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      transports: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const LinkUpdateWithoutUserInputSchema: z.ZodType<Prisma.LinkUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      url: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutLinkNestedInputSchema)
        .optional()
    })
    .strict();

export const LinkUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.LinkUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      url: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutLinkNestedInputSchema)
        .optional()
    })
    .strict();

export const LinkUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.LinkUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      url: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const FeedbackUpdateWithoutUserInputSchema: z.ZodType<Prisma.FeedbackUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      message: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const FeedbackUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.FeedbackUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      message: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const FeedbackUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.FeedbackUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      message: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const LikeUpdateWithoutUserInputSchema: z.ZodType<Prisma.LikeUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ip: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      site: z
        .lazy(() => SiteUpdateOneRequiredWithoutLikesNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateOneWithoutLikesNestedInputSchema).optional()
    })
    .strict();

export const LikeUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.LikeUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ip: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      feedId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const LikeUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.LikeUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ip: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      feedId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const UserUpdateWithoutRefererInputSchema: z.ZodType<Prisma.UserUpdateWithoutRefererInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(() => AuthenticatorUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      links: z
        .lazy(() => LinkUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(() => TwoFactorConfirmationUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      naf: z
        .lazy(() => NafCodeUpdateOneWithoutUsersNestedInputSchema)
        .optional(),
      feedback: z
        .lazy(() => FeedbackUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(() => WorkflowStateUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z.lazy(() => FeedUpdateManyWithoutUserNestedInputSchema).optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(() => ReservationUpdateManyWithoutAffiliateNestedInputSchema)
        .optional(),
      lists: z
        .lazy(() => ListUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateWithoutRefererInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutRefererInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sites: z
        .lazy(() => SiteUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      authenticator: z
        .lazy(
          () => AuthenticatorUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      links: z
        .lazy(() => LinkUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      customer: z
        .lazy(() => CustomerUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      twoFactorConfirmation: z
        .lazy(
          () =>
            TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInputSchema
        )
        .optional(),
      feedback: z
        .lazy(() => FeedbackUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      affiliates: z
        .lazy(() => UserUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional(),
      events: z
        .lazy(() => EventUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      workflowStates: z
        .lazy(
          () => WorkflowStateUncheckedUpdateManyWithoutUserNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      jobs: z
        .lazy(() => QueueUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      outbox: z
        .lazy(() => OutboxUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      feed: z
        .lazy(() => FeedUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      sent: z
        .lazy(() => MessageUncheckedUpdateManyWithoutSenderNestedInputSchema)
        .optional(),
      received: z
        .lazy(() => MessageUncheckedUpdateManyWithoutReceiverNestedInputSchema)
        .optional(),
      reservations: z
        .lazy(
          () => ReservationUncheckedUpdateManyWithoutAffiliateNestedInputSchema
        )
        .optional(),
      lists: z
        .lazy(() => ListUncheckedUpdateManyWithoutContactsNestedInputSchema)
        .optional(),
      listsManage: z
        .lazy(() => ListUncheckedUpdateManyWithoutOwnersNestedInputSchema)
        .optional(),
      emails: z
        .lazy(() => EmailUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      clicks: z
        .lazy(() => ClickUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      referrals: z
        .lazy(() => ClickUncheckedUpdateManyWithoutRefererNestedInputSchema)
        .optional()
    })
    .strict();

export const UserUncheckedUpdateManyWithoutRefererInputSchema: z.ZodType<Prisma.UserUncheckedUpdateManyWithoutRefererInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isTwoFactorEnabled: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      billing_address: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      payment_method: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      company: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      location: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      postcode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      phone: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      activity: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      bounced: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      affiliateRate: z
        .union([
          z.number(),
          z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      isAnonymous: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      codeNaf: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const EventUpdateWithoutUserInputSchema: z.ZodType<Prisma.EventUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      eventType: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      payload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      attempts: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      lastError: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const EventUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.EventUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      eventType: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      payload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      attempts: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      lastError: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const EventUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.EventUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      eventType: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      payload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      attempts: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      lastError: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const WorkflowStateUpdateWithoutUserInputSchema: z.ZodType<Prisma.WorkflowStateUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => WorkflowStateStatusSchema),
          z.lazy(() => EnumWorkflowStateStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      startedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      workflow: z
        .lazy(() => WorkflowUpdateOneRequiredWithoutStatesNestedInputSchema)
        .optional()
    })
    .strict();

export const WorkflowStateUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.WorkflowStateUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      workflowId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => WorkflowStateStatusSchema),
          z.lazy(() => EnumWorkflowStateStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      startedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const WorkflowStateUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.WorkflowStateUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      workflowId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => WorkflowStateStatusSchema),
          z.lazy(() => EnumWorkflowStateStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      startedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const ExecutionUpdateWithoutUserInputSchema: z.ZodType<Prisma.ExecutionUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      executedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ExecutionStatusSchema),
          z.lazy(() => EnumExecutionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      errorMessage: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      action: z
        .lazy(() => ActionUpdateOneRequiredWithoutExecutionsNestedInputSchema)
        .optional(),
      rule: z
        .lazy(() => RuleUpdateOneWithoutExecutionsNestedInputSchema)
        .optional()
    })
    .strict();

export const ExecutionUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.ExecutionUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      actionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ruleId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      executedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ExecutionStatusSchema),
          z.lazy(() => EnumExecutionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      errorMessage: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ExecutionUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.ExecutionUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      actionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ruleId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      executedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ExecutionStatusSchema),
          z.lazy(() => EnumExecutionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      errorMessage: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const QueueUpdateWithoutUserInputSchema: z.ZodType<Prisma.QueueUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      job: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      payload: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      attempts: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      lastError: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      runAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      priority: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      processingStartedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const QueueUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.QueueUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      job: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      payload: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      attempts: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      lastError: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      runAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      priority: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      processingStartedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const QueueUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.QueueUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      job: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      payload: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      attempts: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      lastError: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      runAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      priority: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      processingStartedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const OutboxUpdateWithoutUserInputSchema: z.ZodType<Prisma.OutboxUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      subject: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      body: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      campaign: z
        .lazy(() => CampaignUpdateOneWithoutOutboxesNestedInputSchema)
        .optional()
    })
    .strict();

export const OutboxUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.OutboxUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      subject: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      body: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      campaignId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const OutboxUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.OutboxUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      subject: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      body: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      metadata: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      campaignId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const FeedUpdateWithoutUserInputSchema: z.ZodType<Prisma.FeedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => FeedTypeSchema),
          z.lazy(() => EnumFeedTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      site: z
        .lazy(() => SiteUpdateOneRequiredWithoutFeedNestedInputSchema)
        .optional(),
      comments: z
        .lazy(() => CommentUpdateManyWithoutFeedNestedInputSchema)
        .optional(),
      likes: z.lazy(() => LikeUpdateManyWithoutFeedNestedInputSchema).optional()
    })
    .strict();

export const FeedUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.FeedUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => FeedTypeSchema),
          z.lazy(() => EnumFeedTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      comments: z
        .lazy(() => CommentUncheckedUpdateManyWithoutFeedNestedInputSchema)
        .optional(),
      likes: z
        .lazy(() => LikeUncheckedUpdateManyWithoutFeedNestedInputSchema)
        .optional()
    })
    .strict();

export const FeedUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.FeedUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => FeedTypeSchema),
          z.lazy(() => EnumFeedTypeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      commentable: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const CommentUpdateWithoutUserInputSchema: z.ZodType<Prisma.CommentUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      feed: z
        .lazy(() => FeedUpdateOneWithoutCommentsNestedInputSchema)
        .optional()
    })
    .strict();

export const CommentUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.CommentUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      feedId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const CommentUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.CommentUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      feedId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const MessageUpdateWithoutSenderInputSchema: z.ZodType<Prisma.MessageUpdateWithoutSenderInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      receiver: z
        .lazy(() => UserUpdateOneRequiredWithoutReceivedNestedInputSchema)
        .optional()
    })
    .strict();

export const MessageUncheckedUpdateWithoutSenderInputSchema: z.ZodType<Prisma.MessageUncheckedUpdateWithoutSenderInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      receiveEmail: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const MessageUncheckedUpdateManyWithoutSenderInputSchema: z.ZodType<Prisma.MessageUncheckedUpdateManyWithoutSenderInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      receiveEmail: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const MessageUpdateWithoutReceiverInputSchema: z.ZodType<Prisma.MessageUpdateWithoutReceiverInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      sender: z
        .lazy(() => UserUpdateOneRequiredWithoutSentNestedInputSchema)
        .optional()
    })
    .strict();

export const MessageUncheckedUpdateWithoutReceiverInputSchema: z.ZodType<Prisma.MessageUncheckedUpdateWithoutReceiverInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      senderEmail: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const MessageUncheckedUpdateManyWithoutReceiverInputSchema: z.ZodType<Prisma.MessageUncheckedUpdateManyWithoutReceiverInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      senderEmail: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const ReservationUpdateWithoutAffiliateInputSchema: z.ZodType<Prisma.ReservationUpdateWithoutAffiliateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      dateStart: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      dateEnd: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      comment: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      block: z
        .lazy(() => BlockUpdateOneWithoutReservationsNestedInputSchema)
        .optional()
    })
    .strict();

export const ReservationUncheckedUpdateWithoutAffiliateInputSchema: z.ZodType<Prisma.ReservationUncheckedUpdateWithoutAffiliateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      dateStart: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      dateEnd: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      comment: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ReservationUncheckedUpdateManyWithoutAffiliateInputSchema: z.ZodType<Prisma.ReservationUncheckedUpdateManyWithoutAffiliateInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      type: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      name: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      dateStart: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      dateEnd: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      comment: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ListUpdateWithoutContactsInputSchema: z.ZodType<Prisma.ListUpdateWithoutContactsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      owners: z
        .lazy(() => UserUpdateManyWithoutListsManageNestedInputSchema)
        .optional(),
      campaigns: z
        .lazy(() => CampaignUpdateManyWithoutListNestedInputSchema)
        .optional()
    })
    .strict();

export const ListUncheckedUpdateWithoutContactsInputSchema: z.ZodType<Prisma.ListUncheckedUpdateWithoutContactsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      owners: z
        .lazy(() => UserUncheckedUpdateManyWithoutListsManageNestedInputSchema)
        .optional(),
      campaigns: z
        .lazy(() => CampaignUncheckedUpdateManyWithoutListNestedInputSchema)
        .optional()
    })
    .strict();

export const ListUncheckedUpdateManyWithoutContactsInputSchema: z.ZodType<Prisma.ListUncheckedUpdateManyWithoutContactsInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const ListUpdateWithoutOwnersInputSchema: z.ZodType<Prisma.ListUpdateWithoutOwnersInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      contacts: z
        .lazy(() => UserUpdateManyWithoutListsNestedInputSchema)
        .optional(),
      campaigns: z
        .lazy(() => CampaignUpdateManyWithoutListNestedInputSchema)
        .optional()
    })
    .strict();

export const ListUncheckedUpdateWithoutOwnersInputSchema: z.ZodType<Prisma.ListUncheckedUpdateWithoutOwnersInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      contacts: z
        .lazy(() => UserUncheckedUpdateManyWithoutListsNestedInputSchema)
        .optional(),
      campaigns: z
        .lazy(() => CampaignUncheckedUpdateManyWithoutListNestedInputSchema)
        .optional()
    })
    .strict();

export const ListUncheckedUpdateManyWithoutOwnersInputSchema: z.ZodType<Prisma.ListUncheckedUpdateManyWithoutOwnersInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const EmailUpdateWithoutUserInputSchema: z.ZodType<Prisma.EmailUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subject: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      design: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      campaigns: z
        .lazy(() => CampaignUpdateManyWithoutEmailNestedInputSchema)
        .optional()
    })
    .strict();

export const EmailUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.EmailUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subject: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      design: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      campaigns: z
        .lazy(() => CampaignUncheckedUpdateManyWithoutEmailNestedInputSchema)
        .optional()
    })
    .strict();

export const EmailUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.EmailUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      subject: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      content: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      design: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const ClickUpdateWithoutUserInputSchema: z.ZodType<Prisma.ClickUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      part: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      path: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      block: z
        .lazy(() => BlockUpdateOneWithoutClicksNestedInputSchema)
        .optional(),
      site: z
        .lazy(() => SiteUpdateOneWithoutClicksNestedInputSchema)
        .optional(),
      link: z
        .lazy(() => LinkUpdateOneWithoutClicksNestedInputSchema)
        .optional(),
      referer: z
        .lazy(() => UserUpdateOneWithoutReferralsNestedInputSchema)
        .optional()
    })
    .strict();

export const ClickUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.ClickUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      part: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      path: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      linkId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ClickUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.ClickUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      part: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      path: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      linkId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      refererId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ClickUpdateWithoutRefererInputSchema: z.ZodType<Prisma.ClickUpdateWithoutRefererInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      part: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      path: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      block: z
        .lazy(() => BlockUpdateOneWithoutClicksNestedInputSchema)
        .optional(),
      site: z
        .lazy(() => SiteUpdateOneWithoutClicksNestedInputSchema)
        .optional(),
      link: z
        .lazy(() => LinkUpdateOneWithoutClicksNestedInputSchema)
        .optional(),
      user: z.lazy(() => UserUpdateOneWithoutClicksNestedInputSchema).optional()
    })
    .strict();

export const ClickUncheckedUpdateWithoutRefererInputSchema: z.ZodType<Prisma.ClickUncheckedUpdateWithoutRefererInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      part: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      path: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      linkId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ClickUncheckedUpdateManyWithoutRefererInputSchema: z.ZodType<Prisma.ClickUncheckedUpdateManyWithoutRefererInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      part: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      path: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      request: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      blockId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      siteId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      linkId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const RuleCreateManyActionInputSchema: z.ZodType<Prisma.RuleCreateManyActionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      workflowId: z.string(),
      triggerId: z.string(),
      delayMinutes: z.number().int().optional(),
      order: z.number().int().optional(),
      isActive: z.boolean().optional(),
      version: z.number().int().optional()
    })
    .strict();

export const ExecutionCreateManyActionInputSchema: z.ZodType<Prisma.ExecutionCreateManyActionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      userId: z.string(),
      ruleId: z.string().optional().nullable(),
      executedAt: z.coerce.date().optional().nullable(),
      status: z.lazy(() => ExecutionStatusSchema).optional(),
      errorMessage: z.string().optional().nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z.string().optional().nullable()
    })
    .strict();

export const RuleUpdateWithoutActionInputSchema: z.ZodType<Prisma.RuleUpdateWithoutActionInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      delayMinutes: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      order: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ruleConditions: z
        .lazy(() => RuleConditionUpdateManyWithoutRuleNestedInputSchema)
        .optional(),
      workflow: z
        .lazy(() => WorkflowUpdateOneRequiredWithoutRulesNestedInputSchema)
        .optional(),
      trigger: z
        .lazy(() => TriggerUpdateOneRequiredWithoutRulesNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutRuleNestedInputSchema)
        .optional()
    })
    .strict();

export const RuleUncheckedUpdateWithoutActionInputSchema: z.ZodType<Prisma.RuleUncheckedUpdateWithoutActionInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      workflowId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      triggerId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      delayMinutes: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      order: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ruleConditions: z
        .lazy(
          () => RuleConditionUncheckedUpdateManyWithoutRuleNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutRuleNestedInputSchema)
        .optional()
    })
    .strict();

export const RuleUncheckedUpdateManyWithoutActionInputSchema: z.ZodType<Prisma.RuleUncheckedUpdateManyWithoutActionInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      workflowId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      triggerId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      delayMinutes: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      order: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const ExecutionUpdateWithoutActionInputSchema: z.ZodType<Prisma.ExecutionUpdateWithoutActionInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      executedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ExecutionStatusSchema),
          z.lazy(() => EnumExecutionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      errorMessage: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutExecutionsNestedInputSchema)
        .optional(),
      rule: z
        .lazy(() => RuleUpdateOneWithoutExecutionsNestedInputSchema)
        .optional()
    })
    .strict();

export const ExecutionUncheckedUpdateWithoutActionInputSchema: z.ZodType<Prisma.ExecutionUncheckedUpdateWithoutActionInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ruleId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      executedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ExecutionStatusSchema),
          z.lazy(() => EnumExecutionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      errorMessage: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ExecutionUncheckedUpdateManyWithoutActionInputSchema: z.ZodType<Prisma.ExecutionUncheckedUpdateManyWithoutActionInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ruleId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      executedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ExecutionStatusSchema),
          z.lazy(() => EnumExecutionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      errorMessage: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const RuleCreateManyWorkflowInputSchema: z.ZodType<Prisma.RuleCreateManyWorkflowInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      actionId: z.string(),
      triggerId: z.string(),
      delayMinutes: z.number().int().optional(),
      order: z.number().int().optional(),
      isActive: z.boolean().optional(),
      version: z.number().int().optional()
    })
    .strict();

export const WorkflowStateCreateManyWorkflowInputSchema: z.ZodType<Prisma.WorkflowStateCreateManyWorkflowInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      userId: z.string(),
      status: z.lazy(() => WorkflowStateStatusSchema).optional(),
      startedAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional()
    })
    .strict();

export const RuleUpdateWithoutWorkflowInputSchema: z.ZodType<Prisma.RuleUpdateWithoutWorkflowInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      delayMinutes: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      order: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ruleConditions: z
        .lazy(() => RuleConditionUpdateManyWithoutRuleNestedInputSchema)
        .optional(),
      action: z
        .lazy(() => ActionUpdateOneRequiredWithoutRulesNestedInputSchema)
        .optional(),
      trigger: z
        .lazy(() => TriggerUpdateOneRequiredWithoutRulesNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutRuleNestedInputSchema)
        .optional()
    })
    .strict();

export const RuleUncheckedUpdateWithoutWorkflowInputSchema: z.ZodType<Prisma.RuleUncheckedUpdateWithoutWorkflowInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      actionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      triggerId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      delayMinutes: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      order: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ruleConditions: z
        .lazy(
          () => RuleConditionUncheckedUpdateManyWithoutRuleNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutRuleNestedInputSchema)
        .optional()
    })
    .strict();

export const RuleUncheckedUpdateManyWithoutWorkflowInputSchema: z.ZodType<Prisma.RuleUncheckedUpdateManyWithoutWorkflowInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      actionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      triggerId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      delayMinutes: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      order: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const WorkflowStateUpdateWithoutWorkflowInputSchema: z.ZodType<Prisma.WorkflowStateUpdateWithoutWorkflowInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => WorkflowStateStatusSchema),
          z.lazy(() => EnumWorkflowStateStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      startedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutWorkflowStatesNestedInputSchema)
        .optional()
    })
    .strict();

export const WorkflowStateUncheckedUpdateWithoutWorkflowInputSchema: z.ZodType<Prisma.WorkflowStateUncheckedUpdateWithoutWorkflowInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => WorkflowStateStatusSchema),
          z.lazy(() => EnumWorkflowStateStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      startedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const WorkflowStateUncheckedUpdateManyWithoutWorkflowInputSchema: z.ZodType<Prisma.WorkflowStateUncheckedUpdateManyWithoutWorkflowInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => WorkflowStateStatusSchema),
          z.lazy(() => EnumWorkflowStateStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      startedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const RuleCreateManyTriggerInputSchema: z.ZodType<Prisma.RuleCreateManyTriggerInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      workflowId: z.string(),
      actionId: z.string(),
      delayMinutes: z.number().int().optional(),
      order: z.number().int().optional(),
      isActive: z.boolean().optional(),
      version: z.number().int().optional()
    })
    .strict();

export const RuleUpdateWithoutTriggerInputSchema: z.ZodType<Prisma.RuleUpdateWithoutTriggerInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      delayMinutes: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      order: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ruleConditions: z
        .lazy(() => RuleConditionUpdateManyWithoutRuleNestedInputSchema)
        .optional(),
      workflow: z
        .lazy(() => WorkflowUpdateOneRequiredWithoutRulesNestedInputSchema)
        .optional(),
      action: z
        .lazy(() => ActionUpdateOneRequiredWithoutRulesNestedInputSchema)
        .optional(),
      executions: z
        .lazy(() => ExecutionUpdateManyWithoutRuleNestedInputSchema)
        .optional()
    })
    .strict();

export const RuleUncheckedUpdateWithoutTriggerInputSchema: z.ZodType<Prisma.RuleUncheckedUpdateWithoutTriggerInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      workflowId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      actionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      delayMinutes: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      order: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      ruleConditions: z
        .lazy(
          () => RuleConditionUncheckedUpdateManyWithoutRuleNestedInputSchema
        )
        .optional(),
      executions: z
        .lazy(() => ExecutionUncheckedUpdateManyWithoutRuleNestedInputSchema)
        .optional()
    })
    .strict();

export const RuleUncheckedUpdateManyWithoutTriggerInputSchema: z.ZodType<Prisma.RuleUncheckedUpdateManyWithoutTriggerInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      workflowId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      actionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      delayMinutes: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      order: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      isActive: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      version: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const RuleConditionCreateManyRuleInputSchema: z.ZodType<Prisma.RuleConditionCreateManyRuleInput> =
  z
    .object({
      conditionId: z.string(),
      group: z.number().int().optional(),
      logic: z.lazy(() => OperatorSchema).optional()
    })
    .strict();

export const ExecutionCreateManyRuleInputSchema: z.ZodType<Prisma.ExecutionCreateManyRuleInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      userId: z.string(),
      actionId: z.string(),
      executedAt: z.coerce.date().optional().nullable(),
      status: z.lazy(() => ExecutionStatusSchema).optional(),
      errorMessage: z.string().optional().nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z.string().optional().nullable()
    })
    .strict();

export const RuleConditionUpdateWithoutRuleInputSchema: z.ZodType<Prisma.RuleConditionUpdateWithoutRuleInput> =
  z
    .object({
      group: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      logic: z
        .union([
          z.lazy(() => OperatorSchema),
          z.lazy(() => EnumOperatorFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      condition: z
        .lazy(() => ConditionUpdateOneRequiredWithoutRulesNestedInputSchema)
        .optional()
    })
    .strict();

export const RuleConditionUncheckedUpdateWithoutRuleInputSchema: z.ZodType<Prisma.RuleConditionUncheckedUpdateWithoutRuleInput> =
  z
    .object({
      conditionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      group: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      logic: z
        .union([
          z.lazy(() => OperatorSchema),
          z.lazy(() => EnumOperatorFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const RuleConditionUncheckedUpdateManyWithoutRuleInputSchema: z.ZodType<Prisma.RuleConditionUncheckedUpdateManyWithoutRuleInput> =
  z
    .object({
      conditionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      group: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      logic: z
        .union([
          z.lazy(() => OperatorSchema),
          z.lazy(() => EnumOperatorFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const ExecutionUpdateWithoutRuleInputSchema: z.ZodType<Prisma.ExecutionUpdateWithoutRuleInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      executedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ExecutionStatusSchema),
          z.lazy(() => EnumExecutionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      errorMessage: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutExecutionsNestedInputSchema)
        .optional(),
      action: z
        .lazy(() => ActionUpdateOneRequiredWithoutExecutionsNestedInputSchema)
        .optional()
    })
    .strict();

export const ExecutionUncheckedUpdateWithoutRuleInputSchema: z.ZodType<Prisma.ExecutionUncheckedUpdateWithoutRuleInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      actionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      executedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ExecutionStatusSchema),
          z.lazy(() => EnumExecutionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      errorMessage: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const ExecutionUncheckedUpdateManyWithoutRuleInputSchema: z.ZodType<Prisma.ExecutionUncheckedUpdateManyWithoutRuleInput> =
  z
    .object({
      id: z
        .union([
          z.string().cuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      actionId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      executedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ExecutionStatusSchema),
          z.lazy(() => EnumExecutionStatusFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      errorMessage: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable(),
      resultPayload: z
        .union([
          z.lazy(() => NullableJsonNullValueInputSchema),
          InputJsonValueSchema
        ])
        .optional(),
      correlationId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)
        ])
        .optional()
        .nullable()
    })
    .strict();

export const RuleConditionCreateManyConditionInputSchema: z.ZodType<Prisma.RuleConditionCreateManyConditionInput> =
  z
    .object({
      ruleId: z.string(),
      group: z.number().int().optional(),
      logic: z.lazy(() => OperatorSchema).optional()
    })
    .strict();

export const RuleConditionUpdateWithoutConditionInputSchema: z.ZodType<Prisma.RuleConditionUpdateWithoutConditionInput> =
  z
    .object({
      group: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      logic: z
        .union([
          z.lazy(() => OperatorSchema),
          z.lazy(() => EnumOperatorFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      rule: z
        .lazy(() => RuleUpdateOneRequiredWithoutRuleConditionsNestedInputSchema)
        .optional()
    })
    .strict();

export const RuleConditionUncheckedUpdateWithoutConditionInputSchema: z.ZodType<Prisma.RuleConditionUncheckedUpdateWithoutConditionInput> =
  z
    .object({
      ruleId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      group: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      logic: z
        .union([
          z.lazy(() => OperatorSchema),
          z.lazy(() => EnumOperatorFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

export const RuleConditionUncheckedUpdateManyWithoutConditionInputSchema: z.ZodType<Prisma.RuleConditionUncheckedUpdateManyWithoutConditionInput> =
  z
    .object({
      ruleId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      group: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema)
        ])
        .optional(),
      logic: z
        .union([
          z.lazy(() => OperatorSchema),
          z.lazy(() => EnumOperatorFieldUpdateOperationsInputSchema)
        ])
        .optional()
    })
    .strict();

/////////////////////////////////////////
// ARGS
/////////////////////////////////////////

export const TwoFactorConfirmationFindFirstArgsSchema: z.ZodType<Prisma.TwoFactorConfirmationFindFirstArgs> =
  z
    .object({
      select: TwoFactorConfirmationSelectSchema.optional(),
      include: TwoFactorConfirmationIncludeSchema.optional(),
      where: TwoFactorConfirmationWhereInputSchema.optional(),
      orderBy: z
        .union([
          TwoFactorConfirmationOrderByWithRelationInputSchema.array(),
          TwoFactorConfirmationOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: TwoFactorConfirmationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          TwoFactorConfirmationScalarFieldEnumSchema,
          TwoFactorConfirmationScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TwoFactorConfirmationFindFirstOrThrowArgsSchema: z.ZodType<Prisma.TwoFactorConfirmationFindFirstOrThrowArgs> =
  z
    .object({
      select: TwoFactorConfirmationSelectSchema.optional(),
      include: TwoFactorConfirmationIncludeSchema.optional(),
      where: TwoFactorConfirmationWhereInputSchema.optional(),
      orderBy: z
        .union([
          TwoFactorConfirmationOrderByWithRelationInputSchema.array(),
          TwoFactorConfirmationOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: TwoFactorConfirmationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          TwoFactorConfirmationScalarFieldEnumSchema,
          TwoFactorConfirmationScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TwoFactorConfirmationFindManyArgsSchema: z.ZodType<Prisma.TwoFactorConfirmationFindManyArgs> =
  z
    .object({
      select: TwoFactorConfirmationSelectSchema.optional(),
      include: TwoFactorConfirmationIncludeSchema.optional(),
      where: TwoFactorConfirmationWhereInputSchema.optional(),
      orderBy: z
        .union([
          TwoFactorConfirmationOrderByWithRelationInputSchema.array(),
          TwoFactorConfirmationOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: TwoFactorConfirmationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          TwoFactorConfirmationScalarFieldEnumSchema,
          TwoFactorConfirmationScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TwoFactorConfirmationAggregateArgsSchema: z.ZodType<Prisma.TwoFactorConfirmationAggregateArgs> =
  z
    .object({
      where: TwoFactorConfirmationWhereInputSchema.optional(),
      orderBy: z
        .union([
          TwoFactorConfirmationOrderByWithRelationInputSchema.array(),
          TwoFactorConfirmationOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: TwoFactorConfirmationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const TwoFactorConfirmationGroupByArgsSchema: z.ZodType<Prisma.TwoFactorConfirmationGroupByArgs> =
  z
    .object({
      where: TwoFactorConfirmationWhereInputSchema.optional(),
      orderBy: z
        .union([
          TwoFactorConfirmationOrderByWithAggregationInputSchema.array(),
          TwoFactorConfirmationOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: TwoFactorConfirmationScalarFieldEnumSchema.array(),
      having:
        TwoFactorConfirmationScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const TwoFactorConfirmationFindUniqueArgsSchema: z.ZodType<Prisma.TwoFactorConfirmationFindUniqueArgs> =
  z
    .object({
      select: TwoFactorConfirmationSelectSchema.optional(),
      include: TwoFactorConfirmationIncludeSchema.optional(),
      where: TwoFactorConfirmationWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TwoFactorConfirmationFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.TwoFactorConfirmationFindUniqueOrThrowArgs> =
  z
    .object({
      select: TwoFactorConfirmationSelectSchema.optional(),
      include: TwoFactorConfirmationIncludeSchema.optional(),
      where: TwoFactorConfirmationWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const AccountFindFirstArgsSchema: z.ZodType<Prisma.AccountFindFirstArgs> =
  z
    .object({
      select: AccountSelectSchema.optional(),
      include: AccountIncludeSchema.optional(),
      where: AccountWhereInputSchema.optional(),
      orderBy: z
        .union([
          AccountOrderByWithRelationInputSchema.array(),
          AccountOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: AccountWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          AccountScalarFieldEnumSchema,
          AccountScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const AccountFindFirstOrThrowArgsSchema: z.ZodType<Prisma.AccountFindFirstOrThrowArgs> =
  z
    .object({
      select: AccountSelectSchema.optional(),
      include: AccountIncludeSchema.optional(),
      where: AccountWhereInputSchema.optional(),
      orderBy: z
        .union([
          AccountOrderByWithRelationInputSchema.array(),
          AccountOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: AccountWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          AccountScalarFieldEnumSchema,
          AccountScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const AccountFindManyArgsSchema: z.ZodType<Prisma.AccountFindManyArgs> =
  z
    .object({
      select: AccountSelectSchema.optional(),
      include: AccountIncludeSchema.optional(),
      where: AccountWhereInputSchema.optional(),
      orderBy: z
        .union([
          AccountOrderByWithRelationInputSchema.array(),
          AccountOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: AccountWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          AccountScalarFieldEnumSchema,
          AccountScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const AccountAggregateArgsSchema: z.ZodType<Prisma.AccountAggregateArgs> =
  z
    .object({
      where: AccountWhereInputSchema.optional(),
      orderBy: z
        .union([
          AccountOrderByWithRelationInputSchema.array(),
          AccountOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: AccountWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const AccountGroupByArgsSchema: z.ZodType<Prisma.AccountGroupByArgs> = z
  .object({
    where: AccountWhereInputSchema.optional(),
    orderBy: z
      .union([
        AccountOrderByWithAggregationInputSchema.array(),
        AccountOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: AccountScalarFieldEnumSchema.array(),
    having: AccountScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const AccountFindUniqueArgsSchema: z.ZodType<Prisma.AccountFindUniqueArgs> =
  z
    .object({
      select: AccountSelectSchema.optional(),
      include: AccountIncludeSchema.optional(),
      where: AccountWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const AccountFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.AccountFindUniqueOrThrowArgs> =
  z
    .object({
      select: AccountSelectSchema.optional(),
      include: AccountIncludeSchema.optional(),
      where: AccountWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SessionFindFirstArgsSchema: z.ZodType<Prisma.SessionFindFirstArgs> =
  z
    .object({
      select: SessionSelectSchema.optional(),
      include: SessionIncludeSchema.optional(),
      where: SessionWhereInputSchema.optional(),
      orderBy: z
        .union([
          SessionOrderByWithRelationInputSchema.array(),
          SessionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: SessionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          SessionScalarFieldEnumSchema,
          SessionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SessionFindFirstOrThrowArgsSchema: z.ZodType<Prisma.SessionFindFirstOrThrowArgs> =
  z
    .object({
      select: SessionSelectSchema.optional(),
      include: SessionIncludeSchema.optional(),
      where: SessionWhereInputSchema.optional(),
      orderBy: z
        .union([
          SessionOrderByWithRelationInputSchema.array(),
          SessionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: SessionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          SessionScalarFieldEnumSchema,
          SessionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SessionFindManyArgsSchema: z.ZodType<Prisma.SessionFindManyArgs> =
  z
    .object({
      select: SessionSelectSchema.optional(),
      include: SessionIncludeSchema.optional(),
      where: SessionWhereInputSchema.optional(),
      orderBy: z
        .union([
          SessionOrderByWithRelationInputSchema.array(),
          SessionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: SessionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          SessionScalarFieldEnumSchema,
          SessionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SessionAggregateArgsSchema: z.ZodType<Prisma.SessionAggregateArgs> =
  z
    .object({
      where: SessionWhereInputSchema.optional(),
      orderBy: z
        .union([
          SessionOrderByWithRelationInputSchema.array(),
          SessionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: SessionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const SessionGroupByArgsSchema: z.ZodType<Prisma.SessionGroupByArgs> = z
  .object({
    where: SessionWhereInputSchema.optional(),
    orderBy: z
      .union([
        SessionOrderByWithAggregationInputSchema.array(),
        SessionOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: SessionScalarFieldEnumSchema.array(),
    having: SessionScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const SessionFindUniqueArgsSchema: z.ZodType<Prisma.SessionFindUniqueArgs> =
  z
    .object({
      select: SessionSelectSchema.optional(),
      include: SessionIncludeSchema.optional(),
      where: SessionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SessionFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.SessionFindUniqueOrThrowArgs> =
  z
    .object({
      select: SessionSelectSchema.optional(),
      include: SessionIncludeSchema.optional(),
      where: SessionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const VerificationFindFirstArgsSchema: z.ZodType<Prisma.VerificationFindFirstArgs> =
  z
    .object({
      select: VerificationSelectSchema.optional(),
      where: VerificationWhereInputSchema.optional(),
      orderBy: z
        .union([
          VerificationOrderByWithRelationInputSchema.array(),
          VerificationOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: VerificationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          VerificationScalarFieldEnumSchema,
          VerificationScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const VerificationFindFirstOrThrowArgsSchema: z.ZodType<Prisma.VerificationFindFirstOrThrowArgs> =
  z
    .object({
      select: VerificationSelectSchema.optional(),
      where: VerificationWhereInputSchema.optional(),
      orderBy: z
        .union([
          VerificationOrderByWithRelationInputSchema.array(),
          VerificationOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: VerificationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          VerificationScalarFieldEnumSchema,
          VerificationScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const VerificationFindManyArgsSchema: z.ZodType<Prisma.VerificationFindManyArgs> =
  z
    .object({
      select: VerificationSelectSchema.optional(),
      where: VerificationWhereInputSchema.optional(),
      orderBy: z
        .union([
          VerificationOrderByWithRelationInputSchema.array(),
          VerificationOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: VerificationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          VerificationScalarFieldEnumSchema,
          VerificationScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const VerificationAggregateArgsSchema: z.ZodType<Prisma.VerificationAggregateArgs> =
  z
    .object({
      where: VerificationWhereInputSchema.optional(),
      orderBy: z
        .union([
          VerificationOrderByWithRelationInputSchema.array(),
          VerificationOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: VerificationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const VerificationGroupByArgsSchema: z.ZodType<Prisma.VerificationGroupByArgs> =
  z
    .object({
      where: VerificationWhereInputSchema.optional(),
      orderBy: z
        .union([
          VerificationOrderByWithAggregationInputSchema.array(),
          VerificationOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: VerificationScalarFieldEnumSchema.array(),
      having: VerificationScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const VerificationFindUniqueArgsSchema: z.ZodType<Prisma.VerificationFindUniqueArgs> =
  z
    .object({
      select: VerificationSelectSchema.optional(),
      where: VerificationWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const VerificationFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.VerificationFindUniqueOrThrowArgs> =
  z
    .object({
      select: VerificationSelectSchema.optional(),
      where: VerificationWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const AuthenticatorFindFirstArgsSchema: z.ZodType<Prisma.AuthenticatorFindFirstArgs> =
  z
    .object({
      select: AuthenticatorSelectSchema.optional(),
      include: AuthenticatorIncludeSchema.optional(),
      where: AuthenticatorWhereInputSchema.optional(),
      orderBy: z
        .union([
          AuthenticatorOrderByWithRelationInputSchema.array(),
          AuthenticatorOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: AuthenticatorWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          AuthenticatorScalarFieldEnumSchema,
          AuthenticatorScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const AuthenticatorFindFirstOrThrowArgsSchema: z.ZodType<Prisma.AuthenticatorFindFirstOrThrowArgs> =
  z
    .object({
      select: AuthenticatorSelectSchema.optional(),
      include: AuthenticatorIncludeSchema.optional(),
      where: AuthenticatorWhereInputSchema.optional(),
      orderBy: z
        .union([
          AuthenticatorOrderByWithRelationInputSchema.array(),
          AuthenticatorOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: AuthenticatorWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          AuthenticatorScalarFieldEnumSchema,
          AuthenticatorScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const AuthenticatorFindManyArgsSchema: z.ZodType<Prisma.AuthenticatorFindManyArgs> =
  z
    .object({
      select: AuthenticatorSelectSchema.optional(),
      include: AuthenticatorIncludeSchema.optional(),
      where: AuthenticatorWhereInputSchema.optional(),
      orderBy: z
        .union([
          AuthenticatorOrderByWithRelationInputSchema.array(),
          AuthenticatorOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: AuthenticatorWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          AuthenticatorScalarFieldEnumSchema,
          AuthenticatorScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const AuthenticatorAggregateArgsSchema: z.ZodType<Prisma.AuthenticatorAggregateArgs> =
  z
    .object({
      where: AuthenticatorWhereInputSchema.optional(),
      orderBy: z
        .union([
          AuthenticatorOrderByWithRelationInputSchema.array(),
          AuthenticatorOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: AuthenticatorWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const AuthenticatorGroupByArgsSchema: z.ZodType<Prisma.AuthenticatorGroupByArgs> =
  z
    .object({
      where: AuthenticatorWhereInputSchema.optional(),
      orderBy: z
        .union([
          AuthenticatorOrderByWithAggregationInputSchema.array(),
          AuthenticatorOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: AuthenticatorScalarFieldEnumSchema.array(),
      having: AuthenticatorScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const AuthenticatorFindUniqueArgsSchema: z.ZodType<Prisma.AuthenticatorFindUniqueArgs> =
  z
    .object({
      select: AuthenticatorSelectSchema.optional(),
      include: AuthenticatorIncludeSchema.optional(),
      where: AuthenticatorWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const AuthenticatorFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.AuthenticatorFindUniqueOrThrowArgs> =
  z
    .object({
      select: AuthenticatorSelectSchema.optional(),
      include: AuthenticatorIncludeSchema.optional(),
      where: AuthenticatorWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const PasswordResetTokenFindFirstArgsSchema: z.ZodType<Prisma.PasswordResetTokenFindFirstArgs> =
  z
    .object({
      select: PasswordResetTokenSelectSchema.optional(),
      where: PasswordResetTokenWhereInputSchema.optional(),
      orderBy: z
        .union([
          PasswordResetTokenOrderByWithRelationInputSchema.array(),
          PasswordResetTokenOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: PasswordResetTokenWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          PasswordResetTokenScalarFieldEnumSchema,
          PasswordResetTokenScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const PasswordResetTokenFindFirstOrThrowArgsSchema: z.ZodType<Prisma.PasswordResetTokenFindFirstOrThrowArgs> =
  z
    .object({
      select: PasswordResetTokenSelectSchema.optional(),
      where: PasswordResetTokenWhereInputSchema.optional(),
      orderBy: z
        .union([
          PasswordResetTokenOrderByWithRelationInputSchema.array(),
          PasswordResetTokenOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: PasswordResetTokenWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          PasswordResetTokenScalarFieldEnumSchema,
          PasswordResetTokenScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const PasswordResetTokenFindManyArgsSchema: z.ZodType<Prisma.PasswordResetTokenFindManyArgs> =
  z
    .object({
      select: PasswordResetTokenSelectSchema.optional(),
      where: PasswordResetTokenWhereInputSchema.optional(),
      orderBy: z
        .union([
          PasswordResetTokenOrderByWithRelationInputSchema.array(),
          PasswordResetTokenOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: PasswordResetTokenWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          PasswordResetTokenScalarFieldEnumSchema,
          PasswordResetTokenScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const PasswordResetTokenAggregateArgsSchema: z.ZodType<Prisma.PasswordResetTokenAggregateArgs> =
  z
    .object({
      where: PasswordResetTokenWhereInputSchema.optional(),
      orderBy: z
        .union([
          PasswordResetTokenOrderByWithRelationInputSchema.array(),
          PasswordResetTokenOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: PasswordResetTokenWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const PasswordResetTokenGroupByArgsSchema: z.ZodType<Prisma.PasswordResetTokenGroupByArgs> =
  z
    .object({
      where: PasswordResetTokenWhereInputSchema.optional(),
      orderBy: z
        .union([
          PasswordResetTokenOrderByWithAggregationInputSchema.array(),
          PasswordResetTokenOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: PasswordResetTokenScalarFieldEnumSchema.array(),
      having: PasswordResetTokenScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const PasswordResetTokenFindUniqueArgsSchema: z.ZodType<Prisma.PasswordResetTokenFindUniqueArgs> =
  z
    .object({
      select: PasswordResetTokenSelectSchema.optional(),
      where: PasswordResetTokenWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const PasswordResetTokenFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.PasswordResetTokenFindUniqueOrThrowArgs> =
  z
    .object({
      select: PasswordResetTokenSelectSchema.optional(),
      where: PasswordResetTokenWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TwoFactorTokenFindFirstArgsSchema: z.ZodType<Prisma.TwoFactorTokenFindFirstArgs> =
  z
    .object({
      select: TwoFactorTokenSelectSchema.optional(),
      where: TwoFactorTokenWhereInputSchema.optional(),
      orderBy: z
        .union([
          TwoFactorTokenOrderByWithRelationInputSchema.array(),
          TwoFactorTokenOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: TwoFactorTokenWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          TwoFactorTokenScalarFieldEnumSchema,
          TwoFactorTokenScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TwoFactorTokenFindFirstOrThrowArgsSchema: z.ZodType<Prisma.TwoFactorTokenFindFirstOrThrowArgs> =
  z
    .object({
      select: TwoFactorTokenSelectSchema.optional(),
      where: TwoFactorTokenWhereInputSchema.optional(),
      orderBy: z
        .union([
          TwoFactorTokenOrderByWithRelationInputSchema.array(),
          TwoFactorTokenOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: TwoFactorTokenWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          TwoFactorTokenScalarFieldEnumSchema,
          TwoFactorTokenScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TwoFactorTokenFindManyArgsSchema: z.ZodType<Prisma.TwoFactorTokenFindManyArgs> =
  z
    .object({
      select: TwoFactorTokenSelectSchema.optional(),
      where: TwoFactorTokenWhereInputSchema.optional(),
      orderBy: z
        .union([
          TwoFactorTokenOrderByWithRelationInputSchema.array(),
          TwoFactorTokenOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: TwoFactorTokenWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          TwoFactorTokenScalarFieldEnumSchema,
          TwoFactorTokenScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TwoFactorTokenAggregateArgsSchema: z.ZodType<Prisma.TwoFactorTokenAggregateArgs> =
  z
    .object({
      where: TwoFactorTokenWhereInputSchema.optional(),
      orderBy: z
        .union([
          TwoFactorTokenOrderByWithRelationInputSchema.array(),
          TwoFactorTokenOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: TwoFactorTokenWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const TwoFactorTokenGroupByArgsSchema: z.ZodType<Prisma.TwoFactorTokenGroupByArgs> =
  z
    .object({
      where: TwoFactorTokenWhereInputSchema.optional(),
      orderBy: z
        .union([
          TwoFactorTokenOrderByWithAggregationInputSchema.array(),
          TwoFactorTokenOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: TwoFactorTokenScalarFieldEnumSchema.array(),
      having: TwoFactorTokenScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const TwoFactorTokenFindUniqueArgsSchema: z.ZodType<Prisma.TwoFactorTokenFindUniqueArgs> =
  z
    .object({
      select: TwoFactorTokenSelectSchema.optional(),
      where: TwoFactorTokenWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TwoFactorTokenFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.TwoFactorTokenFindUniqueOrThrowArgs> =
  z
    .object({
      select: TwoFactorTokenSelectSchema.optional(),
      where: TwoFactorTokenWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CustomerFindFirstArgsSchema: z.ZodType<Prisma.CustomerFindFirstArgs> =
  z
    .object({
      select: CustomerSelectSchema.optional(),
      include: CustomerIncludeSchema.optional(),
      where: CustomerWhereInputSchema.optional(),
      orderBy: z
        .union([
          CustomerOrderByWithRelationInputSchema.array(),
          CustomerOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: CustomerWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CustomerScalarFieldEnumSchema,
          CustomerScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CustomerFindFirstOrThrowArgsSchema: z.ZodType<Prisma.CustomerFindFirstOrThrowArgs> =
  z
    .object({
      select: CustomerSelectSchema.optional(),
      include: CustomerIncludeSchema.optional(),
      where: CustomerWhereInputSchema.optional(),
      orderBy: z
        .union([
          CustomerOrderByWithRelationInputSchema.array(),
          CustomerOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: CustomerWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CustomerScalarFieldEnumSchema,
          CustomerScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CustomerFindManyArgsSchema: z.ZodType<Prisma.CustomerFindManyArgs> =
  z
    .object({
      select: CustomerSelectSchema.optional(),
      include: CustomerIncludeSchema.optional(),
      where: CustomerWhereInputSchema.optional(),
      orderBy: z
        .union([
          CustomerOrderByWithRelationInputSchema.array(),
          CustomerOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: CustomerWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CustomerScalarFieldEnumSchema,
          CustomerScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CustomerAggregateArgsSchema: z.ZodType<Prisma.CustomerAggregateArgs> =
  z
    .object({
      where: CustomerWhereInputSchema.optional(),
      orderBy: z
        .union([
          CustomerOrderByWithRelationInputSchema.array(),
          CustomerOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: CustomerWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const CustomerGroupByArgsSchema: z.ZodType<Prisma.CustomerGroupByArgs> =
  z
    .object({
      where: CustomerWhereInputSchema.optional(),
      orderBy: z
        .union([
          CustomerOrderByWithAggregationInputSchema.array(),
          CustomerOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: CustomerScalarFieldEnumSchema.array(),
      having: CustomerScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const CustomerFindUniqueArgsSchema: z.ZodType<Prisma.CustomerFindUniqueArgs> =
  z
    .object({
      select: CustomerSelectSchema.optional(),
      include: CustomerIncludeSchema.optional(),
      where: CustomerWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CustomerFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.CustomerFindUniqueOrThrowArgs> =
  z
    .object({
      select: CustomerSelectSchema.optional(),
      include: CustomerIncludeSchema.optional(),
      where: CustomerWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ProductFindFirstArgsSchema: z.ZodType<Prisma.ProductFindFirstArgs> =
  z
    .object({
      select: ProductSelectSchema.optional(),
      include: ProductIncludeSchema.optional(),
      where: ProductWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductOrderByWithRelationInputSchema.array(),
          ProductOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: ProductWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ProductScalarFieldEnumSchema,
          ProductScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ProductFindFirstOrThrowArgsSchema: z.ZodType<Prisma.ProductFindFirstOrThrowArgs> =
  z
    .object({
      select: ProductSelectSchema.optional(),
      include: ProductIncludeSchema.optional(),
      where: ProductWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductOrderByWithRelationInputSchema.array(),
          ProductOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: ProductWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ProductScalarFieldEnumSchema,
          ProductScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ProductFindManyArgsSchema: z.ZodType<Prisma.ProductFindManyArgs> =
  z
    .object({
      select: ProductSelectSchema.optional(),
      include: ProductIncludeSchema.optional(),
      where: ProductWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductOrderByWithRelationInputSchema.array(),
          ProductOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: ProductWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ProductScalarFieldEnumSchema,
          ProductScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ProductAggregateArgsSchema: z.ZodType<Prisma.ProductAggregateArgs> =
  z
    .object({
      where: ProductWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProductOrderByWithRelationInputSchema.array(),
          ProductOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: ProductWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const ProductGroupByArgsSchema: z.ZodType<Prisma.ProductGroupByArgs> = z
  .object({
    where: ProductWhereInputSchema.optional(),
    orderBy: z
      .union([
        ProductOrderByWithAggregationInputSchema.array(),
        ProductOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: ProductScalarFieldEnumSchema.array(),
    having: ProductScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const ProductFindUniqueArgsSchema: z.ZodType<Prisma.ProductFindUniqueArgs> =
  z
    .object({
      select: ProductSelectSchema.optional(),
      include: ProductIncludeSchema.optional(),
      where: ProductWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ProductFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.ProductFindUniqueOrThrowArgs> =
  z
    .object({
      select: ProductSelectSchema.optional(),
      include: ProductIncludeSchema.optional(),
      where: ProductWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const PriceFindFirstArgsSchema: z.ZodType<Prisma.PriceFindFirstArgs> = z
  .object({
    select: PriceSelectSchema.optional(),
    include: PriceIncludeSchema.optional(),
    where: PriceWhereInputSchema.optional(),
    orderBy: z
      .union([
        PriceOrderByWithRelationInputSchema.array(),
        PriceOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: PriceWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([PriceScalarFieldEnumSchema, PriceScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const PriceFindFirstOrThrowArgsSchema: z.ZodType<Prisma.PriceFindFirstOrThrowArgs> =
  z
    .object({
      select: PriceSelectSchema.optional(),
      include: PriceIncludeSchema.optional(),
      where: PriceWhereInputSchema.optional(),
      orderBy: z
        .union([
          PriceOrderByWithRelationInputSchema.array(),
          PriceOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: PriceWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([PriceScalarFieldEnumSchema, PriceScalarFieldEnumSchema.array()])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const PriceFindManyArgsSchema: z.ZodType<Prisma.PriceFindManyArgs> = z
  .object({
    select: PriceSelectSchema.optional(),
    include: PriceIncludeSchema.optional(),
    where: PriceWhereInputSchema.optional(),
    orderBy: z
      .union([
        PriceOrderByWithRelationInputSchema.array(),
        PriceOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: PriceWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([PriceScalarFieldEnumSchema, PriceScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const PriceAggregateArgsSchema: z.ZodType<Prisma.PriceAggregateArgs> = z
  .object({
    where: PriceWhereInputSchema.optional(),
    orderBy: z
      .union([
        PriceOrderByWithRelationInputSchema.array(),
        PriceOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: PriceWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const PriceGroupByArgsSchema: z.ZodType<Prisma.PriceGroupByArgs> = z
  .object({
    where: PriceWhereInputSchema.optional(),
    orderBy: z
      .union([
        PriceOrderByWithAggregationInputSchema.array(),
        PriceOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: PriceScalarFieldEnumSchema.array(),
    having: PriceScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const PriceFindUniqueArgsSchema: z.ZodType<Prisma.PriceFindUniqueArgs> =
  z
    .object({
      select: PriceSelectSchema.optional(),
      include: PriceIncludeSchema.optional(),
      where: PriceWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const PriceFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.PriceFindUniqueOrThrowArgs> =
  z
    .object({
      select: PriceSelectSchema.optional(),
      include: PriceIncludeSchema.optional(),
      where: PriceWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SubscriptionFindFirstArgsSchema: z.ZodType<Prisma.SubscriptionFindFirstArgs> =
  z
    .object({
      select: SubscriptionSelectSchema.optional(),
      include: SubscriptionIncludeSchema.optional(),
      where: SubscriptionWhereInputSchema.optional(),
      orderBy: z
        .union([
          SubscriptionOrderByWithRelationInputSchema.array(),
          SubscriptionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: SubscriptionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          SubscriptionScalarFieldEnumSchema,
          SubscriptionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SubscriptionFindFirstOrThrowArgsSchema: z.ZodType<Prisma.SubscriptionFindFirstOrThrowArgs> =
  z
    .object({
      select: SubscriptionSelectSchema.optional(),
      include: SubscriptionIncludeSchema.optional(),
      where: SubscriptionWhereInputSchema.optional(),
      orderBy: z
        .union([
          SubscriptionOrderByWithRelationInputSchema.array(),
          SubscriptionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: SubscriptionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          SubscriptionScalarFieldEnumSchema,
          SubscriptionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SubscriptionFindManyArgsSchema: z.ZodType<Prisma.SubscriptionFindManyArgs> =
  z
    .object({
      select: SubscriptionSelectSchema.optional(),
      include: SubscriptionIncludeSchema.optional(),
      where: SubscriptionWhereInputSchema.optional(),
      orderBy: z
        .union([
          SubscriptionOrderByWithRelationInputSchema.array(),
          SubscriptionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: SubscriptionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          SubscriptionScalarFieldEnumSchema,
          SubscriptionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SubscriptionAggregateArgsSchema: z.ZodType<Prisma.SubscriptionAggregateArgs> =
  z
    .object({
      where: SubscriptionWhereInputSchema.optional(),
      orderBy: z
        .union([
          SubscriptionOrderByWithRelationInputSchema.array(),
          SubscriptionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: SubscriptionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const SubscriptionGroupByArgsSchema: z.ZodType<Prisma.SubscriptionGroupByArgs> =
  z
    .object({
      where: SubscriptionWhereInputSchema.optional(),
      orderBy: z
        .union([
          SubscriptionOrderByWithAggregationInputSchema.array(),
          SubscriptionOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: SubscriptionScalarFieldEnumSchema.array(),
      having: SubscriptionScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const SubscriptionFindUniqueArgsSchema: z.ZodType<Prisma.SubscriptionFindUniqueArgs> =
  z
    .object({
      select: SubscriptionSelectSchema.optional(),
      include: SubscriptionIncludeSchema.optional(),
      where: SubscriptionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SubscriptionFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.SubscriptionFindUniqueOrThrowArgs> =
  z
    .object({
      select: SubscriptionSelectSchema.optional(),
      include: SubscriptionIncludeSchema.optional(),
      where: SubscriptionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const FeedFindFirstArgsSchema: z.ZodType<Prisma.FeedFindFirstArgs> = z
  .object({
    select: FeedSelectSchema.optional(),
    include: FeedIncludeSchema.optional(),
    where: FeedWhereInputSchema.optional(),
    orderBy: z
      .union([
        FeedOrderByWithRelationInputSchema.array(),
        FeedOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: FeedWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([FeedScalarFieldEnumSchema, FeedScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const FeedFindFirstOrThrowArgsSchema: z.ZodType<Prisma.FeedFindFirstOrThrowArgs> =
  z
    .object({
      select: FeedSelectSchema.optional(),
      include: FeedIncludeSchema.optional(),
      where: FeedWhereInputSchema.optional(),
      orderBy: z
        .union([
          FeedOrderByWithRelationInputSchema.array(),
          FeedOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: FeedWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([FeedScalarFieldEnumSchema, FeedScalarFieldEnumSchema.array()])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const FeedFindManyArgsSchema: z.ZodType<Prisma.FeedFindManyArgs> = z
  .object({
    select: FeedSelectSchema.optional(),
    include: FeedIncludeSchema.optional(),
    where: FeedWhereInputSchema.optional(),
    orderBy: z
      .union([
        FeedOrderByWithRelationInputSchema.array(),
        FeedOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: FeedWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([FeedScalarFieldEnumSchema, FeedScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const FeedAggregateArgsSchema: z.ZodType<Prisma.FeedAggregateArgs> = z
  .object({
    where: FeedWhereInputSchema.optional(),
    orderBy: z
      .union([
        FeedOrderByWithRelationInputSchema.array(),
        FeedOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: FeedWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const FeedGroupByArgsSchema: z.ZodType<Prisma.FeedGroupByArgs> = z
  .object({
    where: FeedWhereInputSchema.optional(),
    orderBy: z
      .union([
        FeedOrderByWithAggregationInputSchema.array(),
        FeedOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: FeedScalarFieldEnumSchema.array(),
    having: FeedScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const FeedFindUniqueArgsSchema: z.ZodType<Prisma.FeedFindUniqueArgs> = z
  .object({
    select: FeedSelectSchema.optional(),
    include: FeedIncludeSchema.optional(),
    where: FeedWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const FeedFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.FeedFindUniqueOrThrowArgs> =
  z
    .object({
      select: FeedSelectSchema.optional(),
      include: FeedIncludeSchema.optional(),
      where: FeedWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CommentFindFirstArgsSchema: z.ZodType<Prisma.CommentFindFirstArgs> =
  z
    .object({
      select: CommentSelectSchema.optional(),
      include: CommentIncludeSchema.optional(),
      where: CommentWhereInputSchema.optional(),
      orderBy: z
        .union([
          CommentOrderByWithRelationInputSchema.array(),
          CommentOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: CommentWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CommentScalarFieldEnumSchema,
          CommentScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CommentFindFirstOrThrowArgsSchema: z.ZodType<Prisma.CommentFindFirstOrThrowArgs> =
  z
    .object({
      select: CommentSelectSchema.optional(),
      include: CommentIncludeSchema.optional(),
      where: CommentWhereInputSchema.optional(),
      orderBy: z
        .union([
          CommentOrderByWithRelationInputSchema.array(),
          CommentOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: CommentWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CommentScalarFieldEnumSchema,
          CommentScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CommentFindManyArgsSchema: z.ZodType<Prisma.CommentFindManyArgs> =
  z
    .object({
      select: CommentSelectSchema.optional(),
      include: CommentIncludeSchema.optional(),
      where: CommentWhereInputSchema.optional(),
      orderBy: z
        .union([
          CommentOrderByWithRelationInputSchema.array(),
          CommentOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: CommentWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CommentScalarFieldEnumSchema,
          CommentScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CommentAggregateArgsSchema: z.ZodType<Prisma.CommentAggregateArgs> =
  z
    .object({
      where: CommentWhereInputSchema.optional(),
      orderBy: z
        .union([
          CommentOrderByWithRelationInputSchema.array(),
          CommentOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: CommentWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const CommentGroupByArgsSchema: z.ZodType<Prisma.CommentGroupByArgs> = z
  .object({
    where: CommentWhereInputSchema.optional(),
    orderBy: z
      .union([
        CommentOrderByWithAggregationInputSchema.array(),
        CommentOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: CommentScalarFieldEnumSchema.array(),
    having: CommentScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const CommentFindUniqueArgsSchema: z.ZodType<Prisma.CommentFindUniqueArgs> =
  z
    .object({
      select: CommentSelectSchema.optional(),
      include: CommentIncludeSchema.optional(),
      where: CommentWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CommentFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.CommentFindUniqueOrThrowArgs> =
  z
    .object({
      select: CommentSelectSchema.optional(),
      include: CommentIncludeSchema.optional(),
      where: CommentWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CityFindFirstArgsSchema: z.ZodType<Prisma.CityFindFirstArgs> = z
  .object({
    select: CitySelectSchema.optional(),
    where: CityWhereInputSchema.optional(),
    orderBy: z
      .union([
        CityOrderByWithRelationInputSchema.array(),
        CityOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: CityWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([CityScalarFieldEnumSchema, CityScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CityFindFirstOrThrowArgsSchema: z.ZodType<Prisma.CityFindFirstOrThrowArgs> =
  z
    .object({
      select: CitySelectSchema.optional(),
      where: CityWhereInputSchema.optional(),
      orderBy: z
        .union([
          CityOrderByWithRelationInputSchema.array(),
          CityOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: CityWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([CityScalarFieldEnumSchema, CityScalarFieldEnumSchema.array()])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CityFindManyArgsSchema: z.ZodType<Prisma.CityFindManyArgs> = z
  .object({
    select: CitySelectSchema.optional(),
    where: CityWhereInputSchema.optional(),
    orderBy: z
      .union([
        CityOrderByWithRelationInputSchema.array(),
        CityOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: CityWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([CityScalarFieldEnumSchema, CityScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CityAggregateArgsSchema: z.ZodType<Prisma.CityAggregateArgs> = z
  .object({
    where: CityWhereInputSchema.optional(),
    orderBy: z
      .union([
        CityOrderByWithRelationInputSchema.array(),
        CityOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: CityWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const CityGroupByArgsSchema: z.ZodType<Prisma.CityGroupByArgs> = z
  .object({
    where: CityWhereInputSchema.optional(),
    orderBy: z
      .union([
        CityOrderByWithAggregationInputSchema.array(),
        CityOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: CityScalarFieldEnumSchema.array(),
    having: CityScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const CityFindUniqueArgsSchema: z.ZodType<Prisma.CityFindUniqueArgs> = z
  .object({
    select: CitySelectSchema.optional(),
    where: CityWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CityFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.CityFindUniqueOrThrowArgs> =
  z
    .object({
      select: CitySelectSchema.optional(),
      where: CityWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafSectionFindFirstArgsSchema: z.ZodType<Prisma.NafSectionFindFirstArgs> =
  z
    .object({
      select: NafSectionSelectSchema.optional(),
      include: NafSectionIncludeSchema.optional(),
      where: NafSectionWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafSectionOrderByWithRelationInputSchema.array(),
          NafSectionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: NafSectionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          NafSectionScalarFieldEnumSchema,
          NafSectionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafSectionFindFirstOrThrowArgsSchema: z.ZodType<Prisma.NafSectionFindFirstOrThrowArgs> =
  z
    .object({
      select: NafSectionSelectSchema.optional(),
      include: NafSectionIncludeSchema.optional(),
      where: NafSectionWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafSectionOrderByWithRelationInputSchema.array(),
          NafSectionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: NafSectionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          NafSectionScalarFieldEnumSchema,
          NafSectionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafSectionFindManyArgsSchema: z.ZodType<Prisma.NafSectionFindManyArgs> =
  z
    .object({
      select: NafSectionSelectSchema.optional(),
      include: NafSectionIncludeSchema.optional(),
      where: NafSectionWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafSectionOrderByWithRelationInputSchema.array(),
          NafSectionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: NafSectionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          NafSectionScalarFieldEnumSchema,
          NafSectionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafSectionAggregateArgsSchema: z.ZodType<Prisma.NafSectionAggregateArgs> =
  z
    .object({
      where: NafSectionWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafSectionOrderByWithRelationInputSchema.array(),
          NafSectionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: NafSectionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const NafSectionGroupByArgsSchema: z.ZodType<Prisma.NafSectionGroupByArgs> =
  z
    .object({
      where: NafSectionWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafSectionOrderByWithAggregationInputSchema.array(),
          NafSectionOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: NafSectionScalarFieldEnumSchema.array(),
      having: NafSectionScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const NafSectionFindUniqueArgsSchema: z.ZodType<Prisma.NafSectionFindUniqueArgs> =
  z
    .object({
      select: NafSectionSelectSchema.optional(),
      include: NafSectionIncludeSchema.optional(),
      where: NafSectionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafSectionFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.NafSectionFindUniqueOrThrowArgs> =
  z
    .object({
      select: NafSectionSelectSchema.optional(),
      include: NafSectionIncludeSchema.optional(),
      where: NafSectionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafDivisionFindFirstArgsSchema: z.ZodType<Prisma.NafDivisionFindFirstArgs> =
  z
    .object({
      select: NafDivisionSelectSchema.optional(),
      include: NafDivisionIncludeSchema.optional(),
      where: NafDivisionWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafDivisionOrderByWithRelationInputSchema.array(),
          NafDivisionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: NafDivisionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          NafDivisionScalarFieldEnumSchema,
          NafDivisionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafDivisionFindFirstOrThrowArgsSchema: z.ZodType<Prisma.NafDivisionFindFirstOrThrowArgs> =
  z
    .object({
      select: NafDivisionSelectSchema.optional(),
      include: NafDivisionIncludeSchema.optional(),
      where: NafDivisionWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafDivisionOrderByWithRelationInputSchema.array(),
          NafDivisionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: NafDivisionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          NafDivisionScalarFieldEnumSchema,
          NafDivisionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafDivisionFindManyArgsSchema: z.ZodType<Prisma.NafDivisionFindManyArgs> =
  z
    .object({
      select: NafDivisionSelectSchema.optional(),
      include: NafDivisionIncludeSchema.optional(),
      where: NafDivisionWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafDivisionOrderByWithRelationInputSchema.array(),
          NafDivisionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: NafDivisionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          NafDivisionScalarFieldEnumSchema,
          NafDivisionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafDivisionAggregateArgsSchema: z.ZodType<Prisma.NafDivisionAggregateArgs> =
  z
    .object({
      where: NafDivisionWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafDivisionOrderByWithRelationInputSchema.array(),
          NafDivisionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: NafDivisionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const NafDivisionGroupByArgsSchema: z.ZodType<Prisma.NafDivisionGroupByArgs> =
  z
    .object({
      where: NafDivisionWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafDivisionOrderByWithAggregationInputSchema.array(),
          NafDivisionOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: NafDivisionScalarFieldEnumSchema.array(),
      having: NafDivisionScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const NafDivisionFindUniqueArgsSchema: z.ZodType<Prisma.NafDivisionFindUniqueArgs> =
  z
    .object({
      select: NafDivisionSelectSchema.optional(),
      include: NafDivisionIncludeSchema.optional(),
      where: NafDivisionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafDivisionFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.NafDivisionFindUniqueOrThrowArgs> =
  z
    .object({
      select: NafDivisionSelectSchema.optional(),
      include: NafDivisionIncludeSchema.optional(),
      where: NafDivisionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafGroupFindFirstArgsSchema: z.ZodType<Prisma.NafGroupFindFirstArgs> =
  z
    .object({
      select: NafGroupSelectSchema.optional(),
      include: NafGroupIncludeSchema.optional(),
      where: NafGroupWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafGroupOrderByWithRelationInputSchema.array(),
          NafGroupOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: NafGroupWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          NafGroupScalarFieldEnumSchema,
          NafGroupScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafGroupFindFirstOrThrowArgsSchema: z.ZodType<Prisma.NafGroupFindFirstOrThrowArgs> =
  z
    .object({
      select: NafGroupSelectSchema.optional(),
      include: NafGroupIncludeSchema.optional(),
      where: NafGroupWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafGroupOrderByWithRelationInputSchema.array(),
          NafGroupOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: NafGroupWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          NafGroupScalarFieldEnumSchema,
          NafGroupScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafGroupFindManyArgsSchema: z.ZodType<Prisma.NafGroupFindManyArgs> =
  z
    .object({
      select: NafGroupSelectSchema.optional(),
      include: NafGroupIncludeSchema.optional(),
      where: NafGroupWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafGroupOrderByWithRelationInputSchema.array(),
          NafGroupOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: NafGroupWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          NafGroupScalarFieldEnumSchema,
          NafGroupScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafGroupAggregateArgsSchema: z.ZodType<Prisma.NafGroupAggregateArgs> =
  z
    .object({
      where: NafGroupWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafGroupOrderByWithRelationInputSchema.array(),
          NafGroupOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: NafGroupWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const NafGroupGroupByArgsSchema: z.ZodType<Prisma.NafGroupGroupByArgs> =
  z
    .object({
      where: NafGroupWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafGroupOrderByWithAggregationInputSchema.array(),
          NafGroupOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: NafGroupScalarFieldEnumSchema.array(),
      having: NafGroupScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const NafGroupFindUniqueArgsSchema: z.ZodType<Prisma.NafGroupFindUniqueArgs> =
  z
    .object({
      select: NafGroupSelectSchema.optional(),
      include: NafGroupIncludeSchema.optional(),
      where: NafGroupWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafGroupFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.NafGroupFindUniqueOrThrowArgs> =
  z
    .object({
      select: NafGroupSelectSchema.optional(),
      include: NafGroupIncludeSchema.optional(),
      where: NafGroupWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafClassFindFirstArgsSchema: z.ZodType<Prisma.NafClassFindFirstArgs> =
  z
    .object({
      select: NafClassSelectSchema.optional(),
      include: NafClassIncludeSchema.optional(),
      where: NafClassWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafClassOrderByWithRelationInputSchema.array(),
          NafClassOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: NafClassWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          NafClassScalarFieldEnumSchema,
          NafClassScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafClassFindFirstOrThrowArgsSchema: z.ZodType<Prisma.NafClassFindFirstOrThrowArgs> =
  z
    .object({
      select: NafClassSelectSchema.optional(),
      include: NafClassIncludeSchema.optional(),
      where: NafClassWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafClassOrderByWithRelationInputSchema.array(),
          NafClassOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: NafClassWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          NafClassScalarFieldEnumSchema,
          NafClassScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafClassFindManyArgsSchema: z.ZodType<Prisma.NafClassFindManyArgs> =
  z
    .object({
      select: NafClassSelectSchema.optional(),
      include: NafClassIncludeSchema.optional(),
      where: NafClassWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafClassOrderByWithRelationInputSchema.array(),
          NafClassOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: NafClassWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          NafClassScalarFieldEnumSchema,
          NafClassScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafClassAggregateArgsSchema: z.ZodType<Prisma.NafClassAggregateArgs> =
  z
    .object({
      where: NafClassWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafClassOrderByWithRelationInputSchema.array(),
          NafClassOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: NafClassWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const NafClassGroupByArgsSchema: z.ZodType<Prisma.NafClassGroupByArgs> =
  z
    .object({
      where: NafClassWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafClassOrderByWithAggregationInputSchema.array(),
          NafClassOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: NafClassScalarFieldEnumSchema.array(),
      having: NafClassScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const NafClassFindUniqueArgsSchema: z.ZodType<Prisma.NafClassFindUniqueArgs> =
  z
    .object({
      select: NafClassSelectSchema.optional(),
      include: NafClassIncludeSchema.optional(),
      where: NafClassWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafClassFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.NafClassFindUniqueOrThrowArgs> =
  z
    .object({
      select: NafClassSelectSchema.optional(),
      include: NafClassIncludeSchema.optional(),
      where: NafClassWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafCodeFindFirstArgsSchema: z.ZodType<Prisma.NafCodeFindFirstArgs> =
  z
    .object({
      select: NafCodeSelectSchema.optional(),
      include: NafCodeIncludeSchema.optional(),
      where: NafCodeWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafCodeOrderByWithRelationInputSchema.array(),
          NafCodeOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: NafCodeWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          NafCodeScalarFieldEnumSchema,
          NafCodeScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafCodeFindFirstOrThrowArgsSchema: z.ZodType<Prisma.NafCodeFindFirstOrThrowArgs> =
  z
    .object({
      select: NafCodeSelectSchema.optional(),
      include: NafCodeIncludeSchema.optional(),
      where: NafCodeWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafCodeOrderByWithRelationInputSchema.array(),
          NafCodeOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: NafCodeWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          NafCodeScalarFieldEnumSchema,
          NafCodeScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafCodeFindManyArgsSchema: z.ZodType<Prisma.NafCodeFindManyArgs> =
  z
    .object({
      select: NafCodeSelectSchema.optional(),
      include: NafCodeIncludeSchema.optional(),
      where: NafCodeWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafCodeOrderByWithRelationInputSchema.array(),
          NafCodeOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: NafCodeWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          NafCodeScalarFieldEnumSchema,
          NafCodeScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafCodeAggregateArgsSchema: z.ZodType<Prisma.NafCodeAggregateArgs> =
  z
    .object({
      where: NafCodeWhereInputSchema.optional(),
      orderBy: z
        .union([
          NafCodeOrderByWithRelationInputSchema.array(),
          NafCodeOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: NafCodeWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const NafCodeGroupByArgsSchema: z.ZodType<Prisma.NafCodeGroupByArgs> = z
  .object({
    where: NafCodeWhereInputSchema.optional(),
    orderBy: z
      .union([
        NafCodeOrderByWithAggregationInputSchema.array(),
        NafCodeOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: NafCodeScalarFieldEnumSchema.array(),
    having: NafCodeScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const NafCodeFindUniqueArgsSchema: z.ZodType<Prisma.NafCodeFindUniqueArgs> =
  z
    .object({
      select: NafCodeSelectSchema.optional(),
      include: NafCodeIncludeSchema.optional(),
      where: NafCodeWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafCodeFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.NafCodeFindUniqueOrThrowArgs> =
  z
    .object({
      select: NafCodeSelectSchema.optional(),
      include: NafCodeIncludeSchema.optional(),
      where: NafCodeWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const OutboxFindFirstArgsSchema: z.ZodType<Prisma.OutboxFindFirstArgs> =
  z
    .object({
      select: OutboxSelectSchema.optional(),
      include: OutboxIncludeSchema.optional(),
      where: OutboxWhereInputSchema.optional(),
      orderBy: z
        .union([
          OutboxOrderByWithRelationInputSchema.array(),
          OutboxOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: OutboxWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OutboxScalarFieldEnumSchema,
          OutboxScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const OutboxFindFirstOrThrowArgsSchema: z.ZodType<Prisma.OutboxFindFirstOrThrowArgs> =
  z
    .object({
      select: OutboxSelectSchema.optional(),
      include: OutboxIncludeSchema.optional(),
      where: OutboxWhereInputSchema.optional(),
      orderBy: z
        .union([
          OutboxOrderByWithRelationInputSchema.array(),
          OutboxOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: OutboxWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OutboxScalarFieldEnumSchema,
          OutboxScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const OutboxFindManyArgsSchema: z.ZodType<Prisma.OutboxFindManyArgs> = z
  .object({
    select: OutboxSelectSchema.optional(),
    include: OutboxIncludeSchema.optional(),
    where: OutboxWhereInputSchema.optional(),
    orderBy: z
      .union([
        OutboxOrderByWithRelationInputSchema.array(),
        OutboxOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: OutboxWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([OutboxScalarFieldEnumSchema, OutboxScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const OutboxAggregateArgsSchema: z.ZodType<Prisma.OutboxAggregateArgs> =
  z
    .object({
      where: OutboxWhereInputSchema.optional(),
      orderBy: z
        .union([
          OutboxOrderByWithRelationInputSchema.array(),
          OutboxOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: OutboxWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const OutboxGroupByArgsSchema: z.ZodType<Prisma.OutboxGroupByArgs> = z
  .object({
    where: OutboxWhereInputSchema.optional(),
    orderBy: z
      .union([
        OutboxOrderByWithAggregationInputSchema.array(),
        OutboxOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: OutboxScalarFieldEnumSchema.array(),
    having: OutboxScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const OutboxFindUniqueArgsSchema: z.ZodType<Prisma.OutboxFindUniqueArgs> =
  z
    .object({
      select: OutboxSelectSchema.optional(),
      include: OutboxIncludeSchema.optional(),
      where: OutboxWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const OutboxFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.OutboxFindUniqueOrThrowArgs> =
  z
    .object({
      select: OutboxSelectSchema.optional(),
      include: OutboxIncludeSchema.optional(),
      where: OutboxWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ListFindFirstArgsSchema: z.ZodType<Prisma.ListFindFirstArgs> = z
  .object({
    select: ListSelectSchema.optional(),
    include: ListIncludeSchema.optional(),
    where: ListWhereInputSchema.optional(),
    orderBy: z
      .union([
        ListOrderByWithRelationInputSchema.array(),
        ListOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: ListWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([ListScalarFieldEnumSchema, ListScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const ListFindFirstOrThrowArgsSchema: z.ZodType<Prisma.ListFindFirstOrThrowArgs> =
  z
    .object({
      select: ListSelectSchema.optional(),
      include: ListIncludeSchema.optional(),
      where: ListWhereInputSchema.optional(),
      orderBy: z
        .union([
          ListOrderByWithRelationInputSchema.array(),
          ListOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: ListWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([ListScalarFieldEnumSchema, ListScalarFieldEnumSchema.array()])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ListFindManyArgsSchema: z.ZodType<Prisma.ListFindManyArgs> = z
  .object({
    select: ListSelectSchema.optional(),
    include: ListIncludeSchema.optional(),
    where: ListWhereInputSchema.optional(),
    orderBy: z
      .union([
        ListOrderByWithRelationInputSchema.array(),
        ListOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: ListWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([ListScalarFieldEnumSchema, ListScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const ListAggregateArgsSchema: z.ZodType<Prisma.ListAggregateArgs> = z
  .object({
    where: ListWhereInputSchema.optional(),
    orderBy: z
      .union([
        ListOrderByWithRelationInputSchema.array(),
        ListOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: ListWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const ListGroupByArgsSchema: z.ZodType<Prisma.ListGroupByArgs> = z
  .object({
    where: ListWhereInputSchema.optional(),
    orderBy: z
      .union([
        ListOrderByWithAggregationInputSchema.array(),
        ListOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: ListScalarFieldEnumSchema.array(),
    having: ListScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const ListFindUniqueArgsSchema: z.ZodType<Prisma.ListFindUniqueArgs> = z
  .object({
    select: ListSelectSchema.optional(),
    include: ListIncludeSchema.optional(),
    where: ListWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const ListFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.ListFindUniqueOrThrowArgs> =
  z
    .object({
      select: ListSelectSchema.optional(),
      include: ListIncludeSchema.optional(),
      where: ListWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CampaignFindFirstArgsSchema: z.ZodType<Prisma.CampaignFindFirstArgs> =
  z
    .object({
      select: CampaignSelectSchema.optional(),
      include: CampaignIncludeSchema.optional(),
      where: CampaignWhereInputSchema.optional(),
      orderBy: z
        .union([
          CampaignOrderByWithRelationInputSchema.array(),
          CampaignOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: CampaignWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CampaignScalarFieldEnumSchema,
          CampaignScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CampaignFindFirstOrThrowArgsSchema: z.ZodType<Prisma.CampaignFindFirstOrThrowArgs> =
  z
    .object({
      select: CampaignSelectSchema.optional(),
      include: CampaignIncludeSchema.optional(),
      where: CampaignWhereInputSchema.optional(),
      orderBy: z
        .union([
          CampaignOrderByWithRelationInputSchema.array(),
          CampaignOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: CampaignWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CampaignScalarFieldEnumSchema,
          CampaignScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CampaignFindManyArgsSchema: z.ZodType<Prisma.CampaignFindManyArgs> =
  z
    .object({
      select: CampaignSelectSchema.optional(),
      include: CampaignIncludeSchema.optional(),
      where: CampaignWhereInputSchema.optional(),
      orderBy: z
        .union([
          CampaignOrderByWithRelationInputSchema.array(),
          CampaignOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: CampaignWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CampaignScalarFieldEnumSchema,
          CampaignScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CampaignAggregateArgsSchema: z.ZodType<Prisma.CampaignAggregateArgs> =
  z
    .object({
      where: CampaignWhereInputSchema.optional(),
      orderBy: z
        .union([
          CampaignOrderByWithRelationInputSchema.array(),
          CampaignOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: CampaignWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const CampaignGroupByArgsSchema: z.ZodType<Prisma.CampaignGroupByArgs> =
  z
    .object({
      where: CampaignWhereInputSchema.optional(),
      orderBy: z
        .union([
          CampaignOrderByWithAggregationInputSchema.array(),
          CampaignOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: CampaignScalarFieldEnumSchema.array(),
      having: CampaignScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const CampaignFindUniqueArgsSchema: z.ZodType<Prisma.CampaignFindUniqueArgs> =
  z
    .object({
      select: CampaignSelectSchema.optional(),
      include: CampaignIncludeSchema.optional(),
      where: CampaignWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CampaignFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.CampaignFindUniqueOrThrowArgs> =
  z
    .object({
      select: CampaignSelectSchema.optional(),
      include: CampaignIncludeSchema.optional(),
      where: CampaignWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const EmailFindFirstArgsSchema: z.ZodType<Prisma.EmailFindFirstArgs> = z
  .object({
    select: EmailSelectSchema.optional(),
    include: EmailIncludeSchema.optional(),
    where: EmailWhereInputSchema.optional(),
    orderBy: z
      .union([
        EmailOrderByWithRelationInputSchema.array(),
        EmailOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: EmailWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([EmailScalarFieldEnumSchema, EmailScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const EmailFindFirstOrThrowArgsSchema: z.ZodType<Prisma.EmailFindFirstOrThrowArgs> =
  z
    .object({
      select: EmailSelectSchema.optional(),
      include: EmailIncludeSchema.optional(),
      where: EmailWhereInputSchema.optional(),
      orderBy: z
        .union([
          EmailOrderByWithRelationInputSchema.array(),
          EmailOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: EmailWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([EmailScalarFieldEnumSchema, EmailScalarFieldEnumSchema.array()])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const EmailFindManyArgsSchema: z.ZodType<Prisma.EmailFindManyArgs> = z
  .object({
    select: EmailSelectSchema.optional(),
    include: EmailIncludeSchema.optional(),
    where: EmailWhereInputSchema.optional(),
    orderBy: z
      .union([
        EmailOrderByWithRelationInputSchema.array(),
        EmailOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: EmailWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([EmailScalarFieldEnumSchema, EmailScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const EmailAggregateArgsSchema: z.ZodType<Prisma.EmailAggregateArgs> = z
  .object({
    where: EmailWhereInputSchema.optional(),
    orderBy: z
      .union([
        EmailOrderByWithRelationInputSchema.array(),
        EmailOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: EmailWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const EmailGroupByArgsSchema: z.ZodType<Prisma.EmailGroupByArgs> = z
  .object({
    where: EmailWhereInputSchema.optional(),
    orderBy: z
      .union([
        EmailOrderByWithAggregationInputSchema.array(),
        EmailOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: EmailScalarFieldEnumSchema.array(),
    having: EmailScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const EmailFindUniqueArgsSchema: z.ZodType<Prisma.EmailFindUniqueArgs> =
  z
    .object({
      select: EmailSelectSchema.optional(),
      include: EmailIncludeSchema.optional(),
      where: EmailWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const EmailFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.EmailFindUniqueOrThrowArgs> =
  z
    .object({
      select: EmailSelectSchema.optional(),
      include: EmailIncludeSchema.optional(),
      where: EmailWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const MediaFindFirstArgsSchema: z.ZodType<Prisma.MediaFindFirstArgs> = z
  .object({
    select: MediaSelectSchema.optional(),
    where: MediaWhereInputSchema.optional(),
    orderBy: z
      .union([
        MediaOrderByWithRelationInputSchema.array(),
        MediaOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: MediaWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([MediaScalarFieldEnumSchema, MediaScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const MediaFindFirstOrThrowArgsSchema: z.ZodType<Prisma.MediaFindFirstOrThrowArgs> =
  z
    .object({
      select: MediaSelectSchema.optional(),
      where: MediaWhereInputSchema.optional(),
      orderBy: z
        .union([
          MediaOrderByWithRelationInputSchema.array(),
          MediaOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: MediaWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([MediaScalarFieldEnumSchema, MediaScalarFieldEnumSchema.array()])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const MediaFindManyArgsSchema: z.ZodType<Prisma.MediaFindManyArgs> = z
  .object({
    select: MediaSelectSchema.optional(),
    where: MediaWhereInputSchema.optional(),
    orderBy: z
      .union([
        MediaOrderByWithRelationInputSchema.array(),
        MediaOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: MediaWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([MediaScalarFieldEnumSchema, MediaScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const MediaAggregateArgsSchema: z.ZodType<Prisma.MediaAggregateArgs> = z
  .object({
    where: MediaWhereInputSchema.optional(),
    orderBy: z
      .union([
        MediaOrderByWithRelationInputSchema.array(),
        MediaOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: MediaWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const MediaGroupByArgsSchema: z.ZodType<Prisma.MediaGroupByArgs> = z
  .object({
    where: MediaWhereInputSchema.optional(),
    orderBy: z
      .union([
        MediaOrderByWithAggregationInputSchema.array(),
        MediaOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: MediaScalarFieldEnumSchema.array(),
    having: MediaScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const MediaFindUniqueArgsSchema: z.ZodType<Prisma.MediaFindUniqueArgs> =
  z
    .object({
      select: MediaSelectSchema.optional(),
      where: MediaWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const MediaFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.MediaFindUniqueOrThrowArgs> =
  z
    .object({
      select: MediaSelectSchema.optional(),
      where: MediaWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ClickFindFirstArgsSchema: z.ZodType<Prisma.ClickFindFirstArgs> = z
  .object({
    select: ClickSelectSchema.optional(),
    include: ClickIncludeSchema.optional(),
    where: ClickWhereInputSchema.optional(),
    orderBy: z
      .union([
        ClickOrderByWithRelationInputSchema.array(),
        ClickOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: ClickWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([ClickScalarFieldEnumSchema, ClickScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const ClickFindFirstOrThrowArgsSchema: z.ZodType<Prisma.ClickFindFirstOrThrowArgs> =
  z
    .object({
      select: ClickSelectSchema.optional(),
      include: ClickIncludeSchema.optional(),
      where: ClickWhereInputSchema.optional(),
      orderBy: z
        .union([
          ClickOrderByWithRelationInputSchema.array(),
          ClickOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: ClickWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([ClickScalarFieldEnumSchema, ClickScalarFieldEnumSchema.array()])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ClickFindManyArgsSchema: z.ZodType<Prisma.ClickFindManyArgs> = z
  .object({
    select: ClickSelectSchema.optional(),
    include: ClickIncludeSchema.optional(),
    where: ClickWhereInputSchema.optional(),
    orderBy: z
      .union([
        ClickOrderByWithRelationInputSchema.array(),
        ClickOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: ClickWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([ClickScalarFieldEnumSchema, ClickScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const ClickAggregateArgsSchema: z.ZodType<Prisma.ClickAggregateArgs> = z
  .object({
    where: ClickWhereInputSchema.optional(),
    orderBy: z
      .union([
        ClickOrderByWithRelationInputSchema.array(),
        ClickOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: ClickWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const ClickGroupByArgsSchema: z.ZodType<Prisma.ClickGroupByArgs> = z
  .object({
    where: ClickWhereInputSchema.optional(),
    orderBy: z
      .union([
        ClickOrderByWithAggregationInputSchema.array(),
        ClickOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: ClickScalarFieldEnumSchema.array(),
    having: ClickScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const ClickFindUniqueArgsSchema: z.ZodType<Prisma.ClickFindUniqueArgs> =
  z
    .object({
      select: ClickSelectSchema.optional(),
      include: ClickIncludeSchema.optional(),
      where: ClickWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ClickFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.ClickFindUniqueOrThrowArgs> =
  z
    .object({
      select: ClickSelectSchema.optional(),
      include: ClickIncludeSchema.optional(),
      where: ClickWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const LinkFindFirstArgsSchema: z.ZodType<Prisma.LinkFindFirstArgs> = z
  .object({
    select: LinkSelectSchema.optional(),
    include: LinkIncludeSchema.optional(),
    where: LinkWhereInputSchema.optional(),
    orderBy: z
      .union([
        LinkOrderByWithRelationInputSchema.array(),
        LinkOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: LinkWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([LinkScalarFieldEnumSchema, LinkScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const LinkFindFirstOrThrowArgsSchema: z.ZodType<Prisma.LinkFindFirstOrThrowArgs> =
  z
    .object({
      select: LinkSelectSchema.optional(),
      include: LinkIncludeSchema.optional(),
      where: LinkWhereInputSchema.optional(),
      orderBy: z
        .union([
          LinkOrderByWithRelationInputSchema.array(),
          LinkOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: LinkWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([LinkScalarFieldEnumSchema, LinkScalarFieldEnumSchema.array()])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const LinkFindManyArgsSchema: z.ZodType<Prisma.LinkFindManyArgs> = z
  .object({
    select: LinkSelectSchema.optional(),
    include: LinkIncludeSchema.optional(),
    where: LinkWhereInputSchema.optional(),
    orderBy: z
      .union([
        LinkOrderByWithRelationInputSchema.array(),
        LinkOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: LinkWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([LinkScalarFieldEnumSchema, LinkScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const LinkAggregateArgsSchema: z.ZodType<Prisma.LinkAggregateArgs> = z
  .object({
    where: LinkWhereInputSchema.optional(),
    orderBy: z
      .union([
        LinkOrderByWithRelationInputSchema.array(),
        LinkOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: LinkWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const LinkGroupByArgsSchema: z.ZodType<Prisma.LinkGroupByArgs> = z
  .object({
    where: LinkWhereInputSchema.optional(),
    orderBy: z
      .union([
        LinkOrderByWithAggregationInputSchema.array(),
        LinkOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: LinkScalarFieldEnumSchema.array(),
    having: LinkScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const LinkFindUniqueArgsSchema: z.ZodType<Prisma.LinkFindUniqueArgs> = z
  .object({
    select: LinkSelectSchema.optional(),
    include: LinkIncludeSchema.optional(),
    where: LinkWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const LinkFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.LinkFindUniqueOrThrowArgs> =
  z
    .object({
      select: LinkSelectSchema.optional(),
      include: LinkIncludeSchema.optional(),
      where: LinkWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const BlockFindFirstArgsSchema: z.ZodType<Prisma.BlockFindFirstArgs> = z
  .object({
    select: BlockSelectSchema.optional(),
    include: BlockIncludeSchema.optional(),
    where: BlockWhereInputSchema.optional(),
    orderBy: z
      .union([
        BlockOrderByWithRelationInputSchema.array(),
        BlockOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: BlockWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([BlockScalarFieldEnumSchema, BlockScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const BlockFindFirstOrThrowArgsSchema: z.ZodType<Prisma.BlockFindFirstOrThrowArgs> =
  z
    .object({
      select: BlockSelectSchema.optional(),
      include: BlockIncludeSchema.optional(),
      where: BlockWhereInputSchema.optional(),
      orderBy: z
        .union([
          BlockOrderByWithRelationInputSchema.array(),
          BlockOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: BlockWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([BlockScalarFieldEnumSchema, BlockScalarFieldEnumSchema.array()])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const BlockFindManyArgsSchema: z.ZodType<Prisma.BlockFindManyArgs> = z
  .object({
    select: BlockSelectSchema.optional(),
    include: BlockIncludeSchema.optional(),
    where: BlockWhereInputSchema.optional(),
    orderBy: z
      .union([
        BlockOrderByWithRelationInputSchema.array(),
        BlockOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: BlockWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([BlockScalarFieldEnumSchema, BlockScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const BlockAggregateArgsSchema: z.ZodType<Prisma.BlockAggregateArgs> = z
  .object({
    where: BlockWhereInputSchema.optional(),
    orderBy: z
      .union([
        BlockOrderByWithRelationInputSchema.array(),
        BlockOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: BlockWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const BlockGroupByArgsSchema: z.ZodType<Prisma.BlockGroupByArgs> = z
  .object({
    where: BlockWhereInputSchema.optional(),
    orderBy: z
      .union([
        BlockOrderByWithAggregationInputSchema.array(),
        BlockOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: BlockScalarFieldEnumSchema.array(),
    having: BlockScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const BlockFindUniqueArgsSchema: z.ZodType<Prisma.BlockFindUniqueArgs> =
  z
    .object({
      select: BlockSelectSchema.optional(),
      include: BlockIncludeSchema.optional(),
      where: BlockWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const BlockFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.BlockFindUniqueOrThrowArgs> =
  z
    .object({
      select: BlockSelectSchema.optional(),
      include: BlockIncludeSchema.optional(),
      where: BlockWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const LikeFindFirstArgsSchema: z.ZodType<Prisma.LikeFindFirstArgs> = z
  .object({
    select: LikeSelectSchema.optional(),
    include: LikeIncludeSchema.optional(),
    where: LikeWhereInputSchema.optional(),
    orderBy: z
      .union([
        LikeOrderByWithRelationInputSchema.array(),
        LikeOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: LikeWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([LikeScalarFieldEnumSchema, LikeScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const LikeFindFirstOrThrowArgsSchema: z.ZodType<Prisma.LikeFindFirstOrThrowArgs> =
  z
    .object({
      select: LikeSelectSchema.optional(),
      include: LikeIncludeSchema.optional(),
      where: LikeWhereInputSchema.optional(),
      orderBy: z
        .union([
          LikeOrderByWithRelationInputSchema.array(),
          LikeOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: LikeWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([LikeScalarFieldEnumSchema, LikeScalarFieldEnumSchema.array()])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const LikeFindManyArgsSchema: z.ZodType<Prisma.LikeFindManyArgs> = z
  .object({
    select: LikeSelectSchema.optional(),
    include: LikeIncludeSchema.optional(),
    where: LikeWhereInputSchema.optional(),
    orderBy: z
      .union([
        LikeOrderByWithRelationInputSchema.array(),
        LikeOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: LikeWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([LikeScalarFieldEnumSchema, LikeScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const LikeAggregateArgsSchema: z.ZodType<Prisma.LikeAggregateArgs> = z
  .object({
    where: LikeWhereInputSchema.optional(),
    orderBy: z
      .union([
        LikeOrderByWithRelationInputSchema.array(),
        LikeOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: LikeWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const LikeGroupByArgsSchema: z.ZodType<Prisma.LikeGroupByArgs> = z
  .object({
    where: LikeWhereInputSchema.optional(),
    orderBy: z
      .union([
        LikeOrderByWithAggregationInputSchema.array(),
        LikeOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: LikeScalarFieldEnumSchema.array(),
    having: LikeScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const LikeFindUniqueArgsSchema: z.ZodType<Prisma.LikeFindUniqueArgs> = z
  .object({
    select: LikeSelectSchema.optional(),
    include: LikeIncludeSchema.optional(),
    where: LikeWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const LikeFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.LikeFindUniqueOrThrowArgs> =
  z
    .object({
      select: LikeSelectSchema.optional(),
      include: LikeIncludeSchema.optional(),
      where: LikeWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SiteFindFirstArgsSchema: z.ZodType<Prisma.SiteFindFirstArgs> = z
  .object({
    select: SiteSelectSchema.optional(),
    include: SiteIncludeSchema.optional(),
    where: SiteWhereInputSchema.optional(),
    orderBy: z
      .union([
        SiteOrderByWithRelationInputSchema.array(),
        SiteOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: SiteWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([SiteScalarFieldEnumSchema, SiteScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const SiteFindFirstOrThrowArgsSchema: z.ZodType<Prisma.SiteFindFirstOrThrowArgs> =
  z
    .object({
      select: SiteSelectSchema.optional(),
      include: SiteIncludeSchema.optional(),
      where: SiteWhereInputSchema.optional(),
      orderBy: z
        .union([
          SiteOrderByWithRelationInputSchema.array(),
          SiteOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: SiteWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([SiteScalarFieldEnumSchema, SiteScalarFieldEnumSchema.array()])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SiteFindManyArgsSchema: z.ZodType<Prisma.SiteFindManyArgs> = z
  .object({
    select: SiteSelectSchema.optional(),
    include: SiteIncludeSchema.optional(),
    where: SiteWhereInputSchema.optional(),
    orderBy: z
      .union([
        SiteOrderByWithRelationInputSchema.array(),
        SiteOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: SiteWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([SiteScalarFieldEnumSchema, SiteScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const SiteAggregateArgsSchema: z.ZodType<Prisma.SiteAggregateArgs> = z
  .object({
    where: SiteWhereInputSchema.optional(),
    orderBy: z
      .union([
        SiteOrderByWithRelationInputSchema.array(),
        SiteOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: SiteWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const SiteGroupByArgsSchema: z.ZodType<Prisma.SiteGroupByArgs> = z
  .object({
    where: SiteWhereInputSchema.optional(),
    orderBy: z
      .union([
        SiteOrderByWithAggregationInputSchema.array(),
        SiteOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: SiteScalarFieldEnumSchema.array(),
    having: SiteScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const SiteFindUniqueArgsSchema: z.ZodType<Prisma.SiteFindUniqueArgs> = z
  .object({
    select: SiteSelectSchema.optional(),
    include: SiteIncludeSchema.optional(),
    where: SiteWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const SiteFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.SiteFindUniqueOrThrowArgs> =
  z
    .object({
      select: SiteSelectSchema.optional(),
      include: SiteIncludeSchema.optional(),
      where: SiteWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SubscriberFindFirstArgsSchema: z.ZodType<Prisma.SubscriberFindFirstArgs> =
  z
    .object({
      select: SubscriberSelectSchema.optional(),
      include: SubscriberIncludeSchema.optional(),
      where: SubscriberWhereInputSchema.optional(),
      orderBy: z
        .union([
          SubscriberOrderByWithRelationInputSchema.array(),
          SubscriberOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: SubscriberWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          SubscriberScalarFieldEnumSchema,
          SubscriberScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SubscriberFindFirstOrThrowArgsSchema: z.ZodType<Prisma.SubscriberFindFirstOrThrowArgs> =
  z
    .object({
      select: SubscriberSelectSchema.optional(),
      include: SubscriberIncludeSchema.optional(),
      where: SubscriberWhereInputSchema.optional(),
      orderBy: z
        .union([
          SubscriberOrderByWithRelationInputSchema.array(),
          SubscriberOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: SubscriberWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          SubscriberScalarFieldEnumSchema,
          SubscriberScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SubscriberFindManyArgsSchema: z.ZodType<Prisma.SubscriberFindManyArgs> =
  z
    .object({
      select: SubscriberSelectSchema.optional(),
      include: SubscriberIncludeSchema.optional(),
      where: SubscriberWhereInputSchema.optional(),
      orderBy: z
        .union([
          SubscriberOrderByWithRelationInputSchema.array(),
          SubscriberOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: SubscriberWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          SubscriberScalarFieldEnumSchema,
          SubscriberScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SubscriberAggregateArgsSchema: z.ZodType<Prisma.SubscriberAggregateArgs> =
  z
    .object({
      where: SubscriberWhereInputSchema.optional(),
      orderBy: z
        .union([
          SubscriberOrderByWithRelationInputSchema.array(),
          SubscriberOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: SubscriberWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const SubscriberGroupByArgsSchema: z.ZodType<Prisma.SubscriberGroupByArgs> =
  z
    .object({
      where: SubscriberWhereInputSchema.optional(),
      orderBy: z
        .union([
          SubscriberOrderByWithAggregationInputSchema.array(),
          SubscriberOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: SubscriberScalarFieldEnumSchema.array(),
      having: SubscriberScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const SubscriberFindUniqueArgsSchema: z.ZodType<Prisma.SubscriberFindUniqueArgs> =
  z
    .object({
      select: SubscriberSelectSchema.optional(),
      include: SubscriberIncludeSchema.optional(),
      where: SubscriberWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SubscriberFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.SubscriberFindUniqueOrThrowArgs> =
  z
    .object({
      select: SubscriberSelectSchema.optional(),
      include: SubscriberIncludeSchema.optional(),
      where: SubscriberWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ReservationFindFirstArgsSchema: z.ZodType<Prisma.ReservationFindFirstArgs> =
  z
    .object({
      select: ReservationSelectSchema.optional(),
      include: ReservationIncludeSchema.optional(),
      where: ReservationWhereInputSchema.optional(),
      orderBy: z
        .union([
          ReservationOrderByWithRelationInputSchema.array(),
          ReservationOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: ReservationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ReservationScalarFieldEnumSchema,
          ReservationScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ReservationFindFirstOrThrowArgsSchema: z.ZodType<Prisma.ReservationFindFirstOrThrowArgs> =
  z
    .object({
      select: ReservationSelectSchema.optional(),
      include: ReservationIncludeSchema.optional(),
      where: ReservationWhereInputSchema.optional(),
      orderBy: z
        .union([
          ReservationOrderByWithRelationInputSchema.array(),
          ReservationOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: ReservationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ReservationScalarFieldEnumSchema,
          ReservationScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ReservationFindManyArgsSchema: z.ZodType<Prisma.ReservationFindManyArgs> =
  z
    .object({
      select: ReservationSelectSchema.optional(),
      include: ReservationIncludeSchema.optional(),
      where: ReservationWhereInputSchema.optional(),
      orderBy: z
        .union([
          ReservationOrderByWithRelationInputSchema.array(),
          ReservationOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: ReservationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ReservationScalarFieldEnumSchema,
          ReservationScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ReservationAggregateArgsSchema: z.ZodType<Prisma.ReservationAggregateArgs> =
  z
    .object({
      where: ReservationWhereInputSchema.optional(),
      orderBy: z
        .union([
          ReservationOrderByWithRelationInputSchema.array(),
          ReservationOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: ReservationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const ReservationGroupByArgsSchema: z.ZodType<Prisma.ReservationGroupByArgs> =
  z
    .object({
      where: ReservationWhereInputSchema.optional(),
      orderBy: z
        .union([
          ReservationOrderByWithAggregationInputSchema.array(),
          ReservationOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: ReservationScalarFieldEnumSchema.array(),
      having: ReservationScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const ReservationFindUniqueArgsSchema: z.ZodType<Prisma.ReservationFindUniqueArgs> =
  z
    .object({
      select: ReservationSelectSchema.optional(),
      include: ReservationIncludeSchema.optional(),
      where: ReservationWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ReservationFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.ReservationFindUniqueOrThrowArgs> =
  z
    .object({
      select: ReservationSelectSchema.optional(),
      include: ReservationIncludeSchema.optional(),
      where: ReservationWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CategoryFindFirstArgsSchema: z.ZodType<Prisma.CategoryFindFirstArgs> =
  z
    .object({
      select: CategorySelectSchema.optional(),
      include: CategoryIncludeSchema.optional(),
      where: CategoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          CategoryOrderByWithRelationInputSchema.array(),
          CategoryOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: CategoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CategoryScalarFieldEnumSchema,
          CategoryScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CategoryFindFirstOrThrowArgsSchema: z.ZodType<Prisma.CategoryFindFirstOrThrowArgs> =
  z
    .object({
      select: CategorySelectSchema.optional(),
      include: CategoryIncludeSchema.optional(),
      where: CategoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          CategoryOrderByWithRelationInputSchema.array(),
          CategoryOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: CategoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CategoryScalarFieldEnumSchema,
          CategoryScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CategoryFindManyArgsSchema: z.ZodType<Prisma.CategoryFindManyArgs> =
  z
    .object({
      select: CategorySelectSchema.optional(),
      include: CategoryIncludeSchema.optional(),
      where: CategoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          CategoryOrderByWithRelationInputSchema.array(),
          CategoryOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: CategoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CategoryScalarFieldEnumSchema,
          CategoryScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CategoryAggregateArgsSchema: z.ZodType<Prisma.CategoryAggregateArgs> =
  z
    .object({
      where: CategoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          CategoryOrderByWithRelationInputSchema.array(),
          CategoryOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: CategoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const CategoryGroupByArgsSchema: z.ZodType<Prisma.CategoryGroupByArgs> =
  z
    .object({
      where: CategoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          CategoryOrderByWithAggregationInputSchema.array(),
          CategoryOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: CategoryScalarFieldEnumSchema.array(),
      having: CategoryScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const CategoryFindUniqueArgsSchema: z.ZodType<Prisma.CategoryFindUniqueArgs> =
  z
    .object({
      select: CategorySelectSchema.optional(),
      include: CategoryIncludeSchema.optional(),
      where: CategoryWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CategoryFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.CategoryFindUniqueOrThrowArgs> =
  z
    .object({
      select: CategorySelectSchema.optional(),
      include: CategoryIncludeSchema.optional(),
      where: CategoryWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const InventoryFindFirstArgsSchema: z.ZodType<Prisma.InventoryFindFirstArgs> =
  z
    .object({
      select: InventorySelectSchema.optional(),
      include: InventoryIncludeSchema.optional(),
      where: InventoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          InventoryOrderByWithRelationInputSchema.array(),
          InventoryOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: InventoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          InventoryScalarFieldEnumSchema,
          InventoryScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const InventoryFindFirstOrThrowArgsSchema: z.ZodType<Prisma.InventoryFindFirstOrThrowArgs> =
  z
    .object({
      select: InventorySelectSchema.optional(),
      include: InventoryIncludeSchema.optional(),
      where: InventoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          InventoryOrderByWithRelationInputSchema.array(),
          InventoryOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: InventoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          InventoryScalarFieldEnumSchema,
          InventoryScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const InventoryFindManyArgsSchema: z.ZodType<Prisma.InventoryFindManyArgs> =
  z
    .object({
      select: InventorySelectSchema.optional(),
      include: InventoryIncludeSchema.optional(),
      where: InventoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          InventoryOrderByWithRelationInputSchema.array(),
          InventoryOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: InventoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          InventoryScalarFieldEnumSchema,
          InventoryScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const InventoryAggregateArgsSchema: z.ZodType<Prisma.InventoryAggregateArgs> =
  z
    .object({
      where: InventoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          InventoryOrderByWithRelationInputSchema.array(),
          InventoryOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: InventoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const InventoryGroupByArgsSchema: z.ZodType<Prisma.InventoryGroupByArgs> =
  z
    .object({
      where: InventoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          InventoryOrderByWithAggregationInputSchema.array(),
          InventoryOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: InventoryScalarFieldEnumSchema.array(),
      having: InventoryScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const InventoryFindUniqueArgsSchema: z.ZodType<Prisma.InventoryFindUniqueArgs> =
  z
    .object({
      select: InventorySelectSchema.optional(),
      include: InventoryIncludeSchema.optional(),
      where: InventoryWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const InventoryFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.InventoryFindUniqueOrThrowArgs> =
  z
    .object({
      select: InventorySelectSchema.optional(),
      include: InventoryIncludeSchema.optional(),
      where: InventoryWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const InventoryVariantFindFirstArgsSchema: z.ZodType<Prisma.InventoryVariantFindFirstArgs> =
  z
    .object({
      select: InventoryVariantSelectSchema.optional(),
      include: InventoryVariantIncludeSchema.optional(),
      where: InventoryVariantWhereInputSchema.optional(),
      orderBy: z
        .union([
          InventoryVariantOrderByWithRelationInputSchema.array(),
          InventoryVariantOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: InventoryVariantWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          InventoryVariantScalarFieldEnumSchema,
          InventoryVariantScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const InventoryVariantFindFirstOrThrowArgsSchema: z.ZodType<Prisma.InventoryVariantFindFirstOrThrowArgs> =
  z
    .object({
      select: InventoryVariantSelectSchema.optional(),
      include: InventoryVariantIncludeSchema.optional(),
      where: InventoryVariantWhereInputSchema.optional(),
      orderBy: z
        .union([
          InventoryVariantOrderByWithRelationInputSchema.array(),
          InventoryVariantOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: InventoryVariantWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          InventoryVariantScalarFieldEnumSchema,
          InventoryVariantScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const InventoryVariantFindManyArgsSchema: z.ZodType<Prisma.InventoryVariantFindManyArgs> =
  z
    .object({
      select: InventoryVariantSelectSchema.optional(),
      include: InventoryVariantIncludeSchema.optional(),
      where: InventoryVariantWhereInputSchema.optional(),
      orderBy: z
        .union([
          InventoryVariantOrderByWithRelationInputSchema.array(),
          InventoryVariantOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: InventoryVariantWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          InventoryVariantScalarFieldEnumSchema,
          InventoryVariantScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const InventoryVariantAggregateArgsSchema: z.ZodType<Prisma.InventoryVariantAggregateArgs> =
  z
    .object({
      where: InventoryVariantWhereInputSchema.optional(),
      orderBy: z
        .union([
          InventoryVariantOrderByWithRelationInputSchema.array(),
          InventoryVariantOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: InventoryVariantWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const InventoryVariantGroupByArgsSchema: z.ZodType<Prisma.InventoryVariantGroupByArgs> =
  z
    .object({
      where: InventoryVariantWhereInputSchema.optional(),
      orderBy: z
        .union([
          InventoryVariantOrderByWithAggregationInputSchema.array(),
          InventoryVariantOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: InventoryVariantScalarFieldEnumSchema.array(),
      having: InventoryVariantScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const InventoryVariantFindUniqueArgsSchema: z.ZodType<Prisma.InventoryVariantFindUniqueArgs> =
  z
    .object({
      select: InventoryVariantSelectSchema.optional(),
      include: InventoryVariantIncludeSchema.optional(),
      where: InventoryVariantWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const InventoryVariantFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.InventoryVariantFindUniqueOrThrowArgs> =
  z
    .object({
      select: InventoryVariantSelectSchema.optional(),
      include: InventoryVariantIncludeSchema.optional(),
      where: InventoryVariantWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CronFindFirstArgsSchema: z.ZodType<Prisma.CronFindFirstArgs> = z
  .object({
    select: CronSelectSchema.optional(),
    include: CronIncludeSchema.optional(),
    where: CronWhereInputSchema.optional(),
    orderBy: z
      .union([
        CronOrderByWithRelationInputSchema.array(),
        CronOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: CronWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([CronScalarFieldEnumSchema, CronScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CronFindFirstOrThrowArgsSchema: z.ZodType<Prisma.CronFindFirstOrThrowArgs> =
  z
    .object({
      select: CronSelectSchema.optional(),
      include: CronIncludeSchema.optional(),
      where: CronWhereInputSchema.optional(),
      orderBy: z
        .union([
          CronOrderByWithRelationInputSchema.array(),
          CronOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: CronWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([CronScalarFieldEnumSchema, CronScalarFieldEnumSchema.array()])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const CronFindManyArgsSchema: z.ZodType<Prisma.CronFindManyArgs> = z
  .object({
    select: CronSelectSchema.optional(),
    include: CronIncludeSchema.optional(),
    where: CronWhereInputSchema.optional(),
    orderBy: z
      .union([
        CronOrderByWithRelationInputSchema.array(),
        CronOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: CronWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([CronScalarFieldEnumSchema, CronScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CronAggregateArgsSchema: z.ZodType<Prisma.CronAggregateArgs> = z
  .object({
    where: CronWhereInputSchema.optional(),
    orderBy: z
      .union([
        CronOrderByWithRelationInputSchema.array(),
        CronOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: CronWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const CronGroupByArgsSchema: z.ZodType<Prisma.CronGroupByArgs> = z
  .object({
    where: CronWhereInputSchema.optional(),
    orderBy: z
      .union([
        CronOrderByWithAggregationInputSchema.array(),
        CronOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: CronScalarFieldEnumSchema.array(),
    having: CronScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const CronFindUniqueArgsSchema: z.ZodType<Prisma.CronFindUniqueArgs> = z
  .object({
    select: CronSelectSchema.optional(),
    include: CronIncludeSchema.optional(),
    where: CronWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CronFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.CronFindUniqueOrThrowArgs> =
  z
    .object({
      select: CronSelectSchema.optional(),
      include: CronIncludeSchema.optional(),
      where: CronWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const HistoryFindFirstArgsSchema: z.ZodType<Prisma.HistoryFindFirstArgs> =
  z
    .object({
      select: HistorySelectSchema.optional(),
      include: HistoryIncludeSchema.optional(),
      where: HistoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          HistoryOrderByWithRelationInputSchema.array(),
          HistoryOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: HistoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          HistoryScalarFieldEnumSchema,
          HistoryScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const HistoryFindFirstOrThrowArgsSchema: z.ZodType<Prisma.HistoryFindFirstOrThrowArgs> =
  z
    .object({
      select: HistorySelectSchema.optional(),
      include: HistoryIncludeSchema.optional(),
      where: HistoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          HistoryOrderByWithRelationInputSchema.array(),
          HistoryOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: HistoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          HistoryScalarFieldEnumSchema,
          HistoryScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const HistoryFindManyArgsSchema: z.ZodType<Prisma.HistoryFindManyArgs> =
  z
    .object({
      select: HistorySelectSchema.optional(),
      include: HistoryIncludeSchema.optional(),
      where: HistoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          HistoryOrderByWithRelationInputSchema.array(),
          HistoryOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: HistoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          HistoryScalarFieldEnumSchema,
          HistoryScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const HistoryAggregateArgsSchema: z.ZodType<Prisma.HistoryAggregateArgs> =
  z
    .object({
      where: HistoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          HistoryOrderByWithRelationInputSchema.array(),
          HistoryOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: HistoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const HistoryGroupByArgsSchema: z.ZodType<Prisma.HistoryGroupByArgs> = z
  .object({
    where: HistoryWhereInputSchema.optional(),
    orderBy: z
      .union([
        HistoryOrderByWithAggregationInputSchema.array(),
        HistoryOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: HistoryScalarFieldEnumSchema.array(),
    having: HistoryScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const HistoryFindUniqueArgsSchema: z.ZodType<Prisma.HistoryFindUniqueArgs> =
  z
    .object({
      select: HistorySelectSchema.optional(),
      include: HistoryIncludeSchema.optional(),
      where: HistoryWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const HistoryFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.HistoryFindUniqueOrThrowArgs> =
  z
    .object({
      select: HistorySelectSchema.optional(),
      include: HistoryIncludeSchema.optional(),
      where: HistoryWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const UserFindFirstArgsSchema: z.ZodType<Prisma.UserFindFirstArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    where: UserWhereInputSchema.optional(),
    orderBy: z
      .union([
        UserOrderByWithRelationInputSchema.array(),
        UserOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: UserWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([UserScalarFieldEnumSchema, UserScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const UserFindFirstOrThrowArgsSchema: z.ZodType<Prisma.UserFindFirstOrThrowArgs> =
  z
    .object({
      select: UserSelectSchema.optional(),
      include: UserIncludeSchema.optional(),
      where: UserWhereInputSchema.optional(),
      orderBy: z
        .union([
          UserOrderByWithRelationInputSchema.array(),
          UserOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: UserWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([UserScalarFieldEnumSchema, UserScalarFieldEnumSchema.array()])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const UserFindManyArgsSchema: z.ZodType<Prisma.UserFindManyArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    where: UserWhereInputSchema.optional(),
    orderBy: z
      .union([
        UserOrderByWithRelationInputSchema.array(),
        UserOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: UserWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([UserScalarFieldEnumSchema, UserScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const UserAggregateArgsSchema: z.ZodType<Prisma.UserAggregateArgs> = z
  .object({
    where: UserWhereInputSchema.optional(),
    orderBy: z
      .union([
        UserOrderByWithRelationInputSchema.array(),
        UserOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: UserWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const UserGroupByArgsSchema: z.ZodType<Prisma.UserGroupByArgs> = z
  .object({
    where: UserWhereInputSchema.optional(),
    orderBy: z
      .union([
        UserOrderByWithAggregationInputSchema.array(),
        UserOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: UserScalarFieldEnumSchema.array(),
    having: UserScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const UserFindUniqueArgsSchema: z.ZodType<Prisma.UserFindUniqueArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    where: UserWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const UserFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.UserFindUniqueOrThrowArgs> =
  z
    .object({
      select: UserSelectSchema.optional(),
      include: UserIncludeSchema.optional(),
      where: UserWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const MessageFindFirstArgsSchema: z.ZodType<Prisma.MessageFindFirstArgs> =
  z
    .object({
      select: MessageSelectSchema.optional(),
      include: MessageIncludeSchema.optional(),
      where: MessageWhereInputSchema.optional(),
      orderBy: z
        .union([
          MessageOrderByWithRelationInputSchema.array(),
          MessageOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: MessageWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          MessageScalarFieldEnumSchema,
          MessageScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const MessageFindFirstOrThrowArgsSchema: z.ZodType<Prisma.MessageFindFirstOrThrowArgs> =
  z
    .object({
      select: MessageSelectSchema.optional(),
      include: MessageIncludeSchema.optional(),
      where: MessageWhereInputSchema.optional(),
      orderBy: z
        .union([
          MessageOrderByWithRelationInputSchema.array(),
          MessageOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: MessageWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          MessageScalarFieldEnumSchema,
          MessageScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const MessageFindManyArgsSchema: z.ZodType<Prisma.MessageFindManyArgs> =
  z
    .object({
      select: MessageSelectSchema.optional(),
      include: MessageIncludeSchema.optional(),
      where: MessageWhereInputSchema.optional(),
      orderBy: z
        .union([
          MessageOrderByWithRelationInputSchema.array(),
          MessageOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: MessageWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          MessageScalarFieldEnumSchema,
          MessageScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const MessageAggregateArgsSchema: z.ZodType<Prisma.MessageAggregateArgs> =
  z
    .object({
      where: MessageWhereInputSchema.optional(),
      orderBy: z
        .union([
          MessageOrderByWithRelationInputSchema.array(),
          MessageOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: MessageWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const MessageGroupByArgsSchema: z.ZodType<Prisma.MessageGroupByArgs> = z
  .object({
    where: MessageWhereInputSchema.optional(),
    orderBy: z
      .union([
        MessageOrderByWithAggregationInputSchema.array(),
        MessageOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: MessageScalarFieldEnumSchema.array(),
    having: MessageScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const MessageFindUniqueArgsSchema: z.ZodType<Prisma.MessageFindUniqueArgs> =
  z
    .object({
      select: MessageSelectSchema.optional(),
      include: MessageIncludeSchema.optional(),
      where: MessageWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const MessageFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.MessageFindUniqueOrThrowArgs> =
  z
    .object({
      select: MessageSelectSchema.optional(),
      include: MessageIncludeSchema.optional(),
      where: MessageWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const FeedbackFindFirstArgsSchema: z.ZodType<Prisma.FeedbackFindFirstArgs> =
  z
    .object({
      select: FeedbackSelectSchema.optional(),
      include: FeedbackIncludeSchema.optional(),
      where: FeedbackWhereInputSchema.optional(),
      orderBy: z
        .union([
          FeedbackOrderByWithRelationInputSchema.array(),
          FeedbackOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: FeedbackWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          FeedbackScalarFieldEnumSchema,
          FeedbackScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const FeedbackFindFirstOrThrowArgsSchema: z.ZodType<Prisma.FeedbackFindFirstOrThrowArgs> =
  z
    .object({
      select: FeedbackSelectSchema.optional(),
      include: FeedbackIncludeSchema.optional(),
      where: FeedbackWhereInputSchema.optional(),
      orderBy: z
        .union([
          FeedbackOrderByWithRelationInputSchema.array(),
          FeedbackOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: FeedbackWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          FeedbackScalarFieldEnumSchema,
          FeedbackScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const FeedbackFindManyArgsSchema: z.ZodType<Prisma.FeedbackFindManyArgs> =
  z
    .object({
      select: FeedbackSelectSchema.optional(),
      include: FeedbackIncludeSchema.optional(),
      where: FeedbackWhereInputSchema.optional(),
      orderBy: z
        .union([
          FeedbackOrderByWithRelationInputSchema.array(),
          FeedbackOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: FeedbackWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          FeedbackScalarFieldEnumSchema,
          FeedbackScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const FeedbackAggregateArgsSchema: z.ZodType<Prisma.FeedbackAggregateArgs> =
  z
    .object({
      where: FeedbackWhereInputSchema.optional(),
      orderBy: z
        .union([
          FeedbackOrderByWithRelationInputSchema.array(),
          FeedbackOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: FeedbackWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const FeedbackGroupByArgsSchema: z.ZodType<Prisma.FeedbackGroupByArgs> =
  z
    .object({
      where: FeedbackWhereInputSchema.optional(),
      orderBy: z
        .union([
          FeedbackOrderByWithAggregationInputSchema.array(),
          FeedbackOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: FeedbackScalarFieldEnumSchema.array(),
      having: FeedbackScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const FeedbackFindUniqueArgsSchema: z.ZodType<Prisma.FeedbackFindUniqueArgs> =
  z
    .object({
      select: FeedbackSelectSchema.optional(),
      include: FeedbackIncludeSchema.optional(),
      where: FeedbackWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const FeedbackFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.FeedbackFindUniqueOrThrowArgs> =
  z
    .object({
      select: FeedbackSelectSchema.optional(),
      include: FeedbackIncludeSchema.optional(),
      where: FeedbackWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const QueueFindFirstArgsSchema: z.ZodType<Prisma.QueueFindFirstArgs> = z
  .object({
    select: QueueSelectSchema.optional(),
    include: QueueIncludeSchema.optional(),
    where: QueueWhereInputSchema.optional(),
    orderBy: z
      .union([
        QueueOrderByWithRelationInputSchema.array(),
        QueueOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: QueueWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([QueueScalarFieldEnumSchema, QueueScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const QueueFindFirstOrThrowArgsSchema: z.ZodType<Prisma.QueueFindFirstOrThrowArgs> =
  z
    .object({
      select: QueueSelectSchema.optional(),
      include: QueueIncludeSchema.optional(),
      where: QueueWhereInputSchema.optional(),
      orderBy: z
        .union([
          QueueOrderByWithRelationInputSchema.array(),
          QueueOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: QueueWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([QueueScalarFieldEnumSchema, QueueScalarFieldEnumSchema.array()])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const QueueFindManyArgsSchema: z.ZodType<Prisma.QueueFindManyArgs> = z
  .object({
    select: QueueSelectSchema.optional(),
    include: QueueIncludeSchema.optional(),
    where: QueueWhereInputSchema.optional(),
    orderBy: z
      .union([
        QueueOrderByWithRelationInputSchema.array(),
        QueueOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: QueueWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([QueueScalarFieldEnumSchema, QueueScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const QueueAggregateArgsSchema: z.ZodType<Prisma.QueueAggregateArgs> = z
  .object({
    where: QueueWhereInputSchema.optional(),
    orderBy: z
      .union([
        QueueOrderByWithRelationInputSchema.array(),
        QueueOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: QueueWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const QueueGroupByArgsSchema: z.ZodType<Prisma.QueueGroupByArgs> = z
  .object({
    where: QueueWhereInputSchema.optional(),
    orderBy: z
      .union([
        QueueOrderByWithAggregationInputSchema.array(),
        QueueOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: QueueScalarFieldEnumSchema.array(),
    having: QueueScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const QueueFindUniqueArgsSchema: z.ZodType<Prisma.QueueFindUniqueArgs> =
  z
    .object({
      select: QueueSelectSchema.optional(),
      include: QueueIncludeSchema.optional(),
      where: QueueWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const QueueFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.QueueFindUniqueOrThrowArgs> =
  z
    .object({
      select: QueueSelectSchema.optional(),
      include: QueueIncludeSchema.optional(),
      where: QueueWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ActionFindFirstArgsSchema: z.ZodType<Prisma.ActionFindFirstArgs> =
  z
    .object({
      select: ActionSelectSchema.optional(),
      include: ActionIncludeSchema.optional(),
      where: ActionWhereInputSchema.optional(),
      orderBy: z
        .union([
          ActionOrderByWithRelationInputSchema.array(),
          ActionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: ActionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ActionScalarFieldEnumSchema,
          ActionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ActionFindFirstOrThrowArgsSchema: z.ZodType<Prisma.ActionFindFirstOrThrowArgs> =
  z
    .object({
      select: ActionSelectSchema.optional(),
      include: ActionIncludeSchema.optional(),
      where: ActionWhereInputSchema.optional(),
      orderBy: z
        .union([
          ActionOrderByWithRelationInputSchema.array(),
          ActionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: ActionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ActionScalarFieldEnumSchema,
          ActionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ActionFindManyArgsSchema: z.ZodType<Prisma.ActionFindManyArgs> = z
  .object({
    select: ActionSelectSchema.optional(),
    include: ActionIncludeSchema.optional(),
    where: ActionWhereInputSchema.optional(),
    orderBy: z
      .union([
        ActionOrderByWithRelationInputSchema.array(),
        ActionOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: ActionWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([ActionScalarFieldEnumSchema, ActionScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const ActionAggregateArgsSchema: z.ZodType<Prisma.ActionAggregateArgs> =
  z
    .object({
      where: ActionWhereInputSchema.optional(),
      orderBy: z
        .union([
          ActionOrderByWithRelationInputSchema.array(),
          ActionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: ActionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const ActionGroupByArgsSchema: z.ZodType<Prisma.ActionGroupByArgs> = z
  .object({
    where: ActionWhereInputSchema.optional(),
    orderBy: z
      .union([
        ActionOrderByWithAggregationInputSchema.array(),
        ActionOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: ActionScalarFieldEnumSchema.array(),
    having: ActionScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const ActionFindUniqueArgsSchema: z.ZodType<Prisma.ActionFindUniqueArgs> =
  z
    .object({
      select: ActionSelectSchema.optional(),
      include: ActionIncludeSchema.optional(),
      where: ActionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ActionFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.ActionFindUniqueOrThrowArgs> =
  z
    .object({
      select: ActionSelectSchema.optional(),
      include: ActionIncludeSchema.optional(),
      where: ActionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const WorkflowFindFirstArgsSchema: z.ZodType<Prisma.WorkflowFindFirstArgs> =
  z
    .object({
      select: WorkflowSelectSchema.optional(),
      include: WorkflowIncludeSchema.optional(),
      where: WorkflowWhereInputSchema.optional(),
      orderBy: z
        .union([
          WorkflowOrderByWithRelationInputSchema.array(),
          WorkflowOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: WorkflowWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          WorkflowScalarFieldEnumSchema,
          WorkflowScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const WorkflowFindFirstOrThrowArgsSchema: z.ZodType<Prisma.WorkflowFindFirstOrThrowArgs> =
  z
    .object({
      select: WorkflowSelectSchema.optional(),
      include: WorkflowIncludeSchema.optional(),
      where: WorkflowWhereInputSchema.optional(),
      orderBy: z
        .union([
          WorkflowOrderByWithRelationInputSchema.array(),
          WorkflowOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: WorkflowWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          WorkflowScalarFieldEnumSchema,
          WorkflowScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const WorkflowFindManyArgsSchema: z.ZodType<Prisma.WorkflowFindManyArgs> =
  z
    .object({
      select: WorkflowSelectSchema.optional(),
      include: WorkflowIncludeSchema.optional(),
      where: WorkflowWhereInputSchema.optional(),
      orderBy: z
        .union([
          WorkflowOrderByWithRelationInputSchema.array(),
          WorkflowOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: WorkflowWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          WorkflowScalarFieldEnumSchema,
          WorkflowScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const WorkflowAggregateArgsSchema: z.ZodType<Prisma.WorkflowAggregateArgs> =
  z
    .object({
      where: WorkflowWhereInputSchema.optional(),
      orderBy: z
        .union([
          WorkflowOrderByWithRelationInputSchema.array(),
          WorkflowOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: WorkflowWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const WorkflowGroupByArgsSchema: z.ZodType<Prisma.WorkflowGroupByArgs> =
  z
    .object({
      where: WorkflowWhereInputSchema.optional(),
      orderBy: z
        .union([
          WorkflowOrderByWithAggregationInputSchema.array(),
          WorkflowOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: WorkflowScalarFieldEnumSchema.array(),
      having: WorkflowScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const WorkflowFindUniqueArgsSchema: z.ZodType<Prisma.WorkflowFindUniqueArgs> =
  z
    .object({
      select: WorkflowSelectSchema.optional(),
      include: WorkflowIncludeSchema.optional(),
      where: WorkflowWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const WorkflowFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.WorkflowFindUniqueOrThrowArgs> =
  z
    .object({
      select: WorkflowSelectSchema.optional(),
      include: WorkflowIncludeSchema.optional(),
      where: WorkflowWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TriggerFindFirstArgsSchema: z.ZodType<Prisma.TriggerFindFirstArgs> =
  z
    .object({
      select: TriggerSelectSchema.optional(),
      include: TriggerIncludeSchema.optional(),
      where: TriggerWhereInputSchema.optional(),
      orderBy: z
        .union([
          TriggerOrderByWithRelationInputSchema.array(),
          TriggerOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: TriggerWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          TriggerScalarFieldEnumSchema,
          TriggerScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TriggerFindFirstOrThrowArgsSchema: z.ZodType<Prisma.TriggerFindFirstOrThrowArgs> =
  z
    .object({
      select: TriggerSelectSchema.optional(),
      include: TriggerIncludeSchema.optional(),
      where: TriggerWhereInputSchema.optional(),
      orderBy: z
        .union([
          TriggerOrderByWithRelationInputSchema.array(),
          TriggerOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: TriggerWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          TriggerScalarFieldEnumSchema,
          TriggerScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TriggerFindManyArgsSchema: z.ZodType<Prisma.TriggerFindManyArgs> =
  z
    .object({
      select: TriggerSelectSchema.optional(),
      include: TriggerIncludeSchema.optional(),
      where: TriggerWhereInputSchema.optional(),
      orderBy: z
        .union([
          TriggerOrderByWithRelationInputSchema.array(),
          TriggerOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: TriggerWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          TriggerScalarFieldEnumSchema,
          TriggerScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TriggerAggregateArgsSchema: z.ZodType<Prisma.TriggerAggregateArgs> =
  z
    .object({
      where: TriggerWhereInputSchema.optional(),
      orderBy: z
        .union([
          TriggerOrderByWithRelationInputSchema.array(),
          TriggerOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: TriggerWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const TriggerGroupByArgsSchema: z.ZodType<Prisma.TriggerGroupByArgs> = z
  .object({
    where: TriggerWhereInputSchema.optional(),
    orderBy: z
      .union([
        TriggerOrderByWithAggregationInputSchema.array(),
        TriggerOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: TriggerScalarFieldEnumSchema.array(),
    having: TriggerScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const TriggerFindUniqueArgsSchema: z.ZodType<Prisma.TriggerFindUniqueArgs> =
  z
    .object({
      select: TriggerSelectSchema.optional(),
      include: TriggerIncludeSchema.optional(),
      where: TriggerWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TriggerFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.TriggerFindUniqueOrThrowArgs> =
  z
    .object({
      select: TriggerSelectSchema.optional(),
      include: TriggerIncludeSchema.optional(),
      where: TriggerWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const RuleFindFirstArgsSchema: z.ZodType<Prisma.RuleFindFirstArgs> = z
  .object({
    select: RuleSelectSchema.optional(),
    include: RuleIncludeSchema.optional(),
    where: RuleWhereInputSchema.optional(),
    orderBy: z
      .union([
        RuleOrderByWithRelationInputSchema.array(),
        RuleOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: RuleWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([RuleScalarFieldEnumSchema, RuleScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const RuleFindFirstOrThrowArgsSchema: z.ZodType<Prisma.RuleFindFirstOrThrowArgs> =
  z
    .object({
      select: RuleSelectSchema.optional(),
      include: RuleIncludeSchema.optional(),
      where: RuleWhereInputSchema.optional(),
      orderBy: z
        .union([
          RuleOrderByWithRelationInputSchema.array(),
          RuleOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: RuleWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([RuleScalarFieldEnumSchema, RuleScalarFieldEnumSchema.array()])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const RuleFindManyArgsSchema: z.ZodType<Prisma.RuleFindManyArgs> = z
  .object({
    select: RuleSelectSchema.optional(),
    include: RuleIncludeSchema.optional(),
    where: RuleWhereInputSchema.optional(),
    orderBy: z
      .union([
        RuleOrderByWithRelationInputSchema.array(),
        RuleOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: RuleWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([RuleScalarFieldEnumSchema, RuleScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const RuleAggregateArgsSchema: z.ZodType<Prisma.RuleAggregateArgs> = z
  .object({
    where: RuleWhereInputSchema.optional(),
    orderBy: z
      .union([
        RuleOrderByWithRelationInputSchema.array(),
        RuleOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: RuleWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const RuleGroupByArgsSchema: z.ZodType<Prisma.RuleGroupByArgs> = z
  .object({
    where: RuleWhereInputSchema.optional(),
    orderBy: z
      .union([
        RuleOrderByWithAggregationInputSchema.array(),
        RuleOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: RuleScalarFieldEnumSchema.array(),
    having: RuleScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const RuleFindUniqueArgsSchema: z.ZodType<Prisma.RuleFindUniqueArgs> = z
  .object({
    select: RuleSelectSchema.optional(),
    include: RuleIncludeSchema.optional(),
    where: RuleWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const RuleFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.RuleFindUniqueOrThrowArgs> =
  z
    .object({
      select: RuleSelectSchema.optional(),
      include: RuleIncludeSchema.optional(),
      where: RuleWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ConditionFindFirstArgsSchema: z.ZodType<Prisma.ConditionFindFirstArgs> =
  z
    .object({
      select: ConditionSelectSchema.optional(),
      include: ConditionIncludeSchema.optional(),
      where: ConditionWhereInputSchema.optional(),
      orderBy: z
        .union([
          ConditionOrderByWithRelationInputSchema.array(),
          ConditionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: ConditionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ConditionScalarFieldEnumSchema,
          ConditionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ConditionFindFirstOrThrowArgsSchema: z.ZodType<Prisma.ConditionFindFirstOrThrowArgs> =
  z
    .object({
      select: ConditionSelectSchema.optional(),
      include: ConditionIncludeSchema.optional(),
      where: ConditionWhereInputSchema.optional(),
      orderBy: z
        .union([
          ConditionOrderByWithRelationInputSchema.array(),
          ConditionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: ConditionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ConditionScalarFieldEnumSchema,
          ConditionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ConditionFindManyArgsSchema: z.ZodType<Prisma.ConditionFindManyArgs> =
  z
    .object({
      select: ConditionSelectSchema.optional(),
      include: ConditionIncludeSchema.optional(),
      where: ConditionWhereInputSchema.optional(),
      orderBy: z
        .union([
          ConditionOrderByWithRelationInputSchema.array(),
          ConditionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: ConditionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ConditionScalarFieldEnumSchema,
          ConditionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ConditionAggregateArgsSchema: z.ZodType<Prisma.ConditionAggregateArgs> =
  z
    .object({
      where: ConditionWhereInputSchema.optional(),
      orderBy: z
        .union([
          ConditionOrderByWithRelationInputSchema.array(),
          ConditionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: ConditionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const ConditionGroupByArgsSchema: z.ZodType<Prisma.ConditionGroupByArgs> =
  z
    .object({
      where: ConditionWhereInputSchema.optional(),
      orderBy: z
        .union([
          ConditionOrderByWithAggregationInputSchema.array(),
          ConditionOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: ConditionScalarFieldEnumSchema.array(),
      having: ConditionScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const ConditionFindUniqueArgsSchema: z.ZodType<Prisma.ConditionFindUniqueArgs> =
  z
    .object({
      select: ConditionSelectSchema.optional(),
      include: ConditionIncludeSchema.optional(),
      where: ConditionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ConditionFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.ConditionFindUniqueOrThrowArgs> =
  z
    .object({
      select: ConditionSelectSchema.optional(),
      include: ConditionIncludeSchema.optional(),
      where: ConditionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const RuleConditionFindFirstArgsSchema: z.ZodType<Prisma.RuleConditionFindFirstArgs> =
  z
    .object({
      select: RuleConditionSelectSchema.optional(),
      include: RuleConditionIncludeSchema.optional(),
      where: RuleConditionWhereInputSchema.optional(),
      orderBy: z
        .union([
          RuleConditionOrderByWithRelationInputSchema.array(),
          RuleConditionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: RuleConditionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          RuleConditionScalarFieldEnumSchema,
          RuleConditionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const RuleConditionFindFirstOrThrowArgsSchema: z.ZodType<Prisma.RuleConditionFindFirstOrThrowArgs> =
  z
    .object({
      select: RuleConditionSelectSchema.optional(),
      include: RuleConditionIncludeSchema.optional(),
      where: RuleConditionWhereInputSchema.optional(),
      orderBy: z
        .union([
          RuleConditionOrderByWithRelationInputSchema.array(),
          RuleConditionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: RuleConditionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          RuleConditionScalarFieldEnumSchema,
          RuleConditionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const RuleConditionFindManyArgsSchema: z.ZodType<Prisma.RuleConditionFindManyArgs> =
  z
    .object({
      select: RuleConditionSelectSchema.optional(),
      include: RuleConditionIncludeSchema.optional(),
      where: RuleConditionWhereInputSchema.optional(),
      orderBy: z
        .union([
          RuleConditionOrderByWithRelationInputSchema.array(),
          RuleConditionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: RuleConditionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          RuleConditionScalarFieldEnumSchema,
          RuleConditionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const RuleConditionAggregateArgsSchema: z.ZodType<Prisma.RuleConditionAggregateArgs> =
  z
    .object({
      where: RuleConditionWhereInputSchema.optional(),
      orderBy: z
        .union([
          RuleConditionOrderByWithRelationInputSchema.array(),
          RuleConditionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: RuleConditionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const RuleConditionGroupByArgsSchema: z.ZodType<Prisma.RuleConditionGroupByArgs> =
  z
    .object({
      where: RuleConditionWhereInputSchema.optional(),
      orderBy: z
        .union([
          RuleConditionOrderByWithAggregationInputSchema.array(),
          RuleConditionOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: RuleConditionScalarFieldEnumSchema.array(),
      having: RuleConditionScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const RuleConditionFindUniqueArgsSchema: z.ZodType<Prisma.RuleConditionFindUniqueArgs> =
  z
    .object({
      select: RuleConditionSelectSchema.optional(),
      include: RuleConditionIncludeSchema.optional(),
      where: RuleConditionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const RuleConditionFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.RuleConditionFindUniqueOrThrowArgs> =
  z
    .object({
      select: RuleConditionSelectSchema.optional(),
      include: RuleConditionIncludeSchema.optional(),
      where: RuleConditionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const EventFindFirstArgsSchema: z.ZodType<Prisma.EventFindFirstArgs> = z
  .object({
    select: EventSelectSchema.optional(),
    include: EventIncludeSchema.optional(),
    where: EventWhereInputSchema.optional(),
    orderBy: z
      .union([
        EventOrderByWithRelationInputSchema.array(),
        EventOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: EventWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([EventScalarFieldEnumSchema, EventScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const EventFindFirstOrThrowArgsSchema: z.ZodType<Prisma.EventFindFirstOrThrowArgs> =
  z
    .object({
      select: EventSelectSchema.optional(),
      include: EventIncludeSchema.optional(),
      where: EventWhereInputSchema.optional(),
      orderBy: z
        .union([
          EventOrderByWithRelationInputSchema.array(),
          EventOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: EventWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([EventScalarFieldEnumSchema, EventScalarFieldEnumSchema.array()])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const EventFindManyArgsSchema: z.ZodType<Prisma.EventFindManyArgs> = z
  .object({
    select: EventSelectSchema.optional(),
    include: EventIncludeSchema.optional(),
    where: EventWhereInputSchema.optional(),
    orderBy: z
      .union([
        EventOrderByWithRelationInputSchema.array(),
        EventOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: EventWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([EventScalarFieldEnumSchema, EventScalarFieldEnumSchema.array()])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const EventAggregateArgsSchema: z.ZodType<Prisma.EventAggregateArgs> = z
  .object({
    where: EventWhereInputSchema.optional(),
    orderBy: z
      .union([
        EventOrderByWithRelationInputSchema.array(),
        EventOrderByWithRelationInputSchema
      ])
      .optional(),
    cursor: EventWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const EventGroupByArgsSchema: z.ZodType<Prisma.EventGroupByArgs> = z
  .object({
    where: EventWhereInputSchema.optional(),
    orderBy: z
      .union([
        EventOrderByWithAggregationInputSchema.array(),
        EventOrderByWithAggregationInputSchema
      ])
      .optional(),
    by: EventScalarFieldEnumSchema.array(),
    having: EventScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional()
  })
  .strict();

export const EventFindUniqueArgsSchema: z.ZodType<Prisma.EventFindUniqueArgs> =
  z
    .object({
      select: EventSelectSchema.optional(),
      include: EventIncludeSchema.optional(),
      where: EventWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const EventFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.EventFindUniqueOrThrowArgs> =
  z
    .object({
      select: EventSelectSchema.optional(),
      include: EventIncludeSchema.optional(),
      where: EventWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const WorkflowStateFindFirstArgsSchema: z.ZodType<Prisma.WorkflowStateFindFirstArgs> =
  z
    .object({
      select: WorkflowStateSelectSchema.optional(),
      include: WorkflowStateIncludeSchema.optional(),
      where: WorkflowStateWhereInputSchema.optional(),
      orderBy: z
        .union([
          WorkflowStateOrderByWithRelationInputSchema.array(),
          WorkflowStateOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: WorkflowStateWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          WorkflowStateScalarFieldEnumSchema,
          WorkflowStateScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const WorkflowStateFindFirstOrThrowArgsSchema: z.ZodType<Prisma.WorkflowStateFindFirstOrThrowArgs> =
  z
    .object({
      select: WorkflowStateSelectSchema.optional(),
      include: WorkflowStateIncludeSchema.optional(),
      where: WorkflowStateWhereInputSchema.optional(),
      orderBy: z
        .union([
          WorkflowStateOrderByWithRelationInputSchema.array(),
          WorkflowStateOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: WorkflowStateWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          WorkflowStateScalarFieldEnumSchema,
          WorkflowStateScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const WorkflowStateFindManyArgsSchema: z.ZodType<Prisma.WorkflowStateFindManyArgs> =
  z
    .object({
      select: WorkflowStateSelectSchema.optional(),
      include: WorkflowStateIncludeSchema.optional(),
      where: WorkflowStateWhereInputSchema.optional(),
      orderBy: z
        .union([
          WorkflowStateOrderByWithRelationInputSchema.array(),
          WorkflowStateOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: WorkflowStateWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          WorkflowStateScalarFieldEnumSchema,
          WorkflowStateScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const WorkflowStateAggregateArgsSchema: z.ZodType<Prisma.WorkflowStateAggregateArgs> =
  z
    .object({
      where: WorkflowStateWhereInputSchema.optional(),
      orderBy: z
        .union([
          WorkflowStateOrderByWithRelationInputSchema.array(),
          WorkflowStateOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: WorkflowStateWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const WorkflowStateGroupByArgsSchema: z.ZodType<Prisma.WorkflowStateGroupByArgs> =
  z
    .object({
      where: WorkflowStateWhereInputSchema.optional(),
      orderBy: z
        .union([
          WorkflowStateOrderByWithAggregationInputSchema.array(),
          WorkflowStateOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: WorkflowStateScalarFieldEnumSchema.array(),
      having: WorkflowStateScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const WorkflowStateFindUniqueArgsSchema: z.ZodType<Prisma.WorkflowStateFindUniqueArgs> =
  z
    .object({
      select: WorkflowStateSelectSchema.optional(),
      include: WorkflowStateIncludeSchema.optional(),
      where: WorkflowStateWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const WorkflowStateFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.WorkflowStateFindUniqueOrThrowArgs> =
  z
    .object({
      select: WorkflowStateSelectSchema.optional(),
      include: WorkflowStateIncludeSchema.optional(),
      where: WorkflowStateWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ExecutionFindFirstArgsSchema: z.ZodType<Prisma.ExecutionFindFirstArgs> =
  z
    .object({
      select: ExecutionSelectSchema.optional(),
      include: ExecutionIncludeSchema.optional(),
      where: ExecutionWhereInputSchema.optional(),
      orderBy: z
        .union([
          ExecutionOrderByWithRelationInputSchema.array(),
          ExecutionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: ExecutionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ExecutionScalarFieldEnumSchema,
          ExecutionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ExecutionFindFirstOrThrowArgsSchema: z.ZodType<Prisma.ExecutionFindFirstOrThrowArgs> =
  z
    .object({
      select: ExecutionSelectSchema.optional(),
      include: ExecutionIncludeSchema.optional(),
      where: ExecutionWhereInputSchema.optional(),
      orderBy: z
        .union([
          ExecutionOrderByWithRelationInputSchema.array(),
          ExecutionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: ExecutionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ExecutionScalarFieldEnumSchema,
          ExecutionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ExecutionFindManyArgsSchema: z.ZodType<Prisma.ExecutionFindManyArgs> =
  z
    .object({
      select: ExecutionSelectSchema.optional(),
      include: ExecutionIncludeSchema.optional(),
      where: ExecutionWhereInputSchema.optional(),
      orderBy: z
        .union([
          ExecutionOrderByWithRelationInputSchema.array(),
          ExecutionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: ExecutionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ExecutionScalarFieldEnumSchema,
          ExecutionScalarFieldEnumSchema.array()
        ])
        .optional(),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ExecutionAggregateArgsSchema: z.ZodType<Prisma.ExecutionAggregateArgs> =
  z
    .object({
      where: ExecutionWhereInputSchema.optional(),
      orderBy: z
        .union([
          ExecutionOrderByWithRelationInputSchema.array(),
          ExecutionOrderByWithRelationInputSchema
        ])
        .optional(),
      cursor: ExecutionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const ExecutionGroupByArgsSchema: z.ZodType<Prisma.ExecutionGroupByArgs> =
  z
    .object({
      where: ExecutionWhereInputSchema.optional(),
      orderBy: z
        .union([
          ExecutionOrderByWithAggregationInputSchema.array(),
          ExecutionOrderByWithAggregationInputSchema
        ])
        .optional(),
      by: ExecutionScalarFieldEnumSchema.array(),
      having: ExecutionScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional()
    })
    .strict();

export const ExecutionFindUniqueArgsSchema: z.ZodType<Prisma.ExecutionFindUniqueArgs> =
  z
    .object({
      select: ExecutionSelectSchema.optional(),
      include: ExecutionIncludeSchema.optional(),
      where: ExecutionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ExecutionFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.ExecutionFindUniqueOrThrowArgs> =
  z
    .object({
      select: ExecutionSelectSchema.optional(),
      include: ExecutionIncludeSchema.optional(),
      where: ExecutionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TwoFactorConfirmationCreateArgsSchema: z.ZodType<Prisma.TwoFactorConfirmationCreateArgs> =
  z
    .object({
      select: TwoFactorConfirmationSelectSchema.optional(),
      include: TwoFactorConfirmationIncludeSchema.optional(),
      data: z.union([
        TwoFactorConfirmationCreateInputSchema,
        TwoFactorConfirmationUncheckedCreateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TwoFactorConfirmationUpsertArgsSchema: z.ZodType<Prisma.TwoFactorConfirmationUpsertArgs> =
  z
    .object({
      select: TwoFactorConfirmationSelectSchema.optional(),
      include: TwoFactorConfirmationIncludeSchema.optional(),
      where: TwoFactorConfirmationWhereUniqueInputSchema,
      create: z.union([
        TwoFactorConfirmationCreateInputSchema,
        TwoFactorConfirmationUncheckedCreateInputSchema
      ]),
      update: z.union([
        TwoFactorConfirmationUpdateInputSchema,
        TwoFactorConfirmationUncheckedUpdateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TwoFactorConfirmationCreateManyArgsSchema: z.ZodType<Prisma.TwoFactorConfirmationCreateManyArgs> =
  z
    .object({
      data: z.union([
        TwoFactorConfirmationCreateManyInputSchema,
        TwoFactorConfirmationCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const TwoFactorConfirmationCreateManyAndReturnArgsSchema: z.ZodType<Prisma.TwoFactorConfirmationCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        TwoFactorConfirmationCreateManyInputSchema,
        TwoFactorConfirmationCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const TwoFactorConfirmationDeleteArgsSchema: z.ZodType<Prisma.TwoFactorConfirmationDeleteArgs> =
  z
    .object({
      select: TwoFactorConfirmationSelectSchema.optional(),
      include: TwoFactorConfirmationIncludeSchema.optional(),
      where: TwoFactorConfirmationWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TwoFactorConfirmationUpdateArgsSchema: z.ZodType<Prisma.TwoFactorConfirmationUpdateArgs> =
  z
    .object({
      select: TwoFactorConfirmationSelectSchema.optional(),
      include: TwoFactorConfirmationIncludeSchema.optional(),
      data: z.union([
        TwoFactorConfirmationUpdateInputSchema,
        TwoFactorConfirmationUncheckedUpdateInputSchema
      ]),
      where: TwoFactorConfirmationWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TwoFactorConfirmationUpdateManyArgsSchema: z.ZodType<Prisma.TwoFactorConfirmationUpdateManyArgs> =
  z
    .object({
      data: z.union([
        TwoFactorConfirmationUpdateManyMutationInputSchema,
        TwoFactorConfirmationUncheckedUpdateManyInputSchema
      ]),
      where: TwoFactorConfirmationWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const TwoFactorConfirmationUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.TwoFactorConfirmationUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        TwoFactorConfirmationUpdateManyMutationInputSchema,
        TwoFactorConfirmationUncheckedUpdateManyInputSchema
      ]),
      where: TwoFactorConfirmationWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const TwoFactorConfirmationDeleteManyArgsSchema: z.ZodType<Prisma.TwoFactorConfirmationDeleteManyArgs> =
  z
    .object({
      where: TwoFactorConfirmationWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const AccountCreateArgsSchema: z.ZodType<Prisma.AccountCreateArgs> = z
  .object({
    select: AccountSelectSchema.optional(),
    include: AccountIncludeSchema.optional(),
    data: z.union([
      AccountCreateInputSchema,
      AccountUncheckedCreateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const AccountUpsertArgsSchema: z.ZodType<Prisma.AccountUpsertArgs> = z
  .object({
    select: AccountSelectSchema.optional(),
    include: AccountIncludeSchema.optional(),
    where: AccountWhereUniqueInputSchema,
    create: z.union([
      AccountCreateInputSchema,
      AccountUncheckedCreateInputSchema
    ]),
    update: z.union([
      AccountUpdateInputSchema,
      AccountUncheckedUpdateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const AccountCreateManyArgsSchema: z.ZodType<Prisma.AccountCreateManyArgs> =
  z
    .object({
      data: z.union([
        AccountCreateManyInputSchema,
        AccountCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const AccountCreateManyAndReturnArgsSchema: z.ZodType<Prisma.AccountCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        AccountCreateManyInputSchema,
        AccountCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const AccountDeleteArgsSchema: z.ZodType<Prisma.AccountDeleteArgs> = z
  .object({
    select: AccountSelectSchema.optional(),
    include: AccountIncludeSchema.optional(),
    where: AccountWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const AccountUpdateArgsSchema: z.ZodType<Prisma.AccountUpdateArgs> = z
  .object({
    select: AccountSelectSchema.optional(),
    include: AccountIncludeSchema.optional(),
    data: z.union([
      AccountUpdateInputSchema,
      AccountUncheckedUpdateInputSchema
    ]),
    where: AccountWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const AccountUpdateManyArgsSchema: z.ZodType<Prisma.AccountUpdateManyArgs> =
  z
    .object({
      data: z.union([
        AccountUpdateManyMutationInputSchema,
        AccountUncheckedUpdateManyInputSchema
      ]),
      where: AccountWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const AccountUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.AccountUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        AccountUpdateManyMutationInputSchema,
        AccountUncheckedUpdateManyInputSchema
      ]),
      where: AccountWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const AccountDeleteManyArgsSchema: z.ZodType<Prisma.AccountDeleteManyArgs> =
  z
    .object({
      where: AccountWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const SessionCreateArgsSchema: z.ZodType<Prisma.SessionCreateArgs> = z
  .object({
    select: SessionSelectSchema.optional(),
    include: SessionIncludeSchema.optional(),
    data: z.union([
      SessionCreateInputSchema,
      SessionUncheckedCreateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const SessionUpsertArgsSchema: z.ZodType<Prisma.SessionUpsertArgs> = z
  .object({
    select: SessionSelectSchema.optional(),
    include: SessionIncludeSchema.optional(),
    where: SessionWhereUniqueInputSchema,
    create: z.union([
      SessionCreateInputSchema,
      SessionUncheckedCreateInputSchema
    ]),
    update: z.union([
      SessionUpdateInputSchema,
      SessionUncheckedUpdateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const SessionCreateManyArgsSchema: z.ZodType<Prisma.SessionCreateManyArgs> =
  z
    .object({
      data: z.union([
        SessionCreateManyInputSchema,
        SessionCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const SessionCreateManyAndReturnArgsSchema: z.ZodType<Prisma.SessionCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        SessionCreateManyInputSchema,
        SessionCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const SessionDeleteArgsSchema: z.ZodType<Prisma.SessionDeleteArgs> = z
  .object({
    select: SessionSelectSchema.optional(),
    include: SessionIncludeSchema.optional(),
    where: SessionWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const SessionUpdateArgsSchema: z.ZodType<Prisma.SessionUpdateArgs> = z
  .object({
    select: SessionSelectSchema.optional(),
    include: SessionIncludeSchema.optional(),
    data: z.union([
      SessionUpdateInputSchema,
      SessionUncheckedUpdateInputSchema
    ]),
    where: SessionWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const SessionUpdateManyArgsSchema: z.ZodType<Prisma.SessionUpdateManyArgs> =
  z
    .object({
      data: z.union([
        SessionUpdateManyMutationInputSchema,
        SessionUncheckedUpdateManyInputSchema
      ]),
      where: SessionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const SessionUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.SessionUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        SessionUpdateManyMutationInputSchema,
        SessionUncheckedUpdateManyInputSchema
      ]),
      where: SessionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const SessionDeleteManyArgsSchema: z.ZodType<Prisma.SessionDeleteManyArgs> =
  z
    .object({
      where: SessionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const VerificationCreateArgsSchema: z.ZodType<Prisma.VerificationCreateArgs> =
  z
    .object({
      select: VerificationSelectSchema.optional(),
      data: z.union([
        VerificationCreateInputSchema,
        VerificationUncheckedCreateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const VerificationUpsertArgsSchema: z.ZodType<Prisma.VerificationUpsertArgs> =
  z
    .object({
      select: VerificationSelectSchema.optional(),
      where: VerificationWhereUniqueInputSchema,
      create: z.union([
        VerificationCreateInputSchema,
        VerificationUncheckedCreateInputSchema
      ]),
      update: z.union([
        VerificationUpdateInputSchema,
        VerificationUncheckedUpdateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const VerificationCreateManyArgsSchema: z.ZodType<Prisma.VerificationCreateManyArgs> =
  z
    .object({
      data: z.union([
        VerificationCreateManyInputSchema,
        VerificationCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const VerificationCreateManyAndReturnArgsSchema: z.ZodType<Prisma.VerificationCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        VerificationCreateManyInputSchema,
        VerificationCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const VerificationDeleteArgsSchema: z.ZodType<Prisma.VerificationDeleteArgs> =
  z
    .object({
      select: VerificationSelectSchema.optional(),
      where: VerificationWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const VerificationUpdateArgsSchema: z.ZodType<Prisma.VerificationUpdateArgs> =
  z
    .object({
      select: VerificationSelectSchema.optional(),
      data: z.union([
        VerificationUpdateInputSchema,
        VerificationUncheckedUpdateInputSchema
      ]),
      where: VerificationWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const VerificationUpdateManyArgsSchema: z.ZodType<Prisma.VerificationUpdateManyArgs> =
  z
    .object({
      data: z.union([
        VerificationUpdateManyMutationInputSchema,
        VerificationUncheckedUpdateManyInputSchema
      ]),
      where: VerificationWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const VerificationUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.VerificationUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        VerificationUpdateManyMutationInputSchema,
        VerificationUncheckedUpdateManyInputSchema
      ]),
      where: VerificationWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const VerificationDeleteManyArgsSchema: z.ZodType<Prisma.VerificationDeleteManyArgs> =
  z
    .object({
      where: VerificationWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const AuthenticatorCreateArgsSchema: z.ZodType<Prisma.AuthenticatorCreateArgs> =
  z
    .object({
      select: AuthenticatorSelectSchema.optional(),
      include: AuthenticatorIncludeSchema.optional(),
      data: z.union([
        AuthenticatorCreateInputSchema,
        AuthenticatorUncheckedCreateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const AuthenticatorUpsertArgsSchema: z.ZodType<Prisma.AuthenticatorUpsertArgs> =
  z
    .object({
      select: AuthenticatorSelectSchema.optional(),
      include: AuthenticatorIncludeSchema.optional(),
      where: AuthenticatorWhereUniqueInputSchema,
      create: z.union([
        AuthenticatorCreateInputSchema,
        AuthenticatorUncheckedCreateInputSchema
      ]),
      update: z.union([
        AuthenticatorUpdateInputSchema,
        AuthenticatorUncheckedUpdateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const AuthenticatorCreateManyArgsSchema: z.ZodType<Prisma.AuthenticatorCreateManyArgs> =
  z
    .object({
      data: z.union([
        AuthenticatorCreateManyInputSchema,
        AuthenticatorCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const AuthenticatorCreateManyAndReturnArgsSchema: z.ZodType<Prisma.AuthenticatorCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        AuthenticatorCreateManyInputSchema,
        AuthenticatorCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const AuthenticatorDeleteArgsSchema: z.ZodType<Prisma.AuthenticatorDeleteArgs> =
  z
    .object({
      select: AuthenticatorSelectSchema.optional(),
      include: AuthenticatorIncludeSchema.optional(),
      where: AuthenticatorWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const AuthenticatorUpdateArgsSchema: z.ZodType<Prisma.AuthenticatorUpdateArgs> =
  z
    .object({
      select: AuthenticatorSelectSchema.optional(),
      include: AuthenticatorIncludeSchema.optional(),
      data: z.union([
        AuthenticatorUpdateInputSchema,
        AuthenticatorUncheckedUpdateInputSchema
      ]),
      where: AuthenticatorWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const AuthenticatorUpdateManyArgsSchema: z.ZodType<Prisma.AuthenticatorUpdateManyArgs> =
  z
    .object({
      data: z.union([
        AuthenticatorUpdateManyMutationInputSchema,
        AuthenticatorUncheckedUpdateManyInputSchema
      ]),
      where: AuthenticatorWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const AuthenticatorUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.AuthenticatorUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        AuthenticatorUpdateManyMutationInputSchema,
        AuthenticatorUncheckedUpdateManyInputSchema
      ]),
      where: AuthenticatorWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const AuthenticatorDeleteManyArgsSchema: z.ZodType<Prisma.AuthenticatorDeleteManyArgs> =
  z
    .object({
      where: AuthenticatorWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const PasswordResetTokenCreateArgsSchema: z.ZodType<Prisma.PasswordResetTokenCreateArgs> =
  z
    .object({
      select: PasswordResetTokenSelectSchema.optional(),
      data: z.union([
        PasswordResetTokenCreateInputSchema,
        PasswordResetTokenUncheckedCreateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const PasswordResetTokenUpsertArgsSchema: z.ZodType<Prisma.PasswordResetTokenUpsertArgs> =
  z
    .object({
      select: PasswordResetTokenSelectSchema.optional(),
      where: PasswordResetTokenWhereUniqueInputSchema,
      create: z.union([
        PasswordResetTokenCreateInputSchema,
        PasswordResetTokenUncheckedCreateInputSchema
      ]),
      update: z.union([
        PasswordResetTokenUpdateInputSchema,
        PasswordResetTokenUncheckedUpdateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const PasswordResetTokenCreateManyArgsSchema: z.ZodType<Prisma.PasswordResetTokenCreateManyArgs> =
  z
    .object({
      data: z.union([
        PasswordResetTokenCreateManyInputSchema,
        PasswordResetTokenCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const PasswordResetTokenCreateManyAndReturnArgsSchema: z.ZodType<Prisma.PasswordResetTokenCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        PasswordResetTokenCreateManyInputSchema,
        PasswordResetTokenCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const PasswordResetTokenDeleteArgsSchema: z.ZodType<Prisma.PasswordResetTokenDeleteArgs> =
  z
    .object({
      select: PasswordResetTokenSelectSchema.optional(),
      where: PasswordResetTokenWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const PasswordResetTokenUpdateArgsSchema: z.ZodType<Prisma.PasswordResetTokenUpdateArgs> =
  z
    .object({
      select: PasswordResetTokenSelectSchema.optional(),
      data: z.union([
        PasswordResetTokenUpdateInputSchema,
        PasswordResetTokenUncheckedUpdateInputSchema
      ]),
      where: PasswordResetTokenWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const PasswordResetTokenUpdateManyArgsSchema: z.ZodType<Prisma.PasswordResetTokenUpdateManyArgs> =
  z
    .object({
      data: z.union([
        PasswordResetTokenUpdateManyMutationInputSchema,
        PasswordResetTokenUncheckedUpdateManyInputSchema
      ]),
      where: PasswordResetTokenWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const PasswordResetTokenUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.PasswordResetTokenUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        PasswordResetTokenUpdateManyMutationInputSchema,
        PasswordResetTokenUncheckedUpdateManyInputSchema
      ]),
      where: PasswordResetTokenWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const PasswordResetTokenDeleteManyArgsSchema: z.ZodType<Prisma.PasswordResetTokenDeleteManyArgs> =
  z
    .object({
      where: PasswordResetTokenWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const TwoFactorTokenCreateArgsSchema: z.ZodType<Prisma.TwoFactorTokenCreateArgs> =
  z
    .object({
      select: TwoFactorTokenSelectSchema.optional(),
      data: z.union([
        TwoFactorTokenCreateInputSchema,
        TwoFactorTokenUncheckedCreateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TwoFactorTokenUpsertArgsSchema: z.ZodType<Prisma.TwoFactorTokenUpsertArgs> =
  z
    .object({
      select: TwoFactorTokenSelectSchema.optional(),
      where: TwoFactorTokenWhereUniqueInputSchema,
      create: z.union([
        TwoFactorTokenCreateInputSchema,
        TwoFactorTokenUncheckedCreateInputSchema
      ]),
      update: z.union([
        TwoFactorTokenUpdateInputSchema,
        TwoFactorTokenUncheckedUpdateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TwoFactorTokenCreateManyArgsSchema: z.ZodType<Prisma.TwoFactorTokenCreateManyArgs> =
  z
    .object({
      data: z.union([
        TwoFactorTokenCreateManyInputSchema,
        TwoFactorTokenCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const TwoFactorTokenCreateManyAndReturnArgsSchema: z.ZodType<Prisma.TwoFactorTokenCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        TwoFactorTokenCreateManyInputSchema,
        TwoFactorTokenCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const TwoFactorTokenDeleteArgsSchema: z.ZodType<Prisma.TwoFactorTokenDeleteArgs> =
  z
    .object({
      select: TwoFactorTokenSelectSchema.optional(),
      where: TwoFactorTokenWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TwoFactorTokenUpdateArgsSchema: z.ZodType<Prisma.TwoFactorTokenUpdateArgs> =
  z
    .object({
      select: TwoFactorTokenSelectSchema.optional(),
      data: z.union([
        TwoFactorTokenUpdateInputSchema,
        TwoFactorTokenUncheckedUpdateInputSchema
      ]),
      where: TwoFactorTokenWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const TwoFactorTokenUpdateManyArgsSchema: z.ZodType<Prisma.TwoFactorTokenUpdateManyArgs> =
  z
    .object({
      data: z.union([
        TwoFactorTokenUpdateManyMutationInputSchema,
        TwoFactorTokenUncheckedUpdateManyInputSchema
      ]),
      where: TwoFactorTokenWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const TwoFactorTokenUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.TwoFactorTokenUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        TwoFactorTokenUpdateManyMutationInputSchema,
        TwoFactorTokenUncheckedUpdateManyInputSchema
      ]),
      where: TwoFactorTokenWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const TwoFactorTokenDeleteManyArgsSchema: z.ZodType<Prisma.TwoFactorTokenDeleteManyArgs> =
  z
    .object({
      where: TwoFactorTokenWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const CustomerCreateArgsSchema: z.ZodType<Prisma.CustomerCreateArgs> = z
  .object({
    select: CustomerSelectSchema.optional(),
    include: CustomerIncludeSchema.optional(),
    data: z.union([
      CustomerCreateInputSchema,
      CustomerUncheckedCreateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CustomerUpsertArgsSchema: z.ZodType<Prisma.CustomerUpsertArgs> = z
  .object({
    select: CustomerSelectSchema.optional(),
    include: CustomerIncludeSchema.optional(),
    where: CustomerWhereUniqueInputSchema,
    create: z.union([
      CustomerCreateInputSchema,
      CustomerUncheckedCreateInputSchema
    ]),
    update: z.union([
      CustomerUpdateInputSchema,
      CustomerUncheckedUpdateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CustomerCreateManyArgsSchema: z.ZodType<Prisma.CustomerCreateManyArgs> =
  z
    .object({
      data: z.union([
        CustomerCreateManyInputSchema,
        CustomerCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const CustomerCreateManyAndReturnArgsSchema: z.ZodType<Prisma.CustomerCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CustomerCreateManyInputSchema,
        CustomerCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const CustomerDeleteArgsSchema: z.ZodType<Prisma.CustomerDeleteArgs> = z
  .object({
    select: CustomerSelectSchema.optional(),
    include: CustomerIncludeSchema.optional(),
    where: CustomerWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CustomerUpdateArgsSchema: z.ZodType<Prisma.CustomerUpdateArgs> = z
  .object({
    select: CustomerSelectSchema.optional(),
    include: CustomerIncludeSchema.optional(),
    data: z.union([
      CustomerUpdateInputSchema,
      CustomerUncheckedUpdateInputSchema
    ]),
    where: CustomerWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CustomerUpdateManyArgsSchema: z.ZodType<Prisma.CustomerUpdateManyArgs> =
  z
    .object({
      data: z.union([
        CustomerUpdateManyMutationInputSchema,
        CustomerUncheckedUpdateManyInputSchema
      ]),
      where: CustomerWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const CustomerUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.CustomerUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CustomerUpdateManyMutationInputSchema,
        CustomerUncheckedUpdateManyInputSchema
      ]),
      where: CustomerWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const CustomerDeleteManyArgsSchema: z.ZodType<Prisma.CustomerDeleteManyArgs> =
  z
    .object({
      where: CustomerWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const ProductCreateArgsSchema: z.ZodType<Prisma.ProductCreateArgs> = z
  .object({
    select: ProductSelectSchema.optional(),
    include: ProductIncludeSchema.optional(),
    data: z.union([
      ProductCreateInputSchema,
      ProductUncheckedCreateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const ProductUpsertArgsSchema: z.ZodType<Prisma.ProductUpsertArgs> = z
  .object({
    select: ProductSelectSchema.optional(),
    include: ProductIncludeSchema.optional(),
    where: ProductWhereUniqueInputSchema,
    create: z.union([
      ProductCreateInputSchema,
      ProductUncheckedCreateInputSchema
    ]),
    update: z.union([
      ProductUpdateInputSchema,
      ProductUncheckedUpdateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const ProductCreateManyArgsSchema: z.ZodType<Prisma.ProductCreateManyArgs> =
  z
    .object({
      data: z.union([
        ProductCreateManyInputSchema,
        ProductCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ProductCreateManyAndReturnArgsSchema: z.ZodType<Prisma.ProductCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ProductCreateManyInputSchema,
        ProductCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ProductDeleteArgsSchema: z.ZodType<Prisma.ProductDeleteArgs> = z
  .object({
    select: ProductSelectSchema.optional(),
    include: ProductIncludeSchema.optional(),
    where: ProductWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const ProductUpdateArgsSchema: z.ZodType<Prisma.ProductUpdateArgs> = z
  .object({
    select: ProductSelectSchema.optional(),
    include: ProductIncludeSchema.optional(),
    data: z.union([
      ProductUpdateInputSchema,
      ProductUncheckedUpdateInputSchema
    ]),
    where: ProductWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const ProductUpdateManyArgsSchema: z.ZodType<Prisma.ProductUpdateManyArgs> =
  z
    .object({
      data: z.union([
        ProductUpdateManyMutationInputSchema,
        ProductUncheckedUpdateManyInputSchema
      ]),
      where: ProductWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const ProductUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.ProductUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ProductUpdateManyMutationInputSchema,
        ProductUncheckedUpdateManyInputSchema
      ]),
      where: ProductWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const ProductDeleteManyArgsSchema: z.ZodType<Prisma.ProductDeleteManyArgs> =
  z
    .object({
      where: ProductWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const PriceCreateArgsSchema: z.ZodType<Prisma.PriceCreateArgs> = z
  .object({
    select: PriceSelectSchema.optional(),
    include: PriceIncludeSchema.optional(),
    data: z.union([PriceCreateInputSchema, PriceUncheckedCreateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const PriceUpsertArgsSchema: z.ZodType<Prisma.PriceUpsertArgs> = z
  .object({
    select: PriceSelectSchema.optional(),
    include: PriceIncludeSchema.optional(),
    where: PriceWhereUniqueInputSchema,
    create: z.union([PriceCreateInputSchema, PriceUncheckedCreateInputSchema]),
    update: z.union([PriceUpdateInputSchema, PriceUncheckedUpdateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const PriceCreateManyArgsSchema: z.ZodType<Prisma.PriceCreateManyArgs> =
  z
    .object({
      data: z.union([
        PriceCreateManyInputSchema,
        PriceCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const PriceCreateManyAndReturnArgsSchema: z.ZodType<Prisma.PriceCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        PriceCreateManyInputSchema,
        PriceCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const PriceDeleteArgsSchema: z.ZodType<Prisma.PriceDeleteArgs> = z
  .object({
    select: PriceSelectSchema.optional(),
    include: PriceIncludeSchema.optional(),
    where: PriceWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const PriceUpdateArgsSchema: z.ZodType<Prisma.PriceUpdateArgs> = z
  .object({
    select: PriceSelectSchema.optional(),
    include: PriceIncludeSchema.optional(),
    data: z.union([PriceUpdateInputSchema, PriceUncheckedUpdateInputSchema]),
    where: PriceWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const PriceUpdateManyArgsSchema: z.ZodType<Prisma.PriceUpdateManyArgs> =
  z
    .object({
      data: z.union([
        PriceUpdateManyMutationInputSchema,
        PriceUncheckedUpdateManyInputSchema
      ]),
      where: PriceWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const PriceUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.PriceUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        PriceUpdateManyMutationInputSchema,
        PriceUncheckedUpdateManyInputSchema
      ]),
      where: PriceWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const PriceDeleteManyArgsSchema: z.ZodType<Prisma.PriceDeleteManyArgs> =
  z
    .object({
      where: PriceWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const SubscriptionCreateArgsSchema: z.ZodType<Prisma.SubscriptionCreateArgs> =
  z
    .object({
      select: SubscriptionSelectSchema.optional(),
      include: SubscriptionIncludeSchema.optional(),
      data: z.union([
        SubscriptionCreateInputSchema,
        SubscriptionUncheckedCreateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SubscriptionUpsertArgsSchema: z.ZodType<Prisma.SubscriptionUpsertArgs> =
  z
    .object({
      select: SubscriptionSelectSchema.optional(),
      include: SubscriptionIncludeSchema.optional(),
      where: SubscriptionWhereUniqueInputSchema,
      create: z.union([
        SubscriptionCreateInputSchema,
        SubscriptionUncheckedCreateInputSchema
      ]),
      update: z.union([
        SubscriptionUpdateInputSchema,
        SubscriptionUncheckedUpdateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SubscriptionCreateManyArgsSchema: z.ZodType<Prisma.SubscriptionCreateManyArgs> =
  z
    .object({
      data: z.union([
        SubscriptionCreateManyInputSchema,
        SubscriptionCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const SubscriptionCreateManyAndReturnArgsSchema: z.ZodType<Prisma.SubscriptionCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        SubscriptionCreateManyInputSchema,
        SubscriptionCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const SubscriptionDeleteArgsSchema: z.ZodType<Prisma.SubscriptionDeleteArgs> =
  z
    .object({
      select: SubscriptionSelectSchema.optional(),
      include: SubscriptionIncludeSchema.optional(),
      where: SubscriptionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SubscriptionUpdateArgsSchema: z.ZodType<Prisma.SubscriptionUpdateArgs> =
  z
    .object({
      select: SubscriptionSelectSchema.optional(),
      include: SubscriptionIncludeSchema.optional(),
      data: z.union([
        SubscriptionUpdateInputSchema,
        SubscriptionUncheckedUpdateInputSchema
      ]),
      where: SubscriptionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SubscriptionUpdateManyArgsSchema: z.ZodType<Prisma.SubscriptionUpdateManyArgs> =
  z
    .object({
      data: z.union([
        SubscriptionUpdateManyMutationInputSchema,
        SubscriptionUncheckedUpdateManyInputSchema
      ]),
      where: SubscriptionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const SubscriptionUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.SubscriptionUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        SubscriptionUpdateManyMutationInputSchema,
        SubscriptionUncheckedUpdateManyInputSchema
      ]),
      where: SubscriptionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const SubscriptionDeleteManyArgsSchema: z.ZodType<Prisma.SubscriptionDeleteManyArgs> =
  z
    .object({
      where: SubscriptionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const FeedCreateArgsSchema: z.ZodType<Prisma.FeedCreateArgs> = z
  .object({
    select: FeedSelectSchema.optional(),
    include: FeedIncludeSchema.optional(),
    data: z.union([FeedCreateInputSchema, FeedUncheckedCreateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const FeedUpsertArgsSchema: z.ZodType<Prisma.FeedUpsertArgs> = z
  .object({
    select: FeedSelectSchema.optional(),
    include: FeedIncludeSchema.optional(),
    where: FeedWhereUniqueInputSchema,
    create: z.union([FeedCreateInputSchema, FeedUncheckedCreateInputSchema]),
    update: z.union([FeedUpdateInputSchema, FeedUncheckedUpdateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const FeedCreateManyArgsSchema: z.ZodType<Prisma.FeedCreateManyArgs> = z
  .object({
    data: z.union([
      FeedCreateManyInputSchema,
      FeedCreateManyInputSchema.array()
    ]),
    skipDuplicates: z.boolean().optional()
  })
  .strict();

export const FeedCreateManyAndReturnArgsSchema: z.ZodType<Prisma.FeedCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        FeedCreateManyInputSchema,
        FeedCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const FeedDeleteArgsSchema: z.ZodType<Prisma.FeedDeleteArgs> = z
  .object({
    select: FeedSelectSchema.optional(),
    include: FeedIncludeSchema.optional(),
    where: FeedWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const FeedUpdateArgsSchema: z.ZodType<Prisma.FeedUpdateArgs> = z
  .object({
    select: FeedSelectSchema.optional(),
    include: FeedIncludeSchema.optional(),
    data: z.union([FeedUpdateInputSchema, FeedUncheckedUpdateInputSchema]),
    where: FeedWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const FeedUpdateManyArgsSchema: z.ZodType<Prisma.FeedUpdateManyArgs> = z
  .object({
    data: z.union([
      FeedUpdateManyMutationInputSchema,
      FeedUncheckedUpdateManyInputSchema
    ]),
    where: FeedWhereInputSchema.optional(),
    limit: z.number().optional()
  })
  .strict();

export const FeedUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.FeedUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        FeedUpdateManyMutationInputSchema,
        FeedUncheckedUpdateManyInputSchema
      ]),
      where: FeedWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const FeedDeleteManyArgsSchema: z.ZodType<Prisma.FeedDeleteManyArgs> = z
  .object({
    where: FeedWhereInputSchema.optional(),
    limit: z.number().optional()
  })
  .strict();

export const CommentCreateArgsSchema: z.ZodType<Prisma.CommentCreateArgs> = z
  .object({
    select: CommentSelectSchema.optional(),
    include: CommentIncludeSchema.optional(),
    data: z.union([
      CommentCreateInputSchema,
      CommentUncheckedCreateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CommentUpsertArgsSchema: z.ZodType<Prisma.CommentUpsertArgs> = z
  .object({
    select: CommentSelectSchema.optional(),
    include: CommentIncludeSchema.optional(),
    where: CommentWhereUniqueInputSchema,
    create: z.union([
      CommentCreateInputSchema,
      CommentUncheckedCreateInputSchema
    ]),
    update: z.union([
      CommentUpdateInputSchema,
      CommentUncheckedUpdateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CommentCreateManyArgsSchema: z.ZodType<Prisma.CommentCreateManyArgs> =
  z
    .object({
      data: z.union([
        CommentCreateManyInputSchema,
        CommentCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const CommentCreateManyAndReturnArgsSchema: z.ZodType<Prisma.CommentCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CommentCreateManyInputSchema,
        CommentCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const CommentDeleteArgsSchema: z.ZodType<Prisma.CommentDeleteArgs> = z
  .object({
    select: CommentSelectSchema.optional(),
    include: CommentIncludeSchema.optional(),
    where: CommentWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CommentUpdateArgsSchema: z.ZodType<Prisma.CommentUpdateArgs> = z
  .object({
    select: CommentSelectSchema.optional(),
    include: CommentIncludeSchema.optional(),
    data: z.union([
      CommentUpdateInputSchema,
      CommentUncheckedUpdateInputSchema
    ]),
    where: CommentWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CommentUpdateManyArgsSchema: z.ZodType<Prisma.CommentUpdateManyArgs> =
  z
    .object({
      data: z.union([
        CommentUpdateManyMutationInputSchema,
        CommentUncheckedUpdateManyInputSchema
      ]),
      where: CommentWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const CommentUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.CommentUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CommentUpdateManyMutationInputSchema,
        CommentUncheckedUpdateManyInputSchema
      ]),
      where: CommentWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const CommentDeleteManyArgsSchema: z.ZodType<Prisma.CommentDeleteManyArgs> =
  z
    .object({
      where: CommentWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const CityCreateArgsSchema: z.ZodType<Prisma.CityCreateArgs> = z
  .object({
    select: CitySelectSchema.optional(),
    data: z.union([CityCreateInputSchema, CityUncheckedCreateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CityUpsertArgsSchema: z.ZodType<Prisma.CityUpsertArgs> = z
  .object({
    select: CitySelectSchema.optional(),
    where: CityWhereUniqueInputSchema,
    create: z.union([CityCreateInputSchema, CityUncheckedCreateInputSchema]),
    update: z.union([CityUpdateInputSchema, CityUncheckedUpdateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CityCreateManyArgsSchema: z.ZodType<Prisma.CityCreateManyArgs> = z
  .object({
    data: z.union([
      CityCreateManyInputSchema,
      CityCreateManyInputSchema.array()
    ]),
    skipDuplicates: z.boolean().optional()
  })
  .strict();

export const CityCreateManyAndReturnArgsSchema: z.ZodType<Prisma.CityCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CityCreateManyInputSchema,
        CityCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const CityDeleteArgsSchema: z.ZodType<Prisma.CityDeleteArgs> = z
  .object({
    select: CitySelectSchema.optional(),
    where: CityWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CityUpdateArgsSchema: z.ZodType<Prisma.CityUpdateArgs> = z
  .object({
    select: CitySelectSchema.optional(),
    data: z.union([CityUpdateInputSchema, CityUncheckedUpdateInputSchema]),
    where: CityWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CityUpdateManyArgsSchema: z.ZodType<Prisma.CityUpdateManyArgs> = z
  .object({
    data: z.union([
      CityUpdateManyMutationInputSchema,
      CityUncheckedUpdateManyInputSchema
    ]),
    where: CityWhereInputSchema.optional(),
    limit: z.number().optional()
  })
  .strict();

export const CityUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.CityUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CityUpdateManyMutationInputSchema,
        CityUncheckedUpdateManyInputSchema
      ]),
      where: CityWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const CityDeleteManyArgsSchema: z.ZodType<Prisma.CityDeleteManyArgs> = z
  .object({
    where: CityWhereInputSchema.optional(),
    limit: z.number().optional()
  })
  .strict();

export const NafSectionCreateArgsSchema: z.ZodType<Prisma.NafSectionCreateArgs> =
  z
    .object({
      select: NafSectionSelectSchema.optional(),
      include: NafSectionIncludeSchema.optional(),
      data: z.union([
        NafSectionCreateInputSchema,
        NafSectionUncheckedCreateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafSectionUpsertArgsSchema: z.ZodType<Prisma.NafSectionUpsertArgs> =
  z
    .object({
      select: NafSectionSelectSchema.optional(),
      include: NafSectionIncludeSchema.optional(),
      where: NafSectionWhereUniqueInputSchema,
      create: z.union([
        NafSectionCreateInputSchema,
        NafSectionUncheckedCreateInputSchema
      ]),
      update: z.union([
        NafSectionUpdateInputSchema,
        NafSectionUncheckedUpdateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafSectionCreateManyArgsSchema: z.ZodType<Prisma.NafSectionCreateManyArgs> =
  z
    .object({
      data: z.union([
        NafSectionCreateManyInputSchema,
        NafSectionCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const NafSectionCreateManyAndReturnArgsSchema: z.ZodType<Prisma.NafSectionCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        NafSectionCreateManyInputSchema,
        NafSectionCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const NafSectionDeleteArgsSchema: z.ZodType<Prisma.NafSectionDeleteArgs> =
  z
    .object({
      select: NafSectionSelectSchema.optional(),
      include: NafSectionIncludeSchema.optional(),
      where: NafSectionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafSectionUpdateArgsSchema: z.ZodType<Prisma.NafSectionUpdateArgs> =
  z
    .object({
      select: NafSectionSelectSchema.optional(),
      include: NafSectionIncludeSchema.optional(),
      data: z.union([
        NafSectionUpdateInputSchema,
        NafSectionUncheckedUpdateInputSchema
      ]),
      where: NafSectionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafSectionUpdateManyArgsSchema: z.ZodType<Prisma.NafSectionUpdateManyArgs> =
  z
    .object({
      data: z.union([
        NafSectionUpdateManyMutationInputSchema,
        NafSectionUncheckedUpdateManyInputSchema
      ]),
      where: NafSectionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const NafSectionUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.NafSectionUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        NafSectionUpdateManyMutationInputSchema,
        NafSectionUncheckedUpdateManyInputSchema
      ]),
      where: NafSectionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const NafSectionDeleteManyArgsSchema: z.ZodType<Prisma.NafSectionDeleteManyArgs> =
  z
    .object({
      where: NafSectionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const NafDivisionCreateArgsSchema: z.ZodType<Prisma.NafDivisionCreateArgs> =
  z
    .object({
      select: NafDivisionSelectSchema.optional(),
      include: NafDivisionIncludeSchema.optional(),
      data: z.union([
        NafDivisionCreateInputSchema,
        NafDivisionUncheckedCreateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafDivisionUpsertArgsSchema: z.ZodType<Prisma.NafDivisionUpsertArgs> =
  z
    .object({
      select: NafDivisionSelectSchema.optional(),
      include: NafDivisionIncludeSchema.optional(),
      where: NafDivisionWhereUniqueInputSchema,
      create: z.union([
        NafDivisionCreateInputSchema,
        NafDivisionUncheckedCreateInputSchema
      ]),
      update: z.union([
        NafDivisionUpdateInputSchema,
        NafDivisionUncheckedUpdateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafDivisionCreateManyArgsSchema: z.ZodType<Prisma.NafDivisionCreateManyArgs> =
  z
    .object({
      data: z.union([
        NafDivisionCreateManyInputSchema,
        NafDivisionCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const NafDivisionCreateManyAndReturnArgsSchema: z.ZodType<Prisma.NafDivisionCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        NafDivisionCreateManyInputSchema,
        NafDivisionCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const NafDivisionDeleteArgsSchema: z.ZodType<Prisma.NafDivisionDeleteArgs> =
  z
    .object({
      select: NafDivisionSelectSchema.optional(),
      include: NafDivisionIncludeSchema.optional(),
      where: NafDivisionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafDivisionUpdateArgsSchema: z.ZodType<Prisma.NafDivisionUpdateArgs> =
  z
    .object({
      select: NafDivisionSelectSchema.optional(),
      include: NafDivisionIncludeSchema.optional(),
      data: z.union([
        NafDivisionUpdateInputSchema,
        NafDivisionUncheckedUpdateInputSchema
      ]),
      where: NafDivisionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const NafDivisionUpdateManyArgsSchema: z.ZodType<Prisma.NafDivisionUpdateManyArgs> =
  z
    .object({
      data: z.union([
        NafDivisionUpdateManyMutationInputSchema,
        NafDivisionUncheckedUpdateManyInputSchema
      ]),
      where: NafDivisionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const NafDivisionUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.NafDivisionUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        NafDivisionUpdateManyMutationInputSchema,
        NafDivisionUncheckedUpdateManyInputSchema
      ]),
      where: NafDivisionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const NafDivisionDeleteManyArgsSchema: z.ZodType<Prisma.NafDivisionDeleteManyArgs> =
  z
    .object({
      where: NafDivisionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const NafGroupCreateArgsSchema: z.ZodType<Prisma.NafGroupCreateArgs> = z
  .object({
    select: NafGroupSelectSchema.optional(),
    include: NafGroupIncludeSchema.optional(),
    data: z.union([
      NafGroupCreateInputSchema,
      NafGroupUncheckedCreateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const NafGroupUpsertArgsSchema: z.ZodType<Prisma.NafGroupUpsertArgs> = z
  .object({
    select: NafGroupSelectSchema.optional(),
    include: NafGroupIncludeSchema.optional(),
    where: NafGroupWhereUniqueInputSchema,
    create: z.union([
      NafGroupCreateInputSchema,
      NafGroupUncheckedCreateInputSchema
    ]),
    update: z.union([
      NafGroupUpdateInputSchema,
      NafGroupUncheckedUpdateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const NafGroupCreateManyArgsSchema: z.ZodType<Prisma.NafGroupCreateManyArgs> =
  z
    .object({
      data: z.union([
        NafGroupCreateManyInputSchema,
        NafGroupCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const NafGroupCreateManyAndReturnArgsSchema: z.ZodType<Prisma.NafGroupCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        NafGroupCreateManyInputSchema,
        NafGroupCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const NafGroupDeleteArgsSchema: z.ZodType<Prisma.NafGroupDeleteArgs> = z
  .object({
    select: NafGroupSelectSchema.optional(),
    include: NafGroupIncludeSchema.optional(),
    where: NafGroupWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const NafGroupUpdateArgsSchema: z.ZodType<Prisma.NafGroupUpdateArgs> = z
  .object({
    select: NafGroupSelectSchema.optional(),
    include: NafGroupIncludeSchema.optional(),
    data: z.union([
      NafGroupUpdateInputSchema,
      NafGroupUncheckedUpdateInputSchema
    ]),
    where: NafGroupWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const NafGroupUpdateManyArgsSchema: z.ZodType<Prisma.NafGroupUpdateManyArgs> =
  z
    .object({
      data: z.union([
        NafGroupUpdateManyMutationInputSchema,
        NafGroupUncheckedUpdateManyInputSchema
      ]),
      where: NafGroupWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const NafGroupUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.NafGroupUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        NafGroupUpdateManyMutationInputSchema,
        NafGroupUncheckedUpdateManyInputSchema
      ]),
      where: NafGroupWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const NafGroupDeleteManyArgsSchema: z.ZodType<Prisma.NafGroupDeleteManyArgs> =
  z
    .object({
      where: NafGroupWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const NafClassCreateArgsSchema: z.ZodType<Prisma.NafClassCreateArgs> = z
  .object({
    select: NafClassSelectSchema.optional(),
    include: NafClassIncludeSchema.optional(),
    data: z.union([
      NafClassCreateInputSchema,
      NafClassUncheckedCreateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const NafClassUpsertArgsSchema: z.ZodType<Prisma.NafClassUpsertArgs> = z
  .object({
    select: NafClassSelectSchema.optional(),
    include: NafClassIncludeSchema.optional(),
    where: NafClassWhereUniqueInputSchema,
    create: z.union([
      NafClassCreateInputSchema,
      NafClassUncheckedCreateInputSchema
    ]),
    update: z.union([
      NafClassUpdateInputSchema,
      NafClassUncheckedUpdateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const NafClassCreateManyArgsSchema: z.ZodType<Prisma.NafClassCreateManyArgs> =
  z
    .object({
      data: z.union([
        NafClassCreateManyInputSchema,
        NafClassCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const NafClassCreateManyAndReturnArgsSchema: z.ZodType<Prisma.NafClassCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        NafClassCreateManyInputSchema,
        NafClassCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const NafClassDeleteArgsSchema: z.ZodType<Prisma.NafClassDeleteArgs> = z
  .object({
    select: NafClassSelectSchema.optional(),
    include: NafClassIncludeSchema.optional(),
    where: NafClassWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const NafClassUpdateArgsSchema: z.ZodType<Prisma.NafClassUpdateArgs> = z
  .object({
    select: NafClassSelectSchema.optional(),
    include: NafClassIncludeSchema.optional(),
    data: z.union([
      NafClassUpdateInputSchema,
      NafClassUncheckedUpdateInputSchema
    ]),
    where: NafClassWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const NafClassUpdateManyArgsSchema: z.ZodType<Prisma.NafClassUpdateManyArgs> =
  z
    .object({
      data: z.union([
        NafClassUpdateManyMutationInputSchema,
        NafClassUncheckedUpdateManyInputSchema
      ]),
      where: NafClassWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const NafClassUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.NafClassUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        NafClassUpdateManyMutationInputSchema,
        NafClassUncheckedUpdateManyInputSchema
      ]),
      where: NafClassWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const NafClassDeleteManyArgsSchema: z.ZodType<Prisma.NafClassDeleteManyArgs> =
  z
    .object({
      where: NafClassWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const NafCodeCreateArgsSchema: z.ZodType<Prisma.NafCodeCreateArgs> = z
  .object({
    select: NafCodeSelectSchema.optional(),
    include: NafCodeIncludeSchema.optional(),
    data: z.union([
      NafCodeCreateInputSchema,
      NafCodeUncheckedCreateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const NafCodeUpsertArgsSchema: z.ZodType<Prisma.NafCodeUpsertArgs> = z
  .object({
    select: NafCodeSelectSchema.optional(),
    include: NafCodeIncludeSchema.optional(),
    where: NafCodeWhereUniqueInputSchema,
    create: z.union([
      NafCodeCreateInputSchema,
      NafCodeUncheckedCreateInputSchema
    ]),
    update: z.union([
      NafCodeUpdateInputSchema,
      NafCodeUncheckedUpdateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const NafCodeCreateManyArgsSchema: z.ZodType<Prisma.NafCodeCreateManyArgs> =
  z
    .object({
      data: z.union([
        NafCodeCreateManyInputSchema,
        NafCodeCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const NafCodeCreateManyAndReturnArgsSchema: z.ZodType<Prisma.NafCodeCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        NafCodeCreateManyInputSchema,
        NafCodeCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const NafCodeDeleteArgsSchema: z.ZodType<Prisma.NafCodeDeleteArgs> = z
  .object({
    select: NafCodeSelectSchema.optional(),
    include: NafCodeIncludeSchema.optional(),
    where: NafCodeWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const NafCodeUpdateArgsSchema: z.ZodType<Prisma.NafCodeUpdateArgs> = z
  .object({
    select: NafCodeSelectSchema.optional(),
    include: NafCodeIncludeSchema.optional(),
    data: z.union([
      NafCodeUpdateInputSchema,
      NafCodeUncheckedUpdateInputSchema
    ]),
    where: NafCodeWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const NafCodeUpdateManyArgsSchema: z.ZodType<Prisma.NafCodeUpdateManyArgs> =
  z
    .object({
      data: z.union([
        NafCodeUpdateManyMutationInputSchema,
        NafCodeUncheckedUpdateManyInputSchema
      ]),
      where: NafCodeWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const NafCodeUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.NafCodeUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        NafCodeUpdateManyMutationInputSchema,
        NafCodeUncheckedUpdateManyInputSchema
      ]),
      where: NafCodeWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const NafCodeDeleteManyArgsSchema: z.ZodType<Prisma.NafCodeDeleteManyArgs> =
  z
    .object({
      where: NafCodeWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const OutboxCreateArgsSchema: z.ZodType<Prisma.OutboxCreateArgs> = z
  .object({
    select: OutboxSelectSchema.optional(),
    include: OutboxIncludeSchema.optional(),
    data: z.union([OutboxCreateInputSchema, OutboxUncheckedCreateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const OutboxUpsertArgsSchema: z.ZodType<Prisma.OutboxUpsertArgs> = z
  .object({
    select: OutboxSelectSchema.optional(),
    include: OutboxIncludeSchema.optional(),
    where: OutboxWhereUniqueInputSchema,
    create: z.union([
      OutboxCreateInputSchema,
      OutboxUncheckedCreateInputSchema
    ]),
    update: z.union([
      OutboxUpdateInputSchema,
      OutboxUncheckedUpdateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const OutboxCreateManyArgsSchema: z.ZodType<Prisma.OutboxCreateManyArgs> =
  z
    .object({
      data: z.union([
        OutboxCreateManyInputSchema,
        OutboxCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const OutboxCreateManyAndReturnArgsSchema: z.ZodType<Prisma.OutboxCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        OutboxCreateManyInputSchema,
        OutboxCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const OutboxDeleteArgsSchema: z.ZodType<Prisma.OutboxDeleteArgs> = z
  .object({
    select: OutboxSelectSchema.optional(),
    include: OutboxIncludeSchema.optional(),
    where: OutboxWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const OutboxUpdateArgsSchema: z.ZodType<Prisma.OutboxUpdateArgs> = z
  .object({
    select: OutboxSelectSchema.optional(),
    include: OutboxIncludeSchema.optional(),
    data: z.union([OutboxUpdateInputSchema, OutboxUncheckedUpdateInputSchema]),
    where: OutboxWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const OutboxUpdateManyArgsSchema: z.ZodType<Prisma.OutboxUpdateManyArgs> =
  z
    .object({
      data: z.union([
        OutboxUpdateManyMutationInputSchema,
        OutboxUncheckedUpdateManyInputSchema
      ]),
      where: OutboxWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const OutboxUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.OutboxUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        OutboxUpdateManyMutationInputSchema,
        OutboxUncheckedUpdateManyInputSchema
      ]),
      where: OutboxWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const OutboxDeleteManyArgsSchema: z.ZodType<Prisma.OutboxDeleteManyArgs> =
  z
    .object({
      where: OutboxWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const ListCreateArgsSchema: z.ZodType<Prisma.ListCreateArgs> = z
  .object({
    select: ListSelectSchema.optional(),
    include: ListIncludeSchema.optional(),
    data: z.union([ListCreateInputSchema, ListUncheckedCreateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const ListUpsertArgsSchema: z.ZodType<Prisma.ListUpsertArgs> = z
  .object({
    select: ListSelectSchema.optional(),
    include: ListIncludeSchema.optional(),
    where: ListWhereUniqueInputSchema,
    create: z.union([ListCreateInputSchema, ListUncheckedCreateInputSchema]),
    update: z.union([ListUpdateInputSchema, ListUncheckedUpdateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const ListCreateManyArgsSchema: z.ZodType<Prisma.ListCreateManyArgs> = z
  .object({
    data: z.union([
      ListCreateManyInputSchema,
      ListCreateManyInputSchema.array()
    ]),
    skipDuplicates: z.boolean().optional()
  })
  .strict();

export const ListCreateManyAndReturnArgsSchema: z.ZodType<Prisma.ListCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ListCreateManyInputSchema,
        ListCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ListDeleteArgsSchema: z.ZodType<Prisma.ListDeleteArgs> = z
  .object({
    select: ListSelectSchema.optional(),
    include: ListIncludeSchema.optional(),
    where: ListWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const ListUpdateArgsSchema: z.ZodType<Prisma.ListUpdateArgs> = z
  .object({
    select: ListSelectSchema.optional(),
    include: ListIncludeSchema.optional(),
    data: z.union([ListUpdateInputSchema, ListUncheckedUpdateInputSchema]),
    where: ListWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const ListUpdateManyArgsSchema: z.ZodType<Prisma.ListUpdateManyArgs> = z
  .object({
    data: z.union([
      ListUpdateManyMutationInputSchema,
      ListUncheckedUpdateManyInputSchema
    ]),
    where: ListWhereInputSchema.optional(),
    limit: z.number().optional()
  })
  .strict();

export const ListUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.ListUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ListUpdateManyMutationInputSchema,
        ListUncheckedUpdateManyInputSchema
      ]),
      where: ListWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const ListDeleteManyArgsSchema: z.ZodType<Prisma.ListDeleteManyArgs> = z
  .object({
    where: ListWhereInputSchema.optional(),
    limit: z.number().optional()
  })
  .strict();

export const CampaignCreateArgsSchema: z.ZodType<Prisma.CampaignCreateArgs> = z
  .object({
    select: CampaignSelectSchema.optional(),
    include: CampaignIncludeSchema.optional(),
    data: z.union([
      CampaignCreateInputSchema,
      CampaignUncheckedCreateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CampaignUpsertArgsSchema: z.ZodType<Prisma.CampaignUpsertArgs> = z
  .object({
    select: CampaignSelectSchema.optional(),
    include: CampaignIncludeSchema.optional(),
    where: CampaignWhereUniqueInputSchema,
    create: z.union([
      CampaignCreateInputSchema,
      CampaignUncheckedCreateInputSchema
    ]),
    update: z.union([
      CampaignUpdateInputSchema,
      CampaignUncheckedUpdateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CampaignCreateManyArgsSchema: z.ZodType<Prisma.CampaignCreateManyArgs> =
  z
    .object({
      data: z.union([
        CampaignCreateManyInputSchema,
        CampaignCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const CampaignCreateManyAndReturnArgsSchema: z.ZodType<Prisma.CampaignCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CampaignCreateManyInputSchema,
        CampaignCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const CampaignDeleteArgsSchema: z.ZodType<Prisma.CampaignDeleteArgs> = z
  .object({
    select: CampaignSelectSchema.optional(),
    include: CampaignIncludeSchema.optional(),
    where: CampaignWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CampaignUpdateArgsSchema: z.ZodType<Prisma.CampaignUpdateArgs> = z
  .object({
    select: CampaignSelectSchema.optional(),
    include: CampaignIncludeSchema.optional(),
    data: z.union([
      CampaignUpdateInputSchema,
      CampaignUncheckedUpdateInputSchema
    ]),
    where: CampaignWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CampaignUpdateManyArgsSchema: z.ZodType<Prisma.CampaignUpdateManyArgs> =
  z
    .object({
      data: z.union([
        CampaignUpdateManyMutationInputSchema,
        CampaignUncheckedUpdateManyInputSchema
      ]),
      where: CampaignWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const CampaignUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.CampaignUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CampaignUpdateManyMutationInputSchema,
        CampaignUncheckedUpdateManyInputSchema
      ]),
      where: CampaignWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const CampaignDeleteManyArgsSchema: z.ZodType<Prisma.CampaignDeleteManyArgs> =
  z
    .object({
      where: CampaignWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const EmailCreateArgsSchema: z.ZodType<Prisma.EmailCreateArgs> = z
  .object({
    select: EmailSelectSchema.optional(),
    include: EmailIncludeSchema.optional(),
    data: z.union([EmailCreateInputSchema, EmailUncheckedCreateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const EmailUpsertArgsSchema: z.ZodType<Prisma.EmailUpsertArgs> = z
  .object({
    select: EmailSelectSchema.optional(),
    include: EmailIncludeSchema.optional(),
    where: EmailWhereUniqueInputSchema,
    create: z.union([EmailCreateInputSchema, EmailUncheckedCreateInputSchema]),
    update: z.union([EmailUpdateInputSchema, EmailUncheckedUpdateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const EmailCreateManyArgsSchema: z.ZodType<Prisma.EmailCreateManyArgs> =
  z
    .object({
      data: z.union([
        EmailCreateManyInputSchema,
        EmailCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const EmailCreateManyAndReturnArgsSchema: z.ZodType<Prisma.EmailCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        EmailCreateManyInputSchema,
        EmailCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const EmailDeleteArgsSchema: z.ZodType<Prisma.EmailDeleteArgs> = z
  .object({
    select: EmailSelectSchema.optional(),
    include: EmailIncludeSchema.optional(),
    where: EmailWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const EmailUpdateArgsSchema: z.ZodType<Prisma.EmailUpdateArgs> = z
  .object({
    select: EmailSelectSchema.optional(),
    include: EmailIncludeSchema.optional(),
    data: z.union([EmailUpdateInputSchema, EmailUncheckedUpdateInputSchema]),
    where: EmailWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const EmailUpdateManyArgsSchema: z.ZodType<Prisma.EmailUpdateManyArgs> =
  z
    .object({
      data: z.union([
        EmailUpdateManyMutationInputSchema,
        EmailUncheckedUpdateManyInputSchema
      ]),
      where: EmailWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const EmailUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.EmailUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        EmailUpdateManyMutationInputSchema,
        EmailUncheckedUpdateManyInputSchema
      ]),
      where: EmailWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const EmailDeleteManyArgsSchema: z.ZodType<Prisma.EmailDeleteManyArgs> =
  z
    .object({
      where: EmailWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const MediaCreateArgsSchema: z.ZodType<Prisma.MediaCreateArgs> = z
  .object({
    select: MediaSelectSchema.optional(),
    data: z.union([MediaCreateInputSchema, MediaUncheckedCreateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const MediaUpsertArgsSchema: z.ZodType<Prisma.MediaUpsertArgs> = z
  .object({
    select: MediaSelectSchema.optional(),
    where: MediaWhereUniqueInputSchema,
    create: z.union([MediaCreateInputSchema, MediaUncheckedCreateInputSchema]),
    update: z.union([MediaUpdateInputSchema, MediaUncheckedUpdateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const MediaCreateManyArgsSchema: z.ZodType<Prisma.MediaCreateManyArgs> =
  z
    .object({
      data: z.union([
        MediaCreateManyInputSchema,
        MediaCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const MediaCreateManyAndReturnArgsSchema: z.ZodType<Prisma.MediaCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        MediaCreateManyInputSchema,
        MediaCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const MediaDeleteArgsSchema: z.ZodType<Prisma.MediaDeleteArgs> = z
  .object({
    select: MediaSelectSchema.optional(),
    where: MediaWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const MediaUpdateArgsSchema: z.ZodType<Prisma.MediaUpdateArgs> = z
  .object({
    select: MediaSelectSchema.optional(),
    data: z.union([MediaUpdateInputSchema, MediaUncheckedUpdateInputSchema]),
    where: MediaWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const MediaUpdateManyArgsSchema: z.ZodType<Prisma.MediaUpdateManyArgs> =
  z
    .object({
      data: z.union([
        MediaUpdateManyMutationInputSchema,
        MediaUncheckedUpdateManyInputSchema
      ]),
      where: MediaWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const MediaUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.MediaUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        MediaUpdateManyMutationInputSchema,
        MediaUncheckedUpdateManyInputSchema
      ]),
      where: MediaWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const MediaDeleteManyArgsSchema: z.ZodType<Prisma.MediaDeleteManyArgs> =
  z
    .object({
      where: MediaWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const ClickCreateArgsSchema: z.ZodType<Prisma.ClickCreateArgs> = z
  .object({
    select: ClickSelectSchema.optional(),
    include: ClickIncludeSchema.optional(),
    data: z
      .union([ClickCreateInputSchema, ClickUncheckedCreateInputSchema])
      .optional(),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const ClickUpsertArgsSchema: z.ZodType<Prisma.ClickUpsertArgs> = z
  .object({
    select: ClickSelectSchema.optional(),
    include: ClickIncludeSchema.optional(),
    where: ClickWhereUniqueInputSchema,
    create: z.union([ClickCreateInputSchema, ClickUncheckedCreateInputSchema]),
    update: z.union([ClickUpdateInputSchema, ClickUncheckedUpdateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const ClickCreateManyArgsSchema: z.ZodType<Prisma.ClickCreateManyArgs> =
  z
    .object({
      data: z.union([
        ClickCreateManyInputSchema,
        ClickCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ClickCreateManyAndReturnArgsSchema: z.ZodType<Prisma.ClickCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ClickCreateManyInputSchema,
        ClickCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ClickDeleteArgsSchema: z.ZodType<Prisma.ClickDeleteArgs> = z
  .object({
    select: ClickSelectSchema.optional(),
    include: ClickIncludeSchema.optional(),
    where: ClickWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const ClickUpdateArgsSchema: z.ZodType<Prisma.ClickUpdateArgs> = z
  .object({
    select: ClickSelectSchema.optional(),
    include: ClickIncludeSchema.optional(),
    data: z.union([ClickUpdateInputSchema, ClickUncheckedUpdateInputSchema]),
    where: ClickWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const ClickUpdateManyArgsSchema: z.ZodType<Prisma.ClickUpdateManyArgs> =
  z
    .object({
      data: z.union([
        ClickUpdateManyMutationInputSchema,
        ClickUncheckedUpdateManyInputSchema
      ]),
      where: ClickWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const ClickUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.ClickUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ClickUpdateManyMutationInputSchema,
        ClickUncheckedUpdateManyInputSchema
      ]),
      where: ClickWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const ClickDeleteManyArgsSchema: z.ZodType<Prisma.ClickDeleteManyArgs> =
  z
    .object({
      where: ClickWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const LinkCreateArgsSchema: z.ZodType<Prisma.LinkCreateArgs> = z
  .object({
    select: LinkSelectSchema.optional(),
    include: LinkIncludeSchema.optional(),
    data: z.union([LinkCreateInputSchema, LinkUncheckedCreateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const LinkUpsertArgsSchema: z.ZodType<Prisma.LinkUpsertArgs> = z
  .object({
    select: LinkSelectSchema.optional(),
    include: LinkIncludeSchema.optional(),
    where: LinkWhereUniqueInputSchema,
    create: z.union([LinkCreateInputSchema, LinkUncheckedCreateInputSchema]),
    update: z.union([LinkUpdateInputSchema, LinkUncheckedUpdateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const LinkCreateManyArgsSchema: z.ZodType<Prisma.LinkCreateManyArgs> = z
  .object({
    data: z.union([
      LinkCreateManyInputSchema,
      LinkCreateManyInputSchema.array()
    ]),
    skipDuplicates: z.boolean().optional()
  })
  .strict();

export const LinkCreateManyAndReturnArgsSchema: z.ZodType<Prisma.LinkCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        LinkCreateManyInputSchema,
        LinkCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const LinkDeleteArgsSchema: z.ZodType<Prisma.LinkDeleteArgs> = z
  .object({
    select: LinkSelectSchema.optional(),
    include: LinkIncludeSchema.optional(),
    where: LinkWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const LinkUpdateArgsSchema: z.ZodType<Prisma.LinkUpdateArgs> = z
  .object({
    select: LinkSelectSchema.optional(),
    include: LinkIncludeSchema.optional(),
    data: z.union([LinkUpdateInputSchema, LinkUncheckedUpdateInputSchema]),
    where: LinkWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const LinkUpdateManyArgsSchema: z.ZodType<Prisma.LinkUpdateManyArgs> = z
  .object({
    data: z.union([
      LinkUpdateManyMutationInputSchema,
      LinkUncheckedUpdateManyInputSchema
    ]),
    where: LinkWhereInputSchema.optional(),
    limit: z.number().optional()
  })
  .strict();

export const LinkUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.LinkUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        LinkUpdateManyMutationInputSchema,
        LinkUncheckedUpdateManyInputSchema
      ]),
      where: LinkWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const LinkDeleteManyArgsSchema: z.ZodType<Prisma.LinkDeleteManyArgs> = z
  .object({
    where: LinkWhereInputSchema.optional(),
    limit: z.number().optional()
  })
  .strict();

export const BlockCreateArgsSchema: z.ZodType<Prisma.BlockCreateArgs> = z
  .object({
    select: BlockSelectSchema.optional(),
    include: BlockIncludeSchema.optional(),
    data: z.union([BlockCreateInputSchema, BlockUncheckedCreateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const BlockUpsertArgsSchema: z.ZodType<Prisma.BlockUpsertArgs> = z
  .object({
    select: BlockSelectSchema.optional(),
    include: BlockIncludeSchema.optional(),
    where: BlockWhereUniqueInputSchema,
    create: z.union([BlockCreateInputSchema, BlockUncheckedCreateInputSchema]),
    update: z.union([BlockUpdateInputSchema, BlockUncheckedUpdateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const BlockCreateManyArgsSchema: z.ZodType<Prisma.BlockCreateManyArgs> =
  z
    .object({
      data: z.union([
        BlockCreateManyInputSchema,
        BlockCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const BlockCreateManyAndReturnArgsSchema: z.ZodType<Prisma.BlockCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        BlockCreateManyInputSchema,
        BlockCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const BlockDeleteArgsSchema: z.ZodType<Prisma.BlockDeleteArgs> = z
  .object({
    select: BlockSelectSchema.optional(),
    include: BlockIncludeSchema.optional(),
    where: BlockWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const BlockUpdateArgsSchema: z.ZodType<Prisma.BlockUpdateArgs> = z
  .object({
    select: BlockSelectSchema.optional(),
    include: BlockIncludeSchema.optional(),
    data: z.union([BlockUpdateInputSchema, BlockUncheckedUpdateInputSchema]),
    where: BlockWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const BlockUpdateManyArgsSchema: z.ZodType<Prisma.BlockUpdateManyArgs> =
  z
    .object({
      data: z.union([
        BlockUpdateManyMutationInputSchema,
        BlockUncheckedUpdateManyInputSchema
      ]),
      where: BlockWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const BlockUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.BlockUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        BlockUpdateManyMutationInputSchema,
        BlockUncheckedUpdateManyInputSchema
      ]),
      where: BlockWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const BlockDeleteManyArgsSchema: z.ZodType<Prisma.BlockDeleteManyArgs> =
  z
    .object({
      where: BlockWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const LikeCreateArgsSchema: z.ZodType<Prisma.LikeCreateArgs> = z
  .object({
    select: LikeSelectSchema.optional(),
    include: LikeIncludeSchema.optional(),
    data: z.union([LikeCreateInputSchema, LikeUncheckedCreateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const LikeUpsertArgsSchema: z.ZodType<Prisma.LikeUpsertArgs> = z
  .object({
    select: LikeSelectSchema.optional(),
    include: LikeIncludeSchema.optional(),
    where: LikeWhereUniqueInputSchema,
    create: z.union([LikeCreateInputSchema, LikeUncheckedCreateInputSchema]),
    update: z.union([LikeUpdateInputSchema, LikeUncheckedUpdateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const LikeCreateManyArgsSchema: z.ZodType<Prisma.LikeCreateManyArgs> = z
  .object({
    data: z.union([
      LikeCreateManyInputSchema,
      LikeCreateManyInputSchema.array()
    ]),
    skipDuplicates: z.boolean().optional()
  })
  .strict();

export const LikeCreateManyAndReturnArgsSchema: z.ZodType<Prisma.LikeCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        LikeCreateManyInputSchema,
        LikeCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const LikeDeleteArgsSchema: z.ZodType<Prisma.LikeDeleteArgs> = z
  .object({
    select: LikeSelectSchema.optional(),
    include: LikeIncludeSchema.optional(),
    where: LikeWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const LikeUpdateArgsSchema: z.ZodType<Prisma.LikeUpdateArgs> = z
  .object({
    select: LikeSelectSchema.optional(),
    include: LikeIncludeSchema.optional(),
    data: z.union([LikeUpdateInputSchema, LikeUncheckedUpdateInputSchema]),
    where: LikeWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const LikeUpdateManyArgsSchema: z.ZodType<Prisma.LikeUpdateManyArgs> = z
  .object({
    data: z.union([
      LikeUpdateManyMutationInputSchema,
      LikeUncheckedUpdateManyInputSchema
    ]),
    where: LikeWhereInputSchema.optional(),
    limit: z.number().optional()
  })
  .strict();

export const LikeUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.LikeUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        LikeUpdateManyMutationInputSchema,
        LikeUncheckedUpdateManyInputSchema
      ]),
      where: LikeWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const LikeDeleteManyArgsSchema: z.ZodType<Prisma.LikeDeleteManyArgs> = z
  .object({
    where: LikeWhereInputSchema.optional(),
    limit: z.number().optional()
  })
  .strict();

export const SiteCreateArgsSchema: z.ZodType<Prisma.SiteCreateArgs> = z
  .object({
    select: SiteSelectSchema.optional(),
    include: SiteIncludeSchema.optional(),
    data: z.union([SiteCreateInputSchema, SiteUncheckedCreateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const SiteUpsertArgsSchema: z.ZodType<Prisma.SiteUpsertArgs> = z
  .object({
    select: SiteSelectSchema.optional(),
    include: SiteIncludeSchema.optional(),
    where: SiteWhereUniqueInputSchema,
    create: z.union([SiteCreateInputSchema, SiteUncheckedCreateInputSchema]),
    update: z.union([SiteUpdateInputSchema, SiteUncheckedUpdateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const SiteCreateManyArgsSchema: z.ZodType<Prisma.SiteCreateManyArgs> = z
  .object({
    data: z.union([
      SiteCreateManyInputSchema,
      SiteCreateManyInputSchema.array()
    ]),
    skipDuplicates: z.boolean().optional()
  })
  .strict();

export const SiteCreateManyAndReturnArgsSchema: z.ZodType<Prisma.SiteCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        SiteCreateManyInputSchema,
        SiteCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const SiteDeleteArgsSchema: z.ZodType<Prisma.SiteDeleteArgs> = z
  .object({
    select: SiteSelectSchema.optional(),
    include: SiteIncludeSchema.optional(),
    where: SiteWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const SiteUpdateArgsSchema: z.ZodType<Prisma.SiteUpdateArgs> = z
  .object({
    select: SiteSelectSchema.optional(),
    include: SiteIncludeSchema.optional(),
    data: z.union([SiteUpdateInputSchema, SiteUncheckedUpdateInputSchema]),
    where: SiteWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const SiteUpdateManyArgsSchema: z.ZodType<Prisma.SiteUpdateManyArgs> = z
  .object({
    data: z.union([
      SiteUpdateManyMutationInputSchema,
      SiteUncheckedUpdateManyInputSchema
    ]),
    where: SiteWhereInputSchema.optional(),
    limit: z.number().optional()
  })
  .strict();

export const SiteUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.SiteUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        SiteUpdateManyMutationInputSchema,
        SiteUncheckedUpdateManyInputSchema
      ]),
      where: SiteWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const SiteDeleteManyArgsSchema: z.ZodType<Prisma.SiteDeleteManyArgs> = z
  .object({
    where: SiteWhereInputSchema.optional(),
    limit: z.number().optional()
  })
  .strict();

export const SubscriberCreateArgsSchema: z.ZodType<Prisma.SubscriberCreateArgs> =
  z
    .object({
      select: SubscriberSelectSchema.optional(),
      include: SubscriberIncludeSchema.optional(),
      data: z.union([
        SubscriberCreateInputSchema,
        SubscriberUncheckedCreateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SubscriberUpsertArgsSchema: z.ZodType<Prisma.SubscriberUpsertArgs> =
  z
    .object({
      select: SubscriberSelectSchema.optional(),
      include: SubscriberIncludeSchema.optional(),
      where: SubscriberWhereUniqueInputSchema,
      create: z.union([
        SubscriberCreateInputSchema,
        SubscriberUncheckedCreateInputSchema
      ]),
      update: z.union([
        SubscriberUpdateInputSchema,
        SubscriberUncheckedUpdateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SubscriberCreateManyArgsSchema: z.ZodType<Prisma.SubscriberCreateManyArgs> =
  z
    .object({
      data: z.union([
        SubscriberCreateManyInputSchema,
        SubscriberCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const SubscriberCreateManyAndReturnArgsSchema: z.ZodType<Prisma.SubscriberCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        SubscriberCreateManyInputSchema,
        SubscriberCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const SubscriberDeleteArgsSchema: z.ZodType<Prisma.SubscriberDeleteArgs> =
  z
    .object({
      select: SubscriberSelectSchema.optional(),
      include: SubscriberIncludeSchema.optional(),
      where: SubscriberWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SubscriberUpdateArgsSchema: z.ZodType<Prisma.SubscriberUpdateArgs> =
  z
    .object({
      select: SubscriberSelectSchema.optional(),
      include: SubscriberIncludeSchema.optional(),
      data: z.union([
        SubscriberUpdateInputSchema,
        SubscriberUncheckedUpdateInputSchema
      ]),
      where: SubscriberWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const SubscriberUpdateManyArgsSchema: z.ZodType<Prisma.SubscriberUpdateManyArgs> =
  z
    .object({
      data: z.union([
        SubscriberUpdateManyMutationInputSchema,
        SubscriberUncheckedUpdateManyInputSchema
      ]),
      where: SubscriberWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const SubscriberUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.SubscriberUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        SubscriberUpdateManyMutationInputSchema,
        SubscriberUncheckedUpdateManyInputSchema
      ]),
      where: SubscriberWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const SubscriberDeleteManyArgsSchema: z.ZodType<Prisma.SubscriberDeleteManyArgs> =
  z
    .object({
      where: SubscriberWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const ReservationCreateArgsSchema: z.ZodType<Prisma.ReservationCreateArgs> =
  z
    .object({
      select: ReservationSelectSchema.optional(),
      include: ReservationIncludeSchema.optional(),
      data: z.union([
        ReservationCreateInputSchema,
        ReservationUncheckedCreateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ReservationUpsertArgsSchema: z.ZodType<Prisma.ReservationUpsertArgs> =
  z
    .object({
      select: ReservationSelectSchema.optional(),
      include: ReservationIncludeSchema.optional(),
      where: ReservationWhereUniqueInputSchema,
      create: z.union([
        ReservationCreateInputSchema,
        ReservationUncheckedCreateInputSchema
      ]),
      update: z.union([
        ReservationUpdateInputSchema,
        ReservationUncheckedUpdateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ReservationCreateManyArgsSchema: z.ZodType<Prisma.ReservationCreateManyArgs> =
  z
    .object({
      data: z.union([
        ReservationCreateManyInputSchema,
        ReservationCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ReservationCreateManyAndReturnArgsSchema: z.ZodType<Prisma.ReservationCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ReservationCreateManyInputSchema,
        ReservationCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ReservationDeleteArgsSchema: z.ZodType<Prisma.ReservationDeleteArgs> =
  z
    .object({
      select: ReservationSelectSchema.optional(),
      include: ReservationIncludeSchema.optional(),
      where: ReservationWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ReservationUpdateArgsSchema: z.ZodType<Prisma.ReservationUpdateArgs> =
  z
    .object({
      select: ReservationSelectSchema.optional(),
      include: ReservationIncludeSchema.optional(),
      data: z.union([
        ReservationUpdateInputSchema,
        ReservationUncheckedUpdateInputSchema
      ]),
      where: ReservationWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ReservationUpdateManyArgsSchema: z.ZodType<Prisma.ReservationUpdateManyArgs> =
  z
    .object({
      data: z.union([
        ReservationUpdateManyMutationInputSchema,
        ReservationUncheckedUpdateManyInputSchema
      ]),
      where: ReservationWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const ReservationUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.ReservationUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ReservationUpdateManyMutationInputSchema,
        ReservationUncheckedUpdateManyInputSchema
      ]),
      where: ReservationWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const ReservationDeleteManyArgsSchema: z.ZodType<Prisma.ReservationDeleteManyArgs> =
  z
    .object({
      where: ReservationWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const CategoryCreateArgsSchema: z.ZodType<Prisma.CategoryCreateArgs> = z
  .object({
    select: CategorySelectSchema.optional(),
    include: CategoryIncludeSchema.optional(),
    data: z.union([
      CategoryCreateInputSchema,
      CategoryUncheckedCreateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CategoryUpsertArgsSchema: z.ZodType<Prisma.CategoryUpsertArgs> = z
  .object({
    select: CategorySelectSchema.optional(),
    include: CategoryIncludeSchema.optional(),
    where: CategoryWhereUniqueInputSchema,
    create: z.union([
      CategoryCreateInputSchema,
      CategoryUncheckedCreateInputSchema
    ]),
    update: z.union([
      CategoryUpdateInputSchema,
      CategoryUncheckedUpdateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CategoryCreateManyArgsSchema: z.ZodType<Prisma.CategoryCreateManyArgs> =
  z
    .object({
      data: z.union([
        CategoryCreateManyInputSchema,
        CategoryCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const CategoryCreateManyAndReturnArgsSchema: z.ZodType<Prisma.CategoryCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CategoryCreateManyInputSchema,
        CategoryCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const CategoryDeleteArgsSchema: z.ZodType<Prisma.CategoryDeleteArgs> = z
  .object({
    select: CategorySelectSchema.optional(),
    include: CategoryIncludeSchema.optional(),
    where: CategoryWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CategoryUpdateArgsSchema: z.ZodType<Prisma.CategoryUpdateArgs> = z
  .object({
    select: CategorySelectSchema.optional(),
    include: CategoryIncludeSchema.optional(),
    data: z.union([
      CategoryUpdateInputSchema,
      CategoryUncheckedUpdateInputSchema
    ]),
    where: CategoryWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CategoryUpdateManyArgsSchema: z.ZodType<Prisma.CategoryUpdateManyArgs> =
  z
    .object({
      data: z.union([
        CategoryUpdateManyMutationInputSchema,
        CategoryUncheckedUpdateManyInputSchema
      ]),
      where: CategoryWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const CategoryUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.CategoryUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CategoryUpdateManyMutationInputSchema,
        CategoryUncheckedUpdateManyInputSchema
      ]),
      where: CategoryWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const CategoryDeleteManyArgsSchema: z.ZodType<Prisma.CategoryDeleteManyArgs> =
  z
    .object({
      where: CategoryWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const InventoryCreateArgsSchema: z.ZodType<Prisma.InventoryCreateArgs> =
  z
    .object({
      select: InventorySelectSchema.optional(),
      include: InventoryIncludeSchema.optional(),
      data: z.union([
        InventoryCreateInputSchema,
        InventoryUncheckedCreateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const InventoryUpsertArgsSchema: z.ZodType<Prisma.InventoryUpsertArgs> =
  z
    .object({
      select: InventorySelectSchema.optional(),
      include: InventoryIncludeSchema.optional(),
      where: InventoryWhereUniqueInputSchema,
      create: z.union([
        InventoryCreateInputSchema,
        InventoryUncheckedCreateInputSchema
      ]),
      update: z.union([
        InventoryUpdateInputSchema,
        InventoryUncheckedUpdateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const InventoryCreateManyArgsSchema: z.ZodType<Prisma.InventoryCreateManyArgs> =
  z
    .object({
      data: z.union([
        InventoryCreateManyInputSchema,
        InventoryCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const InventoryCreateManyAndReturnArgsSchema: z.ZodType<Prisma.InventoryCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        InventoryCreateManyInputSchema,
        InventoryCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const InventoryDeleteArgsSchema: z.ZodType<Prisma.InventoryDeleteArgs> =
  z
    .object({
      select: InventorySelectSchema.optional(),
      include: InventoryIncludeSchema.optional(),
      where: InventoryWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const InventoryUpdateArgsSchema: z.ZodType<Prisma.InventoryUpdateArgs> =
  z
    .object({
      select: InventorySelectSchema.optional(),
      include: InventoryIncludeSchema.optional(),
      data: z.union([
        InventoryUpdateInputSchema,
        InventoryUncheckedUpdateInputSchema
      ]),
      where: InventoryWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const InventoryUpdateManyArgsSchema: z.ZodType<Prisma.InventoryUpdateManyArgs> =
  z
    .object({
      data: z.union([
        InventoryUpdateManyMutationInputSchema,
        InventoryUncheckedUpdateManyInputSchema
      ]),
      where: InventoryWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const InventoryUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.InventoryUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        InventoryUpdateManyMutationInputSchema,
        InventoryUncheckedUpdateManyInputSchema
      ]),
      where: InventoryWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const InventoryDeleteManyArgsSchema: z.ZodType<Prisma.InventoryDeleteManyArgs> =
  z
    .object({
      where: InventoryWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const InventoryVariantCreateArgsSchema: z.ZodType<Prisma.InventoryVariantCreateArgs> =
  z
    .object({
      select: InventoryVariantSelectSchema.optional(),
      include: InventoryVariantIncludeSchema.optional(),
      data: z.union([
        InventoryVariantCreateInputSchema,
        InventoryVariantUncheckedCreateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const InventoryVariantUpsertArgsSchema: z.ZodType<Prisma.InventoryVariantUpsertArgs> =
  z
    .object({
      select: InventoryVariantSelectSchema.optional(),
      include: InventoryVariantIncludeSchema.optional(),
      where: InventoryVariantWhereUniqueInputSchema,
      create: z.union([
        InventoryVariantCreateInputSchema,
        InventoryVariantUncheckedCreateInputSchema
      ]),
      update: z.union([
        InventoryVariantUpdateInputSchema,
        InventoryVariantUncheckedUpdateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const InventoryVariantCreateManyArgsSchema: z.ZodType<Prisma.InventoryVariantCreateManyArgs> =
  z
    .object({
      data: z.union([
        InventoryVariantCreateManyInputSchema,
        InventoryVariantCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const InventoryVariantCreateManyAndReturnArgsSchema: z.ZodType<Prisma.InventoryVariantCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        InventoryVariantCreateManyInputSchema,
        InventoryVariantCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const InventoryVariantDeleteArgsSchema: z.ZodType<Prisma.InventoryVariantDeleteArgs> =
  z
    .object({
      select: InventoryVariantSelectSchema.optional(),
      include: InventoryVariantIncludeSchema.optional(),
      where: InventoryVariantWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const InventoryVariantUpdateArgsSchema: z.ZodType<Prisma.InventoryVariantUpdateArgs> =
  z
    .object({
      select: InventoryVariantSelectSchema.optional(),
      include: InventoryVariantIncludeSchema.optional(),
      data: z.union([
        InventoryVariantUpdateInputSchema,
        InventoryVariantUncheckedUpdateInputSchema
      ]),
      where: InventoryVariantWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const InventoryVariantUpdateManyArgsSchema: z.ZodType<Prisma.InventoryVariantUpdateManyArgs> =
  z
    .object({
      data: z.union([
        InventoryVariantUpdateManyMutationInputSchema,
        InventoryVariantUncheckedUpdateManyInputSchema
      ]),
      where: InventoryVariantWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const InventoryVariantUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.InventoryVariantUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        InventoryVariantUpdateManyMutationInputSchema,
        InventoryVariantUncheckedUpdateManyInputSchema
      ]),
      where: InventoryVariantWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const InventoryVariantDeleteManyArgsSchema: z.ZodType<Prisma.InventoryVariantDeleteManyArgs> =
  z
    .object({
      where: InventoryVariantWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const CronCreateArgsSchema: z.ZodType<Prisma.CronCreateArgs> = z
  .object({
    select: CronSelectSchema.optional(),
    include: CronIncludeSchema.optional(),
    data: z.union([CronCreateInputSchema, CronUncheckedCreateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CronUpsertArgsSchema: z.ZodType<Prisma.CronUpsertArgs> = z
  .object({
    select: CronSelectSchema.optional(),
    include: CronIncludeSchema.optional(),
    where: CronWhereUniqueInputSchema,
    create: z.union([CronCreateInputSchema, CronUncheckedCreateInputSchema]),
    update: z.union([CronUpdateInputSchema, CronUncheckedUpdateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CronCreateManyArgsSchema: z.ZodType<Prisma.CronCreateManyArgs> = z
  .object({
    data: z.union([
      CronCreateManyInputSchema,
      CronCreateManyInputSchema.array()
    ]),
    skipDuplicates: z.boolean().optional()
  })
  .strict();

export const CronCreateManyAndReturnArgsSchema: z.ZodType<Prisma.CronCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CronCreateManyInputSchema,
        CronCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const CronDeleteArgsSchema: z.ZodType<Prisma.CronDeleteArgs> = z
  .object({
    select: CronSelectSchema.optional(),
    include: CronIncludeSchema.optional(),
    where: CronWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CronUpdateArgsSchema: z.ZodType<Prisma.CronUpdateArgs> = z
  .object({
    select: CronSelectSchema.optional(),
    include: CronIncludeSchema.optional(),
    data: z.union([CronUpdateInputSchema, CronUncheckedUpdateInputSchema]),
    where: CronWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const CronUpdateManyArgsSchema: z.ZodType<Prisma.CronUpdateManyArgs> = z
  .object({
    data: z.union([
      CronUpdateManyMutationInputSchema,
      CronUncheckedUpdateManyInputSchema
    ]),
    where: CronWhereInputSchema.optional(),
    limit: z.number().optional()
  })
  .strict();

export const CronUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.CronUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CronUpdateManyMutationInputSchema,
        CronUncheckedUpdateManyInputSchema
      ]),
      where: CronWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const CronDeleteManyArgsSchema: z.ZodType<Prisma.CronDeleteManyArgs> = z
  .object({
    where: CronWhereInputSchema.optional(),
    limit: z.number().optional()
  })
  .strict();

export const HistoryCreateArgsSchema: z.ZodType<Prisma.HistoryCreateArgs> = z
  .object({
    select: HistorySelectSchema.optional(),
    include: HistoryIncludeSchema.optional(),
    data: z.union([
      HistoryCreateInputSchema,
      HistoryUncheckedCreateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const HistoryUpsertArgsSchema: z.ZodType<Prisma.HistoryUpsertArgs> = z
  .object({
    select: HistorySelectSchema.optional(),
    include: HistoryIncludeSchema.optional(),
    where: HistoryWhereUniqueInputSchema,
    create: z.union([
      HistoryCreateInputSchema,
      HistoryUncheckedCreateInputSchema
    ]),
    update: z.union([
      HistoryUpdateInputSchema,
      HistoryUncheckedUpdateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const HistoryCreateManyArgsSchema: z.ZodType<Prisma.HistoryCreateManyArgs> =
  z
    .object({
      data: z.union([
        HistoryCreateManyInputSchema,
        HistoryCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const HistoryCreateManyAndReturnArgsSchema: z.ZodType<Prisma.HistoryCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        HistoryCreateManyInputSchema,
        HistoryCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const HistoryDeleteArgsSchema: z.ZodType<Prisma.HistoryDeleteArgs> = z
  .object({
    select: HistorySelectSchema.optional(),
    include: HistoryIncludeSchema.optional(),
    where: HistoryWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const HistoryUpdateArgsSchema: z.ZodType<Prisma.HistoryUpdateArgs> = z
  .object({
    select: HistorySelectSchema.optional(),
    include: HistoryIncludeSchema.optional(),
    data: z.union([
      HistoryUpdateInputSchema,
      HistoryUncheckedUpdateInputSchema
    ]),
    where: HistoryWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const HistoryUpdateManyArgsSchema: z.ZodType<Prisma.HistoryUpdateManyArgs> =
  z
    .object({
      data: z.union([
        HistoryUpdateManyMutationInputSchema,
        HistoryUncheckedUpdateManyInputSchema
      ]),
      where: HistoryWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const HistoryUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.HistoryUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        HistoryUpdateManyMutationInputSchema,
        HistoryUncheckedUpdateManyInputSchema
      ]),
      where: HistoryWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const HistoryDeleteManyArgsSchema: z.ZodType<Prisma.HistoryDeleteManyArgs> =
  z
    .object({
      where: HistoryWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const UserCreateArgsSchema: z.ZodType<Prisma.UserCreateArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    data: z.union([UserCreateInputSchema, UserUncheckedCreateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const UserUpsertArgsSchema: z.ZodType<Prisma.UserUpsertArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    where: UserWhereUniqueInputSchema,
    create: z.union([UserCreateInputSchema, UserUncheckedCreateInputSchema]),
    update: z.union([UserUpdateInputSchema, UserUncheckedUpdateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const UserCreateManyArgsSchema: z.ZodType<Prisma.UserCreateManyArgs> = z
  .object({
    data: z.union([
      UserCreateManyInputSchema,
      UserCreateManyInputSchema.array()
    ]),
    skipDuplicates: z.boolean().optional()
  })
  .strict();

export const UserCreateManyAndReturnArgsSchema: z.ZodType<Prisma.UserCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        UserCreateManyInputSchema,
        UserCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const UserDeleteArgsSchema: z.ZodType<Prisma.UserDeleteArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    where: UserWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const UserUpdateArgsSchema: z.ZodType<Prisma.UserUpdateArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    data: z.union([UserUpdateInputSchema, UserUncheckedUpdateInputSchema]),
    where: UserWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const UserUpdateManyArgsSchema: z.ZodType<Prisma.UserUpdateManyArgs> = z
  .object({
    data: z.union([
      UserUpdateManyMutationInputSchema,
      UserUncheckedUpdateManyInputSchema
    ]),
    where: UserWhereInputSchema.optional(),
    limit: z.number().optional()
  })
  .strict();

export const UserUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.UserUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        UserUpdateManyMutationInputSchema,
        UserUncheckedUpdateManyInputSchema
      ]),
      where: UserWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const UserDeleteManyArgsSchema: z.ZodType<Prisma.UserDeleteManyArgs> = z
  .object({
    where: UserWhereInputSchema.optional(),
    limit: z.number().optional()
  })
  .strict();

export const MessageCreateArgsSchema: z.ZodType<Prisma.MessageCreateArgs> = z
  .object({
    select: MessageSelectSchema.optional(),
    include: MessageIncludeSchema.optional(),
    data: z.union([
      MessageCreateInputSchema,
      MessageUncheckedCreateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const MessageUpsertArgsSchema: z.ZodType<Prisma.MessageUpsertArgs> = z
  .object({
    select: MessageSelectSchema.optional(),
    include: MessageIncludeSchema.optional(),
    where: MessageWhereUniqueInputSchema,
    create: z.union([
      MessageCreateInputSchema,
      MessageUncheckedCreateInputSchema
    ]),
    update: z.union([
      MessageUpdateInputSchema,
      MessageUncheckedUpdateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const MessageCreateManyArgsSchema: z.ZodType<Prisma.MessageCreateManyArgs> =
  z
    .object({
      data: z.union([
        MessageCreateManyInputSchema,
        MessageCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const MessageCreateManyAndReturnArgsSchema: z.ZodType<Prisma.MessageCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        MessageCreateManyInputSchema,
        MessageCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const MessageDeleteArgsSchema: z.ZodType<Prisma.MessageDeleteArgs> = z
  .object({
    select: MessageSelectSchema.optional(),
    include: MessageIncludeSchema.optional(),
    where: MessageWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const MessageUpdateArgsSchema: z.ZodType<Prisma.MessageUpdateArgs> = z
  .object({
    select: MessageSelectSchema.optional(),
    include: MessageIncludeSchema.optional(),
    data: z.union([
      MessageUpdateInputSchema,
      MessageUncheckedUpdateInputSchema
    ]),
    where: MessageWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const MessageUpdateManyArgsSchema: z.ZodType<Prisma.MessageUpdateManyArgs> =
  z
    .object({
      data: z.union([
        MessageUpdateManyMutationInputSchema,
        MessageUncheckedUpdateManyInputSchema
      ]),
      where: MessageWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const MessageUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.MessageUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        MessageUpdateManyMutationInputSchema,
        MessageUncheckedUpdateManyInputSchema
      ]),
      where: MessageWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const MessageDeleteManyArgsSchema: z.ZodType<Prisma.MessageDeleteManyArgs> =
  z
    .object({
      where: MessageWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const FeedbackCreateArgsSchema: z.ZodType<Prisma.FeedbackCreateArgs> = z
  .object({
    select: FeedbackSelectSchema.optional(),
    include: FeedbackIncludeSchema.optional(),
    data: z.union([
      FeedbackCreateInputSchema,
      FeedbackUncheckedCreateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const FeedbackUpsertArgsSchema: z.ZodType<Prisma.FeedbackUpsertArgs> = z
  .object({
    select: FeedbackSelectSchema.optional(),
    include: FeedbackIncludeSchema.optional(),
    where: FeedbackWhereUniqueInputSchema,
    create: z.union([
      FeedbackCreateInputSchema,
      FeedbackUncheckedCreateInputSchema
    ]),
    update: z.union([
      FeedbackUpdateInputSchema,
      FeedbackUncheckedUpdateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const FeedbackCreateManyArgsSchema: z.ZodType<Prisma.FeedbackCreateManyArgs> =
  z
    .object({
      data: z.union([
        FeedbackCreateManyInputSchema,
        FeedbackCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const FeedbackCreateManyAndReturnArgsSchema: z.ZodType<Prisma.FeedbackCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        FeedbackCreateManyInputSchema,
        FeedbackCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const FeedbackDeleteArgsSchema: z.ZodType<Prisma.FeedbackDeleteArgs> = z
  .object({
    select: FeedbackSelectSchema.optional(),
    include: FeedbackIncludeSchema.optional(),
    where: FeedbackWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const FeedbackUpdateArgsSchema: z.ZodType<Prisma.FeedbackUpdateArgs> = z
  .object({
    select: FeedbackSelectSchema.optional(),
    include: FeedbackIncludeSchema.optional(),
    data: z.union([
      FeedbackUpdateInputSchema,
      FeedbackUncheckedUpdateInputSchema
    ]),
    where: FeedbackWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const FeedbackUpdateManyArgsSchema: z.ZodType<Prisma.FeedbackUpdateManyArgs> =
  z
    .object({
      data: z.union([
        FeedbackUpdateManyMutationInputSchema,
        FeedbackUncheckedUpdateManyInputSchema
      ]),
      where: FeedbackWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const FeedbackUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.FeedbackUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        FeedbackUpdateManyMutationInputSchema,
        FeedbackUncheckedUpdateManyInputSchema
      ]),
      where: FeedbackWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const FeedbackDeleteManyArgsSchema: z.ZodType<Prisma.FeedbackDeleteManyArgs> =
  z
    .object({
      where: FeedbackWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const QueueCreateArgsSchema: z.ZodType<Prisma.QueueCreateArgs> = z
  .object({
    select: QueueSelectSchema.optional(),
    include: QueueIncludeSchema.optional(),
    data: z.union([QueueCreateInputSchema, QueueUncheckedCreateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const QueueUpsertArgsSchema: z.ZodType<Prisma.QueueUpsertArgs> = z
  .object({
    select: QueueSelectSchema.optional(),
    include: QueueIncludeSchema.optional(),
    where: QueueWhereUniqueInputSchema,
    create: z.union([QueueCreateInputSchema, QueueUncheckedCreateInputSchema]),
    update: z.union([QueueUpdateInputSchema, QueueUncheckedUpdateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const QueueCreateManyArgsSchema: z.ZodType<Prisma.QueueCreateManyArgs> =
  z
    .object({
      data: z.union([
        QueueCreateManyInputSchema,
        QueueCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const QueueCreateManyAndReturnArgsSchema: z.ZodType<Prisma.QueueCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        QueueCreateManyInputSchema,
        QueueCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const QueueDeleteArgsSchema: z.ZodType<Prisma.QueueDeleteArgs> = z
  .object({
    select: QueueSelectSchema.optional(),
    include: QueueIncludeSchema.optional(),
    where: QueueWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const QueueUpdateArgsSchema: z.ZodType<Prisma.QueueUpdateArgs> = z
  .object({
    select: QueueSelectSchema.optional(),
    include: QueueIncludeSchema.optional(),
    data: z.union([QueueUpdateInputSchema, QueueUncheckedUpdateInputSchema]),
    where: QueueWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const QueueUpdateManyArgsSchema: z.ZodType<Prisma.QueueUpdateManyArgs> =
  z
    .object({
      data: z.union([
        QueueUpdateManyMutationInputSchema,
        QueueUncheckedUpdateManyInputSchema
      ]),
      where: QueueWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const QueueUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.QueueUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        QueueUpdateManyMutationInputSchema,
        QueueUncheckedUpdateManyInputSchema
      ]),
      where: QueueWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const QueueDeleteManyArgsSchema: z.ZodType<Prisma.QueueDeleteManyArgs> =
  z
    .object({
      where: QueueWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const ActionCreateArgsSchema: z.ZodType<Prisma.ActionCreateArgs> = z
  .object({
    select: ActionSelectSchema.optional(),
    include: ActionIncludeSchema.optional(),
    data: z.union([ActionCreateInputSchema, ActionUncheckedCreateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const ActionUpsertArgsSchema: z.ZodType<Prisma.ActionUpsertArgs> = z
  .object({
    select: ActionSelectSchema.optional(),
    include: ActionIncludeSchema.optional(),
    where: ActionWhereUniqueInputSchema,
    create: z.union([
      ActionCreateInputSchema,
      ActionUncheckedCreateInputSchema
    ]),
    update: z.union([
      ActionUpdateInputSchema,
      ActionUncheckedUpdateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const ActionCreateManyArgsSchema: z.ZodType<Prisma.ActionCreateManyArgs> =
  z
    .object({
      data: z.union([
        ActionCreateManyInputSchema,
        ActionCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ActionCreateManyAndReturnArgsSchema: z.ZodType<Prisma.ActionCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ActionCreateManyInputSchema,
        ActionCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ActionDeleteArgsSchema: z.ZodType<Prisma.ActionDeleteArgs> = z
  .object({
    select: ActionSelectSchema.optional(),
    include: ActionIncludeSchema.optional(),
    where: ActionWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const ActionUpdateArgsSchema: z.ZodType<Prisma.ActionUpdateArgs> = z
  .object({
    select: ActionSelectSchema.optional(),
    include: ActionIncludeSchema.optional(),
    data: z.union([ActionUpdateInputSchema, ActionUncheckedUpdateInputSchema]),
    where: ActionWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const ActionUpdateManyArgsSchema: z.ZodType<Prisma.ActionUpdateManyArgs> =
  z
    .object({
      data: z.union([
        ActionUpdateManyMutationInputSchema,
        ActionUncheckedUpdateManyInputSchema
      ]),
      where: ActionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const ActionUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.ActionUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ActionUpdateManyMutationInputSchema,
        ActionUncheckedUpdateManyInputSchema
      ]),
      where: ActionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const ActionDeleteManyArgsSchema: z.ZodType<Prisma.ActionDeleteManyArgs> =
  z
    .object({
      where: ActionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const WorkflowCreateArgsSchema: z.ZodType<Prisma.WorkflowCreateArgs> = z
  .object({
    select: WorkflowSelectSchema.optional(),
    include: WorkflowIncludeSchema.optional(),
    data: z.union([
      WorkflowCreateInputSchema,
      WorkflowUncheckedCreateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const WorkflowUpsertArgsSchema: z.ZodType<Prisma.WorkflowUpsertArgs> = z
  .object({
    select: WorkflowSelectSchema.optional(),
    include: WorkflowIncludeSchema.optional(),
    where: WorkflowWhereUniqueInputSchema,
    create: z.union([
      WorkflowCreateInputSchema,
      WorkflowUncheckedCreateInputSchema
    ]),
    update: z.union([
      WorkflowUpdateInputSchema,
      WorkflowUncheckedUpdateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const WorkflowCreateManyArgsSchema: z.ZodType<Prisma.WorkflowCreateManyArgs> =
  z
    .object({
      data: z.union([
        WorkflowCreateManyInputSchema,
        WorkflowCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const WorkflowCreateManyAndReturnArgsSchema: z.ZodType<Prisma.WorkflowCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        WorkflowCreateManyInputSchema,
        WorkflowCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const WorkflowDeleteArgsSchema: z.ZodType<Prisma.WorkflowDeleteArgs> = z
  .object({
    select: WorkflowSelectSchema.optional(),
    include: WorkflowIncludeSchema.optional(),
    where: WorkflowWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const WorkflowUpdateArgsSchema: z.ZodType<Prisma.WorkflowUpdateArgs> = z
  .object({
    select: WorkflowSelectSchema.optional(),
    include: WorkflowIncludeSchema.optional(),
    data: z.union([
      WorkflowUpdateInputSchema,
      WorkflowUncheckedUpdateInputSchema
    ]),
    where: WorkflowWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const WorkflowUpdateManyArgsSchema: z.ZodType<Prisma.WorkflowUpdateManyArgs> =
  z
    .object({
      data: z.union([
        WorkflowUpdateManyMutationInputSchema,
        WorkflowUncheckedUpdateManyInputSchema
      ]),
      where: WorkflowWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const WorkflowUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.WorkflowUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        WorkflowUpdateManyMutationInputSchema,
        WorkflowUncheckedUpdateManyInputSchema
      ]),
      where: WorkflowWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const WorkflowDeleteManyArgsSchema: z.ZodType<Prisma.WorkflowDeleteManyArgs> =
  z
    .object({
      where: WorkflowWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const TriggerCreateArgsSchema: z.ZodType<Prisma.TriggerCreateArgs> = z
  .object({
    select: TriggerSelectSchema.optional(),
    include: TriggerIncludeSchema.optional(),
    data: z.union([
      TriggerCreateInputSchema,
      TriggerUncheckedCreateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const TriggerUpsertArgsSchema: z.ZodType<Prisma.TriggerUpsertArgs> = z
  .object({
    select: TriggerSelectSchema.optional(),
    include: TriggerIncludeSchema.optional(),
    where: TriggerWhereUniqueInputSchema,
    create: z.union([
      TriggerCreateInputSchema,
      TriggerUncheckedCreateInputSchema
    ]),
    update: z.union([
      TriggerUpdateInputSchema,
      TriggerUncheckedUpdateInputSchema
    ]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const TriggerCreateManyArgsSchema: z.ZodType<Prisma.TriggerCreateManyArgs> =
  z
    .object({
      data: z.union([
        TriggerCreateManyInputSchema,
        TriggerCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const TriggerCreateManyAndReturnArgsSchema: z.ZodType<Prisma.TriggerCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        TriggerCreateManyInputSchema,
        TriggerCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const TriggerDeleteArgsSchema: z.ZodType<Prisma.TriggerDeleteArgs> = z
  .object({
    select: TriggerSelectSchema.optional(),
    include: TriggerIncludeSchema.optional(),
    where: TriggerWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const TriggerUpdateArgsSchema: z.ZodType<Prisma.TriggerUpdateArgs> = z
  .object({
    select: TriggerSelectSchema.optional(),
    include: TriggerIncludeSchema.optional(),
    data: z.union([
      TriggerUpdateInputSchema,
      TriggerUncheckedUpdateInputSchema
    ]),
    where: TriggerWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const TriggerUpdateManyArgsSchema: z.ZodType<Prisma.TriggerUpdateManyArgs> =
  z
    .object({
      data: z.union([
        TriggerUpdateManyMutationInputSchema,
        TriggerUncheckedUpdateManyInputSchema
      ]),
      where: TriggerWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const TriggerUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.TriggerUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        TriggerUpdateManyMutationInputSchema,
        TriggerUncheckedUpdateManyInputSchema
      ]),
      where: TriggerWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const TriggerDeleteManyArgsSchema: z.ZodType<Prisma.TriggerDeleteManyArgs> =
  z
    .object({
      where: TriggerWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const RuleCreateArgsSchema: z.ZodType<Prisma.RuleCreateArgs> = z
  .object({
    select: RuleSelectSchema.optional(),
    include: RuleIncludeSchema.optional(),
    data: z.union([RuleCreateInputSchema, RuleUncheckedCreateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const RuleUpsertArgsSchema: z.ZodType<Prisma.RuleUpsertArgs> = z
  .object({
    select: RuleSelectSchema.optional(),
    include: RuleIncludeSchema.optional(),
    where: RuleWhereUniqueInputSchema,
    create: z.union([RuleCreateInputSchema, RuleUncheckedCreateInputSchema]),
    update: z.union([RuleUpdateInputSchema, RuleUncheckedUpdateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const RuleCreateManyArgsSchema: z.ZodType<Prisma.RuleCreateManyArgs> = z
  .object({
    data: z.union([
      RuleCreateManyInputSchema,
      RuleCreateManyInputSchema.array()
    ]),
    skipDuplicates: z.boolean().optional()
  })
  .strict();

export const RuleCreateManyAndReturnArgsSchema: z.ZodType<Prisma.RuleCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        RuleCreateManyInputSchema,
        RuleCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const RuleDeleteArgsSchema: z.ZodType<Prisma.RuleDeleteArgs> = z
  .object({
    select: RuleSelectSchema.optional(),
    include: RuleIncludeSchema.optional(),
    where: RuleWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const RuleUpdateArgsSchema: z.ZodType<Prisma.RuleUpdateArgs> = z
  .object({
    select: RuleSelectSchema.optional(),
    include: RuleIncludeSchema.optional(),
    data: z.union([RuleUpdateInputSchema, RuleUncheckedUpdateInputSchema]),
    where: RuleWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const RuleUpdateManyArgsSchema: z.ZodType<Prisma.RuleUpdateManyArgs> = z
  .object({
    data: z.union([
      RuleUpdateManyMutationInputSchema,
      RuleUncheckedUpdateManyInputSchema
    ]),
    where: RuleWhereInputSchema.optional(),
    limit: z.number().optional()
  })
  .strict();

export const RuleUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.RuleUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        RuleUpdateManyMutationInputSchema,
        RuleUncheckedUpdateManyInputSchema
      ]),
      where: RuleWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const RuleDeleteManyArgsSchema: z.ZodType<Prisma.RuleDeleteManyArgs> = z
  .object({
    where: RuleWhereInputSchema.optional(),
    limit: z.number().optional()
  })
  .strict();

export const ConditionCreateArgsSchema: z.ZodType<Prisma.ConditionCreateArgs> =
  z
    .object({
      select: ConditionSelectSchema.optional(),
      include: ConditionIncludeSchema.optional(),
      data: z.union([
        ConditionCreateInputSchema,
        ConditionUncheckedCreateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ConditionUpsertArgsSchema: z.ZodType<Prisma.ConditionUpsertArgs> =
  z
    .object({
      select: ConditionSelectSchema.optional(),
      include: ConditionIncludeSchema.optional(),
      where: ConditionWhereUniqueInputSchema,
      create: z.union([
        ConditionCreateInputSchema,
        ConditionUncheckedCreateInputSchema
      ]),
      update: z.union([
        ConditionUpdateInputSchema,
        ConditionUncheckedUpdateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ConditionCreateManyArgsSchema: z.ZodType<Prisma.ConditionCreateManyArgs> =
  z
    .object({
      data: z.union([
        ConditionCreateManyInputSchema,
        ConditionCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ConditionCreateManyAndReturnArgsSchema: z.ZodType<Prisma.ConditionCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ConditionCreateManyInputSchema,
        ConditionCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ConditionDeleteArgsSchema: z.ZodType<Prisma.ConditionDeleteArgs> =
  z
    .object({
      select: ConditionSelectSchema.optional(),
      include: ConditionIncludeSchema.optional(),
      where: ConditionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ConditionUpdateArgsSchema: z.ZodType<Prisma.ConditionUpdateArgs> =
  z
    .object({
      select: ConditionSelectSchema.optional(),
      include: ConditionIncludeSchema.optional(),
      data: z.union([
        ConditionUpdateInputSchema,
        ConditionUncheckedUpdateInputSchema
      ]),
      where: ConditionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ConditionUpdateManyArgsSchema: z.ZodType<Prisma.ConditionUpdateManyArgs> =
  z
    .object({
      data: z.union([
        ConditionUpdateManyMutationInputSchema,
        ConditionUncheckedUpdateManyInputSchema
      ]),
      where: ConditionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const ConditionUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.ConditionUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ConditionUpdateManyMutationInputSchema,
        ConditionUncheckedUpdateManyInputSchema
      ]),
      where: ConditionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const ConditionDeleteManyArgsSchema: z.ZodType<Prisma.ConditionDeleteManyArgs> =
  z
    .object({
      where: ConditionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const RuleConditionCreateArgsSchema: z.ZodType<Prisma.RuleConditionCreateArgs> =
  z
    .object({
      select: RuleConditionSelectSchema.optional(),
      include: RuleConditionIncludeSchema.optional(),
      data: z.union([
        RuleConditionCreateInputSchema,
        RuleConditionUncheckedCreateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const RuleConditionUpsertArgsSchema: z.ZodType<Prisma.RuleConditionUpsertArgs> =
  z
    .object({
      select: RuleConditionSelectSchema.optional(),
      include: RuleConditionIncludeSchema.optional(),
      where: RuleConditionWhereUniqueInputSchema,
      create: z.union([
        RuleConditionCreateInputSchema,
        RuleConditionUncheckedCreateInputSchema
      ]),
      update: z.union([
        RuleConditionUpdateInputSchema,
        RuleConditionUncheckedUpdateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const RuleConditionCreateManyArgsSchema: z.ZodType<Prisma.RuleConditionCreateManyArgs> =
  z
    .object({
      data: z.union([
        RuleConditionCreateManyInputSchema,
        RuleConditionCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const RuleConditionCreateManyAndReturnArgsSchema: z.ZodType<Prisma.RuleConditionCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        RuleConditionCreateManyInputSchema,
        RuleConditionCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const RuleConditionDeleteArgsSchema: z.ZodType<Prisma.RuleConditionDeleteArgs> =
  z
    .object({
      select: RuleConditionSelectSchema.optional(),
      include: RuleConditionIncludeSchema.optional(),
      where: RuleConditionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const RuleConditionUpdateArgsSchema: z.ZodType<Prisma.RuleConditionUpdateArgs> =
  z
    .object({
      select: RuleConditionSelectSchema.optional(),
      include: RuleConditionIncludeSchema.optional(),
      data: z.union([
        RuleConditionUpdateInputSchema,
        RuleConditionUncheckedUpdateInputSchema
      ]),
      where: RuleConditionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const RuleConditionUpdateManyArgsSchema: z.ZodType<Prisma.RuleConditionUpdateManyArgs> =
  z
    .object({
      data: z.union([
        RuleConditionUpdateManyMutationInputSchema,
        RuleConditionUncheckedUpdateManyInputSchema
      ]),
      where: RuleConditionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const RuleConditionUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.RuleConditionUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        RuleConditionUpdateManyMutationInputSchema,
        RuleConditionUncheckedUpdateManyInputSchema
      ]),
      where: RuleConditionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const RuleConditionDeleteManyArgsSchema: z.ZodType<Prisma.RuleConditionDeleteManyArgs> =
  z
    .object({
      where: RuleConditionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const EventCreateArgsSchema: z.ZodType<Prisma.EventCreateArgs> = z
  .object({
    select: EventSelectSchema.optional(),
    include: EventIncludeSchema.optional(),
    data: z.union([EventCreateInputSchema, EventUncheckedCreateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const EventUpsertArgsSchema: z.ZodType<Prisma.EventUpsertArgs> = z
  .object({
    select: EventSelectSchema.optional(),
    include: EventIncludeSchema.optional(),
    where: EventWhereUniqueInputSchema,
    create: z.union([EventCreateInputSchema, EventUncheckedCreateInputSchema]),
    update: z.union([EventUpdateInputSchema, EventUncheckedUpdateInputSchema]),
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const EventCreateManyArgsSchema: z.ZodType<Prisma.EventCreateManyArgs> =
  z
    .object({
      data: z.union([
        EventCreateManyInputSchema,
        EventCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const EventCreateManyAndReturnArgsSchema: z.ZodType<Prisma.EventCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        EventCreateManyInputSchema,
        EventCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const EventDeleteArgsSchema: z.ZodType<Prisma.EventDeleteArgs> = z
  .object({
    select: EventSelectSchema.optional(),
    include: EventIncludeSchema.optional(),
    where: EventWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const EventUpdateArgsSchema: z.ZodType<Prisma.EventUpdateArgs> = z
  .object({
    select: EventSelectSchema.optional(),
    include: EventIncludeSchema.optional(),
    data: z.union([EventUpdateInputSchema, EventUncheckedUpdateInputSchema]),
    where: EventWhereUniqueInputSchema,
    relationLoadStrategy: RelationLoadStrategySchema.optional()
  })
  .strict();

export const EventUpdateManyArgsSchema: z.ZodType<Prisma.EventUpdateManyArgs> =
  z
    .object({
      data: z.union([
        EventUpdateManyMutationInputSchema,
        EventUncheckedUpdateManyInputSchema
      ]),
      where: EventWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const EventUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.EventUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        EventUpdateManyMutationInputSchema,
        EventUncheckedUpdateManyInputSchema
      ]),
      where: EventWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const EventDeleteManyArgsSchema: z.ZodType<Prisma.EventDeleteManyArgs> =
  z
    .object({
      where: EventWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const WorkflowStateCreateArgsSchema: z.ZodType<Prisma.WorkflowStateCreateArgs> =
  z
    .object({
      select: WorkflowStateSelectSchema.optional(),
      include: WorkflowStateIncludeSchema.optional(),
      data: z.union([
        WorkflowStateCreateInputSchema,
        WorkflowStateUncheckedCreateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const WorkflowStateUpsertArgsSchema: z.ZodType<Prisma.WorkflowStateUpsertArgs> =
  z
    .object({
      select: WorkflowStateSelectSchema.optional(),
      include: WorkflowStateIncludeSchema.optional(),
      where: WorkflowStateWhereUniqueInputSchema,
      create: z.union([
        WorkflowStateCreateInputSchema,
        WorkflowStateUncheckedCreateInputSchema
      ]),
      update: z.union([
        WorkflowStateUpdateInputSchema,
        WorkflowStateUncheckedUpdateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const WorkflowStateCreateManyArgsSchema: z.ZodType<Prisma.WorkflowStateCreateManyArgs> =
  z
    .object({
      data: z.union([
        WorkflowStateCreateManyInputSchema,
        WorkflowStateCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const WorkflowStateCreateManyAndReturnArgsSchema: z.ZodType<Prisma.WorkflowStateCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        WorkflowStateCreateManyInputSchema,
        WorkflowStateCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const WorkflowStateDeleteArgsSchema: z.ZodType<Prisma.WorkflowStateDeleteArgs> =
  z
    .object({
      select: WorkflowStateSelectSchema.optional(),
      include: WorkflowStateIncludeSchema.optional(),
      where: WorkflowStateWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const WorkflowStateUpdateArgsSchema: z.ZodType<Prisma.WorkflowStateUpdateArgs> =
  z
    .object({
      select: WorkflowStateSelectSchema.optional(),
      include: WorkflowStateIncludeSchema.optional(),
      data: z.union([
        WorkflowStateUpdateInputSchema,
        WorkflowStateUncheckedUpdateInputSchema
      ]),
      where: WorkflowStateWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const WorkflowStateUpdateManyArgsSchema: z.ZodType<Prisma.WorkflowStateUpdateManyArgs> =
  z
    .object({
      data: z.union([
        WorkflowStateUpdateManyMutationInputSchema,
        WorkflowStateUncheckedUpdateManyInputSchema
      ]),
      where: WorkflowStateWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const WorkflowStateUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.WorkflowStateUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        WorkflowStateUpdateManyMutationInputSchema,
        WorkflowStateUncheckedUpdateManyInputSchema
      ]),
      where: WorkflowStateWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const WorkflowStateDeleteManyArgsSchema: z.ZodType<Prisma.WorkflowStateDeleteManyArgs> =
  z
    .object({
      where: WorkflowStateWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const ExecutionCreateArgsSchema: z.ZodType<Prisma.ExecutionCreateArgs> =
  z
    .object({
      select: ExecutionSelectSchema.optional(),
      include: ExecutionIncludeSchema.optional(),
      data: z.union([
        ExecutionCreateInputSchema,
        ExecutionUncheckedCreateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ExecutionUpsertArgsSchema: z.ZodType<Prisma.ExecutionUpsertArgs> =
  z
    .object({
      select: ExecutionSelectSchema.optional(),
      include: ExecutionIncludeSchema.optional(),
      where: ExecutionWhereUniqueInputSchema,
      create: z.union([
        ExecutionCreateInputSchema,
        ExecutionUncheckedCreateInputSchema
      ]),
      update: z.union([
        ExecutionUpdateInputSchema,
        ExecutionUncheckedUpdateInputSchema
      ]),
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ExecutionCreateManyArgsSchema: z.ZodType<Prisma.ExecutionCreateManyArgs> =
  z
    .object({
      data: z.union([
        ExecutionCreateManyInputSchema,
        ExecutionCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ExecutionCreateManyAndReturnArgsSchema: z.ZodType<Prisma.ExecutionCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ExecutionCreateManyInputSchema,
        ExecutionCreateManyInputSchema.array()
      ]),
      skipDuplicates: z.boolean().optional()
    })
    .strict();

export const ExecutionDeleteArgsSchema: z.ZodType<Prisma.ExecutionDeleteArgs> =
  z
    .object({
      select: ExecutionSelectSchema.optional(),
      include: ExecutionIncludeSchema.optional(),
      where: ExecutionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ExecutionUpdateArgsSchema: z.ZodType<Prisma.ExecutionUpdateArgs> =
  z
    .object({
      select: ExecutionSelectSchema.optional(),
      include: ExecutionIncludeSchema.optional(),
      data: z.union([
        ExecutionUpdateInputSchema,
        ExecutionUncheckedUpdateInputSchema
      ]),
      where: ExecutionWhereUniqueInputSchema,
      relationLoadStrategy: RelationLoadStrategySchema.optional()
    })
    .strict();

export const ExecutionUpdateManyArgsSchema: z.ZodType<Prisma.ExecutionUpdateManyArgs> =
  z
    .object({
      data: z.union([
        ExecutionUpdateManyMutationInputSchema,
        ExecutionUncheckedUpdateManyInputSchema
      ]),
      where: ExecutionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const ExecutionUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.ExecutionUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ExecutionUpdateManyMutationInputSchema,
        ExecutionUncheckedUpdateManyInputSchema
      ]),
      where: ExecutionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();

export const ExecutionDeleteManyArgsSchema: z.ZodType<Prisma.ExecutionDeleteManyArgs> =
  z
    .object({
      where: ExecutionWhereInputSchema.optional(),
      limit: z.number().optional()
    })
    .strict();
